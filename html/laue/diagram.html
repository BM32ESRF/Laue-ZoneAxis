<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>laue.diagram API documentation</title>
<meta name="description" content="** Permet de manipuler un diagramme de Laue unique. **
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laue.diagram</code></h1>
</header>
<section id="section-intro">
<h2 id="permet-de-manipuler-un-diagramme-de-laue-unique"><strong> Permet de manipuler un diagramme de Laue unique. </strong></h2>
<h2 id="notes">Notes</h2>
<p>Si le module <code>psutil</code> est installe, la memoire sera mieux geree.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
** Permet de manipuler un diagramme de Laue unique. **
-----------------------------------------------------

Notes
-----
Si le module ``psutil`` est installe, la memoire sera mieux geree.
&#34;&#34;&#34;

import math
import os

import cv2
import numpy as np
try:
    import psutil # Pour acceder a la memoire disponible.
except ImportError:
    psutil = None

from laue.spot import Spot
from laue.tools.splitable import Splitable


__pdoc__ = {&#34;LaueDiagram.__contains__&#34;: True,
            &#34;LaueDiagram.__getitem__&#34;: True,
            &#34;LaueDiagram.__hash__&#34;: True,
            &#34;LaueDiagram.__iter__&#34;: True,
            &#34;LaueDiagram.__len__&#34;: True}


class LaueDiagram(Splitable):
    &#34;&#34;&#34;
    Represente un diagramme de Laue associe a une seule image.
    &#34;&#34;&#34;
    def __init__(self, name, spots, experiment, **kwargs):
        &#34;&#34;&#34;
        Notes
        -----
        * L&#39;utilisateur n&#39;a pas a generer des objets issus de cette classe.
        Ils sont generes automatiquement par des instances de ``laue.experiment.base_experiment.Experiment``.
        * Il n&#39;y a pas de verifications faites sur les entrees car l&#39;utilisateur
        ne doit pas toucher a l&#39;initialisateur. La performance passe donc avant
        l&#39;enorme mefiance envers les humains.

        Parameters
        ----------
        name : str
            Nom de l&#39;image du diagramme.
        spots : set
            Ensemble des points chauds. Ils doivent heriter de ``laue.spot.Spot``.
        experiment : Experiment
            Instance de l&#39;experience qui contient ce diagramme.
            Cet objet doit heriter de ``laue.experiment.base_experiment.Experiment``.
        image_xy : np.ndarray, optional
            Matrice numpy de l&#39;image de depart.
        &#34;&#34;&#34;
        self.name = name
        self.experiment = experiment # C&#39;est l&#39;experience qui contient ce diagramme.
        self.spots = spots # La liste des spots en vrac. Pas set car l&#39;ordre doit etre fige.
        self.image_xy = kwargs.get(&#34;image_xy&#34;, None) # None si il faut preserver la RAM.

        # Declaration des variables futur.
        self.quality = None # Facteur qui dit a quel point ce diagramme est joli a l&#39;oeil.
        self.image_gnom = None # Image projete dans le plan gnomonic.
        self.sorted_spots = {} # Les listes des spots tries selon un ordre particulier.
        self.axis = {} # Les axes de zones
        self.spots_set = None # L&#39;ensemble des spots pour une recherche plus rapide.

    def find_zone_axes(self, *, dmax=None, nbr=7, tol=None,
        _axes_args=None, _get_args=False):
        &#34;&#34;&#34;
        ** Cherche les axes de zone **

        Notes
        -----
        Si le but est d&#39;extraire les axes de zonnes de plusieurs diagrammes
        il vaut mieux appeler ``laue.experiment.base_experiment.Experiment.find_zone_axes`` car
        les calculs sont parallelises, contrairement a cette methode.

        Parameters
        ----------
        dmax : float, optional
            La distance maximale admissible entre un spot et un axe de zone
            pour pouvoir considerer que le spot appartient a l&#39;axe de zone.
            Par defaut cette valeur evolue lineairement entre 5 pxl pour
            les diagrammes contenants beaucoup de spots a 20 pxl pour les petits.
            avec ``n`` le nombre de spots dans le diagramme.
        tol : float, optional
            Alignement des points. Voir ``laue.geometry.Transformer.hough_reduce``
            pour avoir les informations precises sur &#39;tol&#39;. Par defaut
            cette valeur evolue exponentiellement entre 0.018 pour les diagrammes
            de 50 spots et 0.005 pour ceux de 600 spots.
        nbr : int, optional
            Nombre minimum de points par axe de zone.

        Returns
        -------
        axis : list
            La liste des axes de zone de type ``laue.zone_axis.ZoneAxis``.

        Examples
        -------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt; type(diag.find_zone_axes())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(diag.find_zone_axes().pop())
        &lt;class &#39;laue.zone_axis.ZoneAxis&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if dmax is None:
            pxl_max, pxl_min = 20, 5
            d_max, d_min = 1.2*pxl_max/2048, 1.2*pxl_min/2048
            dmax = max(.005, d_max - (d_max-d_min)/800 * len(self))
        if tol is None:
            a = 2.2865e-8
            b = -3.9201e-5
            c = .0205058
            tol = a*len(self)**2 + b*len(self) + c

        assert isinstance(dmax, float), \
            f&#34;&#39;dmax&#39; doit etre un flottant, pas un {type(dmax).__name__}.&#34;
        assert dmax &gt; 0, f&#34;La distance doit etre strictement positive elle vaut {dmax}.&#34;

        if _get_args: # Si il faut seulement preparer le travail.
            gnomonics = self.get_gnomonic_positions()
            return gnomonics, dmax, nbr, tol

        if (dmax, nbr, tol) in self.axis: # Si on a deja la solution.
            return self.axis[(dmax, nbr, tol)]

        if _axes_args is None: # Si le travail n&#39;est pas premache.
            from laue.zone_axis import _get_zone_axes_pickle
            angles, dists, axis_spots_ind, spots_axes_ind = _get_zone_axes_pickle(
                (self.experiment.transformer,
                self.get_gnomonic_positions(),
                dmax, nbr, tol))
        else:
            angles, dists, axis_spots_ind, spots_axes_ind = _axes_args

        # Creation des objets &#39;ZoneAxis&#39;.
        from laue.zone_axis import ZoneAxis
        self.axis[(dmax, nbr, tol)] = [
                ZoneAxis(diagram=self,
                     spots_ind=spots_ind,
                     identifier=i,
                     angle=angle,
                     dist=dist)
                for i, (angle, dist, spots_ind) in enumerate(zip(angles, dists, axis_spots_ind))]

        # Attribution des axes aux spots.
        for spot, axes_ind in zip(self, spots_axes_ind):
            spot.axes = {self.axis[(dmax, nbr, tol)][axis_ind] for axis_ind in axes_ind}
        return self.axis[(dmax, nbr, tol)]

    def get_image_gnomonic(self):
        &#34;&#34;&#34;
        ** Recupere le contenu de l&#39;image d&#39;un diagramme projete dans le plan gnomonic. **

        Notes
        -----
        Les parametres de set_calibration de la camera sont recuperes avec
        un appel a la fonction ``laue.experiment.base_experiment.Experiment.set_calibration()``.

        Returns
        -------
        image: np.ndarray(dtype=np.uint16)
            L&#39;image 2d en niveau de gris encodee en uint16.
        
        Raises
        ------
        NameError
            Si l&#39;image est introuvable.
        AttributError
            Si il manque des infos pour satisfaire cette demande.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt; diag.get_image_gnomonic()
        array([[0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               ...,
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.image_gnom is not None:
            return self.image_gnom

        # Interpolation inverse vers l&#39;image finale.
        map_x, map_y, _ = self.experiment._get_gnomonic_matrix()
        image_xy = self.get_image_xy()
        image_gnom = cv2.remap(image_xy,
            map_x, map_y, interpolation=cv2.INTER_LINEAR)

        if psutil is not None and psutil.virtual_memory().percent &lt; 75:
            self.image_gnom = image_gnom

        return image_gnom

    def get_image_xy(self):
        &#34;&#34;&#34;
        ** Recupere le contenu de l&#39;image d&#39;un diagramme. **

        Returns
        -------
        image : np.ndarray(dtype=np.uint16)
            L&#39;image 2d en niveau de gris encodee en uint16.
        
        Raises
        ------
        NameError
            Si l&#39;image est introuvable.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.get_image_xy()
        array([[0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               ...,
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
        &gt;&gt;&gt; diag.get_image_xy().max()
        28899
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.image_xy is not None:
            return self.image_xy

        if not os.path.exists(self.get_id()):
            raise NameError(f&#34;Impossible de trouver le fichier {repr(self.get_id())}.&#34;)

        from laue.tools.image import read_image
        image = read_image(self.get_id())

        if psutil is not None and psutil.virtual_memory().percent &lt; 75:
            self.image_xy = image

        return image

    def get_id(self):
        &#34;&#34;&#34;
        ** Retourne le nom du diagramme. **

        * Dans la mesure du possible, le nom du diagramme est le chemin
        d&#39;acces au fichier image qui a permis de constituer le diagramme.
        * Si le chemin d&#39;acces est inconnu, un nom par defaut unique est genere.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.get_id()
        &#39;laue/examples/ge_blanc.mccd&#39;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self.name

    def select_spots(self, *, n=None, sort=None):
        &#34;&#34;&#34;
        ** Recupere une partie des spots. **

        Notes
        -----
        Les pointeurs des spots renvoyes sont dupliques, c&#39;est une copie superficielle.
        Une suppression ou un ajout de spot dans la liste ne changera pas le diagramme
        par contre une modification d&#39;un attribut d&#39;un des spots va etre effectif,
        et modifira donc definitivement le spot considere.

        Parameters
        ----------
        n : int, optional
            Nombre de spots a considerer. La valeur ``None`` indique
            que tous les spots sont renvoyes.
        sort : str or callable, optional
            - None =&gt; Les spots ne sont pas tries (le plus rapide). Ils sont cedes dans
            un ordre quelquonque mais systematique. L&#39;ordre reste inchange entre 2 appels.
            - callable =&gt; Clef de tri, qui a chaque spot de type ``laue.spot.Spot``.
            associe un flotant. Les spots ayant des petits flottant se retrouveront
            au debut, ceux avec un gros seront en fin de chaine.
            - str =&gt; La methode de tri. Il y en a plusieurs possibles:
                - &#34;intensity&#34; =&gt; Les spots sont renvoyes par intensite decroissante.
                - &#34;distortion&#34; =&gt; Les spots sont renvoyes par distortion croissante.
                - &#34;quality&#34; =&gt; Les spots sont renvoyes par qualite decroissante.

        Returns
        -------
        list
            La liste des spots. Chaque element est de type ``laue.spot.Spot``.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.select_spots(n=2, sort=&#34;intensity&#34;)
        [Spot(bbox=(617, 1651, 11, 13), distortion=1.0760), Spot(bbox=(928, 1210, 10, 11), distortion=1.0673)]
        &gt;&gt;&gt; diag.select_spots(n=2, sort=&#34;distortion&#34;)
        [Spot(bbox=(928, 1210, 10, 11), distortion=1.0673), Spot(bbox=(617, 1651, 11, 13), distortion=1.0760)]
        &gt;&gt;&gt; diag.select_spots(n=2, sort=lambda spot: spot.get_position()[0])
        [Spot(bbox=(130, 1202, 5, 6), distortion=1.1804), Spot(bbox=(157, 905, 7, 6), distortion=1.1342)]
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert n is None or isinstance(n, int), f&#34;&#39;n&#39; can not be {type(n).__name__}.&#34;
        assert n is None or n &gt; 0, f&#34;&#39;n&#39; can not be {n}.&#34;
        assert (sort is None or hasattr(sort, &#34;__call__&#34;)
            or sort in {&#34;intensity&#34;, &#34;distortion&#34;, &#34;quality&#34;}), \
            f&#34;&#39;sort&#39; ne peut pas etre {sort}.&#34;

        if sort is None: # Si il n&#39;y a pas de tri a faire.
            if n is None:
                return self.spots.copy()
            return self.spots[:n]

        if hasattr(sort, &#34;__call__&#34;):
            l_spots = sorted(self.spots, key=sort)
        if sort in self.sorted_spots: # On enregistre la liste pour de melleur
            l_spots = self.sorted_spots[sort] #  perfs aux apels suivants.
        else:
            if sort == &#34;intensity&#34;:
                l_spots = sorted(self.spots, key=(lambda spot: -spot.get_intensity()))
            elif sort == &#34;distortion&#34;:
                l_spots = sorted(self.spots, key=(lambda spot: spot.get_distortion()))
            elif sort == &#34;quality&#34;:
                l_spots = sorted(self.spots, key=(lambda spot: -spot.get_quality()))
            self.sorted_spots[sort] = l_spots

        if n is not None:
            return l_spots[:n]
        return l_spots

    def get_positions(self, *, n=None, sort=None):
        &#34;&#34;&#34;
        ** Recupere la position des spots dans le plan de la camera. **

        Parameters
        ----------
        n : int, optional
            Same as ``LaueDiagram.select_spots``.
        sort : str or callable, optional
            Same as ``LaueDiagram.select_spots``.

        Returns
        -------
        np.ndarray
            * Le vecteur des coordonnees x puis le vecteur des y. (en pxl)
            * La shape de retour est (2, nbr_spots).
            * Les spots ne sont pas tries, l&#39;ordre est le meme que
            ``LaueDiagram.select_spots`` sans argument.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.get_positions().shape
        (2, 78)
        &gt;&gt;&gt; diag.get_positions(n=4, sort=lambda spot: spot.get_position()[0])
        array([[ 132.0286 ,  160.35379,  192.01744,  214.02731],
               [1204.656  ,  907.2095 , 1296.9255 ,  492.425  ]], dtype=float32)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return np.array(
            [spot.get_position() for spot in self.select_spots(n=n, sort=sort)],
            dtype=np.float32).transpose()

    def get_gnomonic_positions(self, *, n=None, sort=None):
        &#34;&#34;&#34;
        ** Recupere la position des spots dans le plan gnomonic. **

        Parameters
        ----------
        n : int, optional
            Same as ``LaueDiagram.select_spots``.
        sort : str or callable, optional
            Same as ``LaueDiagram.select_spots``.

        Returns
        -------
        coordonees : np.ndarray
            * Le vecteur des coordonnees x puis le vecteur y. (en mm)
            * La shape de retour est (2, nbr_spots)

        Raises
        ------
        AttributError
            Si il manque des infos pour satisfaire cette demande.
            En general l&#39;un des parametres de set_calibration.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt; diag.get_gnomonic_positions().shape
        (2, 78)
        &gt;&gt;&gt; diag.get_gnomonic_positions(n=4, sort=lambda spot: spot.get_position()[0])
        array([[-0.0978478 , -0.20958039, -0.04084784, -0.3524825 ],
               [ 0.5766271 ,  0.48377115,  0.56894475,  0.36476415]],
              dtype=float32)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # On calcul les projections pour tous les points a la fois.
        if self.spots[0].gnomonic is None:
            coord_gnomonic = self.experiment.transformer.cam_to_gnomonic(
                *self.get_positions(n=n, sort=sort),
                self.experiment.set_calibration())
            for spot, xg, yg in zip(self, *coord_gnomonic):
                spot.gnomonic = (xg, yg)
        # On extrait juste ce qu&#39;il nous interresse.
        else:
            coord_gnomonic = np.array(
                [spot.get_gnomonic() for spot in self.select_spots(n=n, sort=sort)],
                dtype=np.float32).transpose()

        return coord_gnomonic

    def get_quality(self):
        r&#34;&#34;&#34;
        ** Estime a quel point le diagramme est joli. **

        Returns
        -------
        quality : float
            * Un scalaire qui permet de juger de la purete du diagramme:
            * &lt; 1 =&gt; diagramme tres moche, illisible a l&#39;oeil.
            * &lt; 2 =&gt; diagramme pas bien joli.
            * &lt; 3 =&gt; diagramme bien joli, avec de belles taches.
            * \&gt; 3 =&gt; diagramme super joli, bien epure avec des taches rondes et intenses.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; print(f&#34;quality: {diag.get_quality():.4f}&#34;)
        quality: 1.2752
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def f_nbr(x, n_best_min, n_best_max):
            if x &lt; n_best_min:
                return x / n_best_min
            if n_best_min &lt;= x &lt; n_best_max:
                return 1
            return math.exp(-(x-n_best_max)*(math.log(2)/n_best_max))

        if self.quality is not None:
            return self.quality

        spot_quality = np.mean([spot.get_quality() for spot in self])
        self.quality = f_nbr(len(self), 60, 120) * spot_quality
        return self.quality

    def find_subsets(self, *args, **kwargs):
        &#34;&#34;&#34;
        ** Alias to ``laue.tools.splitable.Splitable.find_subsets``. **

        C&#39;est une methode abstraite definie dans la classe mere.
        &#34;&#34;&#34;
        return super().find_subsets(*args, **kwargs)

    def plot_all(self, *, display=True):
        &#34;&#34;&#34;
        ** Affiche le diagramme a l&#39;ecran. **

        * Utilise le module ``matplotlib`` qui doit etre installe.
        * Cette methode peut prendre du temps car elle affiche le maximum de choses possible.

        Parameters
        ----------
        display : boolean
            Si True, affiche a l&#39;ecran en faisant appel a ``plt.show()``.

        Returns
        -------
        matplotlib.figure.Figure
            La figure matplotlib completee.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt; diag.plot_all(display=False)
        &lt;Figure size 640x480 with 2 Axes&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        import matplotlib.pyplot as plt

        fig = plt.figure()
        fig.suptitle(self.get_id())
        axe_xy = fig.add_subplot(1, 2, 1)
        axe_gnomonic = fig.add_subplot(1, 2, 2)

        self.plot_xy(axe_xy, display=False)

        try:
            self.plot_gnomonic(axe_gnomonic, display=False)
        except AttributeError:
            pass

        if display:
            plt.show()

        return fig

    def plot_gnomonic(self, axe_pyplot=None, *, display=True):
        &#34;&#34;&#34;
        ** Prepare l&#39;affichage du diagramme dans le plan gnomonic. **

        Parameters
        ----------
        axe_pyplot : Axe
            Axe matplotlib qui supporte les methodes ``.scatter`` et ``.imshow``.
        display : boolean
            Si True, affiche a l&#39;ecran en faisant appel a ``plt.show()``.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt;
        &gt;&gt;&gt; diag.plot_gnomonic(display=False)
        &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan gnomonic&#39;}, xlabel=&#39;x.Gi (mm)&#39;, ylabel=&#39;y.Gj (mm)&#39;&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; fig = plt.figure()
        &gt;&gt;&gt; axe = fig.add_subplot()
        &gt;&gt;&gt; diag.plot_gnomonic(axe, display=False)
        &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan gnomonic&#39;}, xlabel=&#39;x.Gi (mm)&#39;, ylabel=&#39;y.Gj (mm)&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if axe_pyplot is None:
            import matplotlib.pyplot as plt
            axe_pyplot = plt.figure().add_subplot()

        axe_pyplot.set_title(&#34;plan gnomonic&#34;)
        axe_pyplot.set_xlabel(&#34;x.Gi (mm)&#34;)
        axe_pyplot.set_ylabel(&#34;y.Gj (mm)&#34;)

        # Affichage image de fond.
        try:
            image = self.get_image_gnomonic()
        except (NameError, AttributeError):
            pass
        else:
            *_, limits = self.experiment._get_gnomonic_matrix()
            mean, std = image.mean(), image.std()
            x_coords, y_coords = self.get_gnomonic_positions()
            axe_pyplot.imshow(image,
                origin=&#39;lower&#39;,
                aspect=((self.experiment.get_images_shape()[1]*x_coords.ptp())
                      / (self.experiment.get_images_shape()[0]*y_coords.ptp())),
                extent=limits,
                vmin=mean-2*std, vmax=mean+4*std, cmap=&#34;gray&#34;)

        # Affichage des axes.
        try:
            for axis in self.find_zone_axes():
                axe_pyplot = axis.plot_gnomonic(axe_pyplot, display=False)
        except AttributeError:
            return axe_pyplot

        # Affichage de spots.
        for spot in self:
            axe_pyplot = spot.plot_gnomonic(axe_pyplot, display=False)

        if display:
            import matplotlib.pyplot as plt
            plt.show()

        return axe_pyplot

    def plot_xy(self, axe_pyplot=None, *, display=True):
        &#34;&#34;&#34;
        ** Prepare l&#39;affichage du diagramme dans le plan du capteur. **

        Parameters
        ----------
        axe_pyplot : Axe
            Axe matplotlib qui supporte les methodes ``.scatter`` et ``.imshow``.
        display : boolean
            Si True, affiche a l&#39;ecran en faisant appel a ``plt.show()``.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt;
        &gt;&gt;&gt; diag.plot_xy(display=False)
        &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan camera&#39;}, xlabel=&#39;x.Ci (pxl)&#39;, ylabel=&#39;y.Cj (pxl)&#39;&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; fig = plt.figure()
        &gt;&gt;&gt; axe = fig.add_subplot()
        &gt;&gt;&gt; diag.plot_xy(axe, display=False)
        &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan camera&#39;}, xlabel=&#39;x.Ci (pxl)&#39;, ylabel=&#39;y.Cj (pxl)&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if axe_pyplot is None:
            import matplotlib.pyplot as plt
            axe_pyplot = plt.figure().add_subplot()

        axe_pyplot.set_title(&#34;plan camera&#34;)
        axe_pyplot.set_xlabel(&#34;x.Ci (pxl)&#34;)
        axe_pyplot.set_ylabel(&#34;y.Cj (pxl)&#34;)

        # Affichage image de fond.
        try:
            image = self.get_image_xy()
        except NameError:
            pass
        else:
            mean, std = image.mean(), image.std()
            axe_pyplot.imshow(image, vmin=mean-2*std, vmax=mean+4*std, cmap=&#34;gray&#34;)

        # Affichage des spots.
        for spot in self:
            axe_pyplot = spot.plot_xy(axe_pyplot, display=False)

        if display:
            import matplotlib.pyplot as plt
            plt.show()

        return axe_pyplot

    def save_file(self, filename):
        &#34;&#34;&#34;
        ** Enregistre un fichier contenant des informations. **

        Notes
        -----
        Les extensions prises en charge sont
        ``.dat``, ``.jpg``, ``.svg``, ``.png``

        Parameters
        ----------
        filename : str
            Nom ou chemin du fichier de destination.
            L&#39;extension doit etre comprise dans le nom du fichier.
            Si un fichier du meme nom existe deja, il est ecrase.

        Examples
        --------
        &gt;&gt;&gt; import os, tempfile
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt;
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; rep = tempfile.mkdtemp()
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.save_file(os.path.join(rep, &#34;ge_blanc.dat&#34;))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        EXT_OK = {&#34;dat&#34;, &#34;jpg&#34;, &#34;jpeg&#34;, &#34;svg&#34;, &#34;png&#34;}

        assert isinstance(filename, str), \
            f&#34;&#39;filename&#39; has to be a string, not a {type(filename).__name__}.&#34;
        assert &#34;.&#34; in filename, &#34;Le fichier doit posseder une extension.&#34;
        assert filename.split(&#34;.&#34;)[-1].lower() in EXT_OK, (&#34;Seul les extensions &#34;
            f&#34;&#39;{&#39;, &#39;.join(EXT_OK)}&#39; sont supportees. Pas &#39;.{filename.split(&#39;.&#39;)[-1]}&#39;.&#34;)

        ext = filename.split(&#34;.&#34;)[-1].lower()
        if ext == &#34;dat&#34;:
            with open(filename, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
                file.write(&#34;{:&lt;20} {:&lt;20} {:&lt;20}\n&#34;.format(&#34;spot_X&#34;, &#34;spot_Y&#34;, &#34;spot_I&#34;))
                for spot in self:
                    file.write(&#34;{x:&lt;20} {y:&lt;20} {i:&lt;20}\n&#34;.format(
                        x=spot.get_position()[0],
                        y=spot.get_position()[1],
                        i=spot.get_intensity()))
        elif ext in {&#34;jpg&#34;, &#34;jpeg&#34;, &#34;svg&#34;, &#34;png&#34;}:
            plt = self.show(_return=True)
            plt.savefig(filename)

    def _clean(self):
        &#34;&#34;&#34;
        ** Supprime les attributs superfux. **

        Si les spots sont modifies, cela permet de vider la memoire
        des informations desormais fausses. Si beaucoup d&#39;images
        sont enregistrees dans la RAM, cela permet de faire de la
        place en memoire.
        &#34;&#34;&#34;
        if os.path.exists(self.get_id()): # Il ne faut pas supprimer
            self.image_xy = None # une image que l&#39;on ne peut pas retrouver!
        self.quality = None
        self.image_gnom = None
        self.sorted_spots = {} # Si jamais la set_calibration ou un spot change.
        self.axis = {} # Les axis de zone depandent de beaucoup de choses, on reste donc prudent.
        self.spots_set = None # On libere de la memoire en faisant ca.
        for spot in self:
            spot._clean()

    def __contains__(self, spot):
        &#34;&#34;&#34;
        ** Verifie qu&#39;un spot fait bien parti de ce diagramme. **

        Parameters
        ----------
        spot : laue.spot.Spot, int
            L&#39;instance de spot dont on cherche a savoir
            si il est present ou pas. Ou bien l&#39;index de ce spot.

        Returns
        -------
        boolean
            True si le spot est present dans ce diagramme, False sinon.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt;
        &gt;&gt;&gt; len(diag)
        78
        &gt;&gt;&gt; 77 in diag
        True
        &gt;&gt;&gt; 78 in diag
        False
        &gt;&gt;&gt;
        &gt;&gt;&gt; spot = diag[0]
        &gt;&gt;&gt; spot
        Spot(bbox=(1368, 1873, 6, 5), distortion=1.1804)
        &gt;&gt;&gt; spot in diag
        True
        &gt;&gt;&gt; 
        &#34;&#34;&#34;
        assert isinstance(spot, (Spot, int)), (&#34;&#39;spot&#39; has to be an &#34;
            f&#34;instance of Spot or int, not {type(spot).__name__}.&#34;)

        if isinstance(spot, int):
            if spot &lt; 0 or spot &gt;= len(self):
                return False
            spot = self[spot]

        if self.spots_set is None:
            self.spots_set = set(self)
        return spot in self.spots_set

    def __getitem__(self, items):
        &#34;&#34;&#34;
        ** Permet de recuperer des elements. **

        Parameters
        ----------
        items : int, slice, tuple, laue.spot.Spot
            C&#39;est un element qui permet de choisir un ou plusieurs
            spot dans ce diagram de laue.

        Returns
        -------
        spots : list, laue.spot.Spot
            - L&#39;element renvoye depend du parametre d&#39;entree ``items``:
                - int =&gt; Renvoi le item(ieme) spot. Comme si un
                ``LaueDiagram`` etait une liste de ``laue.spot.Spot``.
                    - Type renvoye: ``laue.spot.Spot``.
                - slice =&gt; Renvoi la liste des spots compris dans
                l&#39;intervalle fournit. Comme si ``LaueDiagram`` est aussi une liste.
                    - Type renvoye: ``list``.
                - tuple =&gt; Cherche un spot ou plusieur selon une notion de distance.
                    - Le premier et/ou deuxieme argument peut etre un spot ou bien 2 nombres x et y.
                    - Le troisieme argument (factultatif) permet de preciser l&#39;espace
                    et la metrique a utiliser pour comparer les spots a la reference.
                    C&#39;est une chaine de caracetere expicite:
                        - &#34;camera&#34; (valeur par defaut si x et y de type ``int``
                        ou que le premier argument est un spot) =&gt;
                        Distance euclidiene dans le plan de la camera (pxl).
                        - &#34;gnomonic&#34; (valeur par defaut si x et y de type ``float``) =&gt;
                        Distance euclidiene dans le plan gnomonique (mm).
                        - &#34;angle&#34; =&gt; Cosine distance entre les vecteurs ``uq`` (axe de reflexion)
                        de chaquns des points (en degre).
                        Le premier argument est interprete comme ``2*theta`` et le second comme ``chi``.
                    - Le quatrieme argument correspond au nombre de voisins a prendre.
                    La valeur par defaut est 1. Cet argument doit etre un entier positif.
                    - Type renvoye: ``list``.
                - spot =&gt; equivalent a ``self[spot, &#34;camera&#34;]``.

        Raises
        ------
        IndexError
            Si aucun spot n&#39;est quandidat ou qu&#39;on shouaite acceder a un spot qui n&#39;existe pas.
        ValueError
            Si les arguments fournis ne sont pas conformes.

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(diag[0])
        &lt;class &#39;laue.spot.Spot&#39;&gt;
        &gt;&gt;&gt; type(diag[3:22]), len(diag[3:22])
        (&lt;class &#39;list&#39;&gt;, 19)
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(diag[500, 700]), len(diag[500, 700])
        (&lt;class &#39;list&#39;&gt;, 1)
        &gt;&gt;&gt; np.round(diag[500, 700].pop().get_position(), 3)
        array([521.018, 724.495])
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(diag[.2, -.3]), len(diag[.2, -.3])
        (&lt;class &#39;list&#39;&gt;, 1)
        &gt;&gt;&gt; np.round(diag[.2, -.3].pop().get_gnomonic(), 3)
        array([ 0.266, -0.299])
        &gt;&gt;&gt;
        &gt;&gt;&gt; len(diag[0.2, .5, &#34;gnomonic&#34;, 6])
        6
        &gt;&gt;&gt; np.array([d.get_gnomonic() for d in diag[0.2, .5, &#34;gnomonic&#34;, 3]])
        array([[0.29464949, 0.39670733],
               [0.06846284, 0.55485944],
               [0.07130572, 0.41748433]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if isinstance(items, (int, np.integer)):
            return self.spots[items]

        if isinstance(items, slice):
            return self.spots[items]

        if isinstance(items, tuple):
            if not items:
                raise ValueError(&#34;Vous ne pouvez pas fournir un tuple vide.&#34;)

            # Recuperation des informations.
            if isinstance(items[0], Spot):
                spot, *infos = items

                # Recherche de la metrique
                if not infos or infos[0] is None:
                    if infos:
                        _, *infos = infos
                    space = &#34;camera&#34;
                else:
                    space, *infos = infos

                x, y = {&#34;camera&#34;: lambda spot: spot.get_position(),
                        &#34;gnomonic&#34;: lambda spot: spot.get_gnomonic(),
                        &#34;angle&#34;: lambda spot: spot.get_twicetheta_chi()
                        }.get(space, lambda spot: (None, None))[spot]
            else:
                if len(items) &lt; 2:
                    raise ValueError(&#34;Si vous chercher a recuperer les spots&#34;
                        &#34;d&#39;un voisinage, vous devez fournir au moins 2 arguments\n.&#34;
                        f&#34;Or il y en a {len(items)}.&#34;)
                x, y, *infos = items

                # Recherche de la metrique
                if type(x) != type(y):
                    raise ValueError(&#34;Les 2 premieres coordonnees doivent etre homogenes&#34;)
                if not isinstance(x, (int, float)):
                    raise ValueError(&#34;Les 2 premiers elements doivent etre de type int ou float, &#34;
                        f&#34;pas de type {type(x).__name__}.&#34;)
                if not infos or infos[0] is None:
                    if infos:
                        _, *infos = infos
                    space = &#34;camera&#34; if isinstance(x, int) else &#34;gnomonic&#34;
                else:
                    space, *infos = infos

            # Recherche du nombre de voisins.
            if not infos or infos[0] is None:
                if infos:
                    _, *infos = infos
                nbr_voisins = 1
            else:
                nbr_voisins, *infos = infos

            # Verifications
            if not isinstance(nbr_voisins, int):
                raise ValueError(&#34;Le nombre de voisin doit etre un entier, &#34;
                    f&#34;pas {type(nbr_voisins).__name__}&#34;)
            if nbr_voisins &lt; 1:
                raise ValueError(&#34;Le nombre de voisin doit etre strictement positif.&#34;)
            if space not in {&#34;camera&#34;, &#34;gnomonic&#34;, &#34;angle&#34;}:
                raise ValueError(&#34;Le dernier argument ne peut etre que &#34;
                    f&#34;&#39;camera&#39;, &#39;gnomonic&#39; ou &#39;angle&#39;. Pas {repr(space)}&#34;)
            if infos:
                raise ValueError(&#34;Il y a trop de parametres.&#34;)

            # Recherche des voisins
            from laue.spot import distance

            d_list = distance((x, y), self.select_spots(), space=space)
            if nbr_voisins == 1:
                return [self.spots[np.argmin(d_list)]]
            return [self.spots[spot_ind] for spot_ind in np.argsort(d_list)[:nbr_voisins]]

        if isinstance(items, Spot):
            return self[items, None, None]

        raise ValueError(&#34;Seul les types &#39;int&#39;, &#39;slice&#39;, &#39;tuple&#39; et &#39;Spot&#39; sont supportees. &#34;
            f&#34;Or le type fourni est {type(items).__name__}.&#34;)

    def __hash__(self):
        &#34;&#34;&#34;
        ** Fonction de hachage. **

        Permet de faire un ``dict`` ou un ``set`` avec
        des instances de ``LaueDiagram``.
        &#34;&#34;&#34;
        return hash(self.get_id())

    def __iter__(self):
        &#34;&#34;&#34;
        ** Permet d&#39;iterer sur les spots. **

        Yields
        ------
        Spot
            Cede les instances des spots qui constituent
            ce diagramme dans un ordre indetermine mais invariant.
            Ces instances heritent de la classe ``laue.spot.Spot``.
            Seul les pointeurs sont cedes, ce qui implique que toute
            modification d&#39;un spot sera globale.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; for spot in diag:
        ...     pass
        ...
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        yield from self.spots

    def __len__(self):
        &#34;&#34;&#34;
        ** Renvoi le nombre de spots. **

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; len(diag)
        78
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return len(self.spots)

    def __str__(self):
        &#34;&#34;&#34;
        ** Renvoi une jolie representation du diagramme de Laue. **
        &#34;&#34;&#34;
        return (&#34;LaueDiagram:\n&#34;
                f&#34;\tname: {self.get_id()}\n&#34;
                f&#34;\tnbr spots: {len(self.select_spots())}\n&#34;
                f&#34;\tquality: {self.get_quality()}&#34;)

    def __repr__(self):
        &#34;&#34;&#34;
        ** Renvoi une chaine evaluable de self. **
        &#34;&#34;&#34;
        return (&#34;LaueDiagram(&#34;
                f&#34;name={repr(self.get_id())}, &#34;
                f&#34;experiment={repr(self.experiment)})&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laue.diagram.LaueDiagram"><code class="flex name class">
<span>class <span class="ident">LaueDiagram</span></span>
<span>(</span><span>name, spots, experiment, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Represente un diagramme de Laue associe a une seule image.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>L'utilisateur n'a pas a generer des objets issus de cette classe.
Ils sont generes automatiquement par des instances de <code><a title="laue.experiment.base_experiment.Experiment" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment">Experiment</a></code>.</li>
<li>Il n'y a pas de verifications faites sur les entrees car l'utilisateur
ne doit pas toucher a l'initialisateur. La performance passe donc avant
l'enorme mefiance envers les humains.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Nom de l'image du diagramme.</dd>
<dt><strong><code>spots</code></strong> :&ensp;<code>set</code></dt>
<dd>Ensemble des points chauds. Ils doivent heriter de <code><a title="laue.spot.Spot" href="spot.html#laue.spot.Spot">Spot</a></code>.</dd>
<dt><strong><code>experiment</code></strong> :&ensp;<code>Experiment</code></dt>
<dd>Instance de l'experience qui contient ce diagramme.
Cet objet doit heriter de <code><a title="laue.experiment.base_experiment.Experiment" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment">Experiment</a></code>.</dd>
<dt><strong><code>image_xy</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>Matrice numpy de l'image de depart.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LaueDiagram(Splitable):
    &#34;&#34;&#34;
    Represente un diagramme de Laue associe a une seule image.
    &#34;&#34;&#34;
    def __init__(self, name, spots, experiment, **kwargs):
        &#34;&#34;&#34;
        Notes
        -----
        * L&#39;utilisateur n&#39;a pas a generer des objets issus de cette classe.
        Ils sont generes automatiquement par des instances de ``laue.experiment.base_experiment.Experiment``.
        * Il n&#39;y a pas de verifications faites sur les entrees car l&#39;utilisateur
        ne doit pas toucher a l&#39;initialisateur. La performance passe donc avant
        l&#39;enorme mefiance envers les humains.

        Parameters
        ----------
        name : str
            Nom de l&#39;image du diagramme.
        spots : set
            Ensemble des points chauds. Ils doivent heriter de ``laue.spot.Spot``.
        experiment : Experiment
            Instance de l&#39;experience qui contient ce diagramme.
            Cet objet doit heriter de ``laue.experiment.base_experiment.Experiment``.
        image_xy : np.ndarray, optional
            Matrice numpy de l&#39;image de depart.
        &#34;&#34;&#34;
        self.name = name
        self.experiment = experiment # C&#39;est l&#39;experience qui contient ce diagramme.
        self.spots = spots # La liste des spots en vrac. Pas set car l&#39;ordre doit etre fige.
        self.image_xy = kwargs.get(&#34;image_xy&#34;, None) # None si il faut preserver la RAM.

        # Declaration des variables futur.
        self.quality = None # Facteur qui dit a quel point ce diagramme est joli a l&#39;oeil.
        self.image_gnom = None # Image projete dans le plan gnomonic.
        self.sorted_spots = {} # Les listes des spots tries selon un ordre particulier.
        self.axis = {} # Les axes de zones
        self.spots_set = None # L&#39;ensemble des spots pour une recherche plus rapide.

    def find_zone_axes(self, *, dmax=None, nbr=7, tol=None,
        _axes_args=None, _get_args=False):
        &#34;&#34;&#34;
        ** Cherche les axes de zone **

        Notes
        -----
        Si le but est d&#39;extraire les axes de zonnes de plusieurs diagrammes
        il vaut mieux appeler ``laue.experiment.base_experiment.Experiment.find_zone_axes`` car
        les calculs sont parallelises, contrairement a cette methode.

        Parameters
        ----------
        dmax : float, optional
            La distance maximale admissible entre un spot et un axe de zone
            pour pouvoir considerer que le spot appartient a l&#39;axe de zone.
            Par defaut cette valeur evolue lineairement entre 5 pxl pour
            les diagrammes contenants beaucoup de spots a 20 pxl pour les petits.
            avec ``n`` le nombre de spots dans le diagramme.
        tol : float, optional
            Alignement des points. Voir ``laue.geometry.Transformer.hough_reduce``
            pour avoir les informations precises sur &#39;tol&#39;. Par defaut
            cette valeur evolue exponentiellement entre 0.018 pour les diagrammes
            de 50 spots et 0.005 pour ceux de 600 spots.
        nbr : int, optional
            Nombre minimum de points par axe de zone.

        Returns
        -------
        axis : list
            La liste des axes de zone de type ``laue.zone_axis.ZoneAxis``.

        Examples
        -------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt; type(diag.find_zone_axes())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(diag.find_zone_axes().pop())
        &lt;class &#39;laue.zone_axis.ZoneAxis&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if dmax is None:
            pxl_max, pxl_min = 20, 5
            d_max, d_min = 1.2*pxl_max/2048, 1.2*pxl_min/2048
            dmax = max(.005, d_max - (d_max-d_min)/800 * len(self))
        if tol is None:
            a = 2.2865e-8
            b = -3.9201e-5
            c = .0205058
            tol = a*len(self)**2 + b*len(self) + c

        assert isinstance(dmax, float), \
            f&#34;&#39;dmax&#39; doit etre un flottant, pas un {type(dmax).__name__}.&#34;
        assert dmax &gt; 0, f&#34;La distance doit etre strictement positive elle vaut {dmax}.&#34;

        if _get_args: # Si il faut seulement preparer le travail.
            gnomonics = self.get_gnomonic_positions()
            return gnomonics, dmax, nbr, tol

        if (dmax, nbr, tol) in self.axis: # Si on a deja la solution.
            return self.axis[(dmax, nbr, tol)]

        if _axes_args is None: # Si le travail n&#39;est pas premache.
            from laue.zone_axis import _get_zone_axes_pickle
            angles, dists, axis_spots_ind, spots_axes_ind = _get_zone_axes_pickle(
                (self.experiment.transformer,
                self.get_gnomonic_positions(),
                dmax, nbr, tol))
        else:
            angles, dists, axis_spots_ind, spots_axes_ind = _axes_args

        # Creation des objets &#39;ZoneAxis&#39;.
        from laue.zone_axis import ZoneAxis
        self.axis[(dmax, nbr, tol)] = [
                ZoneAxis(diagram=self,
                     spots_ind=spots_ind,
                     identifier=i,
                     angle=angle,
                     dist=dist)
                for i, (angle, dist, spots_ind) in enumerate(zip(angles, dists, axis_spots_ind))]

        # Attribution des axes aux spots.
        for spot, axes_ind in zip(self, spots_axes_ind):
            spot.axes = {self.axis[(dmax, nbr, tol)][axis_ind] for axis_ind in axes_ind}
        return self.axis[(dmax, nbr, tol)]

    def get_image_gnomonic(self):
        &#34;&#34;&#34;
        ** Recupere le contenu de l&#39;image d&#39;un diagramme projete dans le plan gnomonic. **

        Notes
        -----
        Les parametres de set_calibration de la camera sont recuperes avec
        un appel a la fonction ``laue.experiment.base_experiment.Experiment.set_calibration()``.

        Returns
        -------
        image: np.ndarray(dtype=np.uint16)
            L&#39;image 2d en niveau de gris encodee en uint16.
        
        Raises
        ------
        NameError
            Si l&#39;image est introuvable.
        AttributError
            Si il manque des infos pour satisfaire cette demande.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt; diag.get_image_gnomonic()
        array([[0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               ...,
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.image_gnom is not None:
            return self.image_gnom

        # Interpolation inverse vers l&#39;image finale.
        map_x, map_y, _ = self.experiment._get_gnomonic_matrix()
        image_xy = self.get_image_xy()
        image_gnom = cv2.remap(image_xy,
            map_x, map_y, interpolation=cv2.INTER_LINEAR)

        if psutil is not None and psutil.virtual_memory().percent &lt; 75:
            self.image_gnom = image_gnom

        return image_gnom

    def get_image_xy(self):
        &#34;&#34;&#34;
        ** Recupere le contenu de l&#39;image d&#39;un diagramme. **

        Returns
        -------
        image : np.ndarray(dtype=np.uint16)
            L&#39;image 2d en niveau de gris encodee en uint16.
        
        Raises
        ------
        NameError
            Si l&#39;image est introuvable.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.get_image_xy()
        array([[0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               ...,
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0],
               [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
        &gt;&gt;&gt; diag.get_image_xy().max()
        28899
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.image_xy is not None:
            return self.image_xy

        if not os.path.exists(self.get_id()):
            raise NameError(f&#34;Impossible de trouver le fichier {repr(self.get_id())}.&#34;)

        from laue.tools.image import read_image
        image = read_image(self.get_id())

        if psutil is not None and psutil.virtual_memory().percent &lt; 75:
            self.image_xy = image

        return image

    def get_id(self):
        &#34;&#34;&#34;
        ** Retourne le nom du diagramme. **

        * Dans la mesure du possible, le nom du diagramme est le chemin
        d&#39;acces au fichier image qui a permis de constituer le diagramme.
        * Si le chemin d&#39;acces est inconnu, un nom par defaut unique est genere.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.get_id()
        &#39;laue/examples/ge_blanc.mccd&#39;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self.name

    def select_spots(self, *, n=None, sort=None):
        &#34;&#34;&#34;
        ** Recupere une partie des spots. **

        Notes
        -----
        Les pointeurs des spots renvoyes sont dupliques, c&#39;est une copie superficielle.
        Une suppression ou un ajout de spot dans la liste ne changera pas le diagramme
        par contre une modification d&#39;un attribut d&#39;un des spots va etre effectif,
        et modifira donc definitivement le spot considere.

        Parameters
        ----------
        n : int, optional
            Nombre de spots a considerer. La valeur ``None`` indique
            que tous les spots sont renvoyes.
        sort : str or callable, optional
            - None =&gt; Les spots ne sont pas tries (le plus rapide). Ils sont cedes dans
            un ordre quelquonque mais systematique. L&#39;ordre reste inchange entre 2 appels.
            - callable =&gt; Clef de tri, qui a chaque spot de type ``laue.spot.Spot``.
            associe un flotant. Les spots ayant des petits flottant se retrouveront
            au debut, ceux avec un gros seront en fin de chaine.
            - str =&gt; La methode de tri. Il y en a plusieurs possibles:
                - &#34;intensity&#34; =&gt; Les spots sont renvoyes par intensite decroissante.
                - &#34;distortion&#34; =&gt; Les spots sont renvoyes par distortion croissante.
                - &#34;quality&#34; =&gt; Les spots sont renvoyes par qualite decroissante.

        Returns
        -------
        list
            La liste des spots. Chaque element est de type ``laue.spot.Spot``.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.select_spots(n=2, sort=&#34;intensity&#34;)
        [Spot(bbox=(617, 1651, 11, 13), distortion=1.0760), Spot(bbox=(928, 1210, 10, 11), distortion=1.0673)]
        &gt;&gt;&gt; diag.select_spots(n=2, sort=&#34;distortion&#34;)
        [Spot(bbox=(928, 1210, 10, 11), distortion=1.0673), Spot(bbox=(617, 1651, 11, 13), distortion=1.0760)]
        &gt;&gt;&gt; diag.select_spots(n=2, sort=lambda spot: spot.get_position()[0])
        [Spot(bbox=(130, 1202, 5, 6), distortion=1.1804), Spot(bbox=(157, 905, 7, 6), distortion=1.1342)]
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert n is None or isinstance(n, int), f&#34;&#39;n&#39; can not be {type(n).__name__}.&#34;
        assert n is None or n &gt; 0, f&#34;&#39;n&#39; can not be {n}.&#34;
        assert (sort is None or hasattr(sort, &#34;__call__&#34;)
            or sort in {&#34;intensity&#34;, &#34;distortion&#34;, &#34;quality&#34;}), \
            f&#34;&#39;sort&#39; ne peut pas etre {sort}.&#34;

        if sort is None: # Si il n&#39;y a pas de tri a faire.
            if n is None:
                return self.spots.copy()
            return self.spots[:n]

        if hasattr(sort, &#34;__call__&#34;):
            l_spots = sorted(self.spots, key=sort)
        if sort in self.sorted_spots: # On enregistre la liste pour de melleur
            l_spots = self.sorted_spots[sort] #  perfs aux apels suivants.
        else:
            if sort == &#34;intensity&#34;:
                l_spots = sorted(self.spots, key=(lambda spot: -spot.get_intensity()))
            elif sort == &#34;distortion&#34;:
                l_spots = sorted(self.spots, key=(lambda spot: spot.get_distortion()))
            elif sort == &#34;quality&#34;:
                l_spots = sorted(self.spots, key=(lambda spot: -spot.get_quality()))
            self.sorted_spots[sort] = l_spots

        if n is not None:
            return l_spots[:n]
        return l_spots

    def get_positions(self, *, n=None, sort=None):
        &#34;&#34;&#34;
        ** Recupere la position des spots dans le plan de la camera. **

        Parameters
        ----------
        n : int, optional
            Same as ``LaueDiagram.select_spots``.
        sort : str or callable, optional
            Same as ``LaueDiagram.select_spots``.

        Returns
        -------
        np.ndarray
            * Le vecteur des coordonnees x puis le vecteur des y. (en pxl)
            * La shape de retour est (2, nbr_spots).
            * Les spots ne sont pas tries, l&#39;ordre est le meme que
            ``LaueDiagram.select_spots`` sans argument.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.get_positions().shape
        (2, 78)
        &gt;&gt;&gt; diag.get_positions(n=4, sort=lambda spot: spot.get_position()[0])
        array([[ 132.0286 ,  160.35379,  192.01744,  214.02731],
               [1204.656  ,  907.2095 , 1296.9255 ,  492.425  ]], dtype=float32)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return np.array(
            [spot.get_position() for spot in self.select_spots(n=n, sort=sort)],
            dtype=np.float32).transpose()

    def get_gnomonic_positions(self, *, n=None, sort=None):
        &#34;&#34;&#34;
        ** Recupere la position des spots dans le plan gnomonic. **

        Parameters
        ----------
        n : int, optional
            Same as ``LaueDiagram.select_spots``.
        sort : str or callable, optional
            Same as ``LaueDiagram.select_spots``.

        Returns
        -------
        coordonees : np.ndarray
            * Le vecteur des coordonnees x puis le vecteur y. (en mm)
            * La shape de retour est (2, nbr_spots)

        Raises
        ------
        AttributError
            Si il manque des infos pour satisfaire cette demande.
            En general l&#39;un des parametres de set_calibration.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt; diag.get_gnomonic_positions().shape
        (2, 78)
        &gt;&gt;&gt; diag.get_gnomonic_positions(n=4, sort=lambda spot: spot.get_position()[0])
        array([[-0.0978478 , -0.20958039, -0.04084784, -0.3524825 ],
               [ 0.5766271 ,  0.48377115,  0.56894475,  0.36476415]],
              dtype=float32)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # On calcul les projections pour tous les points a la fois.
        if self.spots[0].gnomonic is None:
            coord_gnomonic = self.experiment.transformer.cam_to_gnomonic(
                *self.get_positions(n=n, sort=sort),
                self.experiment.set_calibration())
            for spot, xg, yg in zip(self, *coord_gnomonic):
                spot.gnomonic = (xg, yg)
        # On extrait juste ce qu&#39;il nous interresse.
        else:
            coord_gnomonic = np.array(
                [spot.get_gnomonic() for spot in self.select_spots(n=n, sort=sort)],
                dtype=np.float32).transpose()

        return coord_gnomonic

    def get_quality(self):
        r&#34;&#34;&#34;
        ** Estime a quel point le diagramme est joli. **

        Returns
        -------
        quality : float
            * Un scalaire qui permet de juger de la purete du diagramme:
            * &lt; 1 =&gt; diagramme tres moche, illisible a l&#39;oeil.
            * &lt; 2 =&gt; diagramme pas bien joli.
            * &lt; 3 =&gt; diagramme bien joli, avec de belles taches.
            * \&gt; 3 =&gt; diagramme super joli, bien epure avec des taches rondes et intenses.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; print(f&#34;quality: {diag.get_quality():.4f}&#34;)
        quality: 1.2752
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def f_nbr(x, n_best_min, n_best_max):
            if x &lt; n_best_min:
                return x / n_best_min
            if n_best_min &lt;= x &lt; n_best_max:
                return 1
            return math.exp(-(x-n_best_max)*(math.log(2)/n_best_max))

        if self.quality is not None:
            return self.quality

        spot_quality = np.mean([spot.get_quality() for spot in self])
        self.quality = f_nbr(len(self), 60, 120) * spot_quality
        return self.quality

    def find_subsets(self, *args, **kwargs):
        &#34;&#34;&#34;
        ** Alias to ``laue.tools.splitable.Splitable.find_subsets``. **

        C&#39;est une methode abstraite definie dans la classe mere.
        &#34;&#34;&#34;
        return super().find_subsets(*args, **kwargs)

    def plot_all(self, *, display=True):
        &#34;&#34;&#34;
        ** Affiche le diagramme a l&#39;ecran. **

        * Utilise le module ``matplotlib`` qui doit etre installe.
        * Cette methode peut prendre du temps car elle affiche le maximum de choses possible.

        Parameters
        ----------
        display : boolean
            Si True, affiche a l&#39;ecran en faisant appel a ``plt.show()``.

        Returns
        -------
        matplotlib.figure.Figure
            La figure matplotlib completee.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt; diag.plot_all(display=False)
        &lt;Figure size 640x480 with 2 Axes&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        import matplotlib.pyplot as plt

        fig = plt.figure()
        fig.suptitle(self.get_id())
        axe_xy = fig.add_subplot(1, 2, 1)
        axe_gnomonic = fig.add_subplot(1, 2, 2)

        self.plot_xy(axe_xy, display=False)

        try:
            self.plot_gnomonic(axe_gnomonic, display=False)
        except AttributeError:
            pass

        if display:
            plt.show()

        return fig

    def plot_gnomonic(self, axe_pyplot=None, *, display=True):
        &#34;&#34;&#34;
        ** Prepare l&#39;affichage du diagramme dans le plan gnomonic. **

        Parameters
        ----------
        axe_pyplot : Axe
            Axe matplotlib qui supporte les methodes ``.scatter`` et ``.imshow``.
        display : boolean
            Si True, affiche a l&#39;ecran en faisant appel a ``plt.show()``.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt;
        &gt;&gt;&gt; diag.plot_gnomonic(display=False)
        &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan gnomonic&#39;}, xlabel=&#39;x.Gi (mm)&#39;, ylabel=&#39;y.Gj (mm)&#39;&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; fig = plt.figure()
        &gt;&gt;&gt; axe = fig.add_subplot()
        &gt;&gt;&gt; diag.plot_gnomonic(axe, display=False)
        &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan gnomonic&#39;}, xlabel=&#39;x.Gi (mm)&#39;, ylabel=&#39;y.Gj (mm)&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if axe_pyplot is None:
            import matplotlib.pyplot as plt
            axe_pyplot = plt.figure().add_subplot()

        axe_pyplot.set_title(&#34;plan gnomonic&#34;)
        axe_pyplot.set_xlabel(&#34;x.Gi (mm)&#34;)
        axe_pyplot.set_ylabel(&#34;y.Gj (mm)&#34;)

        # Affichage image de fond.
        try:
            image = self.get_image_gnomonic()
        except (NameError, AttributeError):
            pass
        else:
            *_, limits = self.experiment._get_gnomonic_matrix()
            mean, std = image.mean(), image.std()
            x_coords, y_coords = self.get_gnomonic_positions()
            axe_pyplot.imshow(image,
                origin=&#39;lower&#39;,
                aspect=((self.experiment.get_images_shape()[1]*x_coords.ptp())
                      / (self.experiment.get_images_shape()[0]*y_coords.ptp())),
                extent=limits,
                vmin=mean-2*std, vmax=mean+4*std, cmap=&#34;gray&#34;)

        # Affichage des axes.
        try:
            for axis in self.find_zone_axes():
                axe_pyplot = axis.plot_gnomonic(axe_pyplot, display=False)
        except AttributeError:
            return axe_pyplot

        # Affichage de spots.
        for spot in self:
            axe_pyplot = spot.plot_gnomonic(axe_pyplot, display=False)

        if display:
            import matplotlib.pyplot as plt
            plt.show()

        return axe_pyplot

    def plot_xy(self, axe_pyplot=None, *, display=True):
        &#34;&#34;&#34;
        ** Prepare l&#39;affichage du diagramme dans le plan du capteur. **

        Parameters
        ----------
        axe_pyplot : Axe
            Axe matplotlib qui supporte les methodes ``.scatter`` et ``.imshow``.
        display : boolean
            Si True, affiche a l&#39;ecran en faisant appel a ``plt.show()``.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt;
        &gt;&gt;&gt; diag.plot_xy(display=False)
        &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan camera&#39;}, xlabel=&#39;x.Ci (pxl)&#39;, ylabel=&#39;y.Cj (pxl)&#39;&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; import matplotlib.pyplot as plt
        &gt;&gt;&gt; fig = plt.figure()
        &gt;&gt;&gt; axe = fig.add_subplot()
        &gt;&gt;&gt; diag.plot_xy(axe, display=False)
        &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan camera&#39;}, xlabel=&#39;x.Ci (pxl)&#39;, ylabel=&#39;y.Cj (pxl)&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if axe_pyplot is None:
            import matplotlib.pyplot as plt
            axe_pyplot = plt.figure().add_subplot()

        axe_pyplot.set_title(&#34;plan camera&#34;)
        axe_pyplot.set_xlabel(&#34;x.Ci (pxl)&#34;)
        axe_pyplot.set_ylabel(&#34;y.Cj (pxl)&#34;)

        # Affichage image de fond.
        try:
            image = self.get_image_xy()
        except NameError:
            pass
        else:
            mean, std = image.mean(), image.std()
            axe_pyplot.imshow(image, vmin=mean-2*std, vmax=mean+4*std, cmap=&#34;gray&#34;)

        # Affichage des spots.
        for spot in self:
            axe_pyplot = spot.plot_xy(axe_pyplot, display=False)

        if display:
            import matplotlib.pyplot as plt
            plt.show()

        return axe_pyplot

    def save_file(self, filename):
        &#34;&#34;&#34;
        ** Enregistre un fichier contenant des informations. **

        Notes
        -----
        Les extensions prises en charge sont
        ``.dat``, ``.jpg``, ``.svg``, ``.png``

        Parameters
        ----------
        filename : str
            Nom ou chemin du fichier de destination.
            L&#39;extension doit etre comprise dans le nom du fichier.
            Si un fichier du meme nom existe deja, il est ecrase.

        Examples
        --------
        &gt;&gt;&gt; import os, tempfile
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt;
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; rep = tempfile.mkdtemp()
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; diag.save_file(os.path.join(rep, &#34;ge_blanc.dat&#34;))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        EXT_OK = {&#34;dat&#34;, &#34;jpg&#34;, &#34;jpeg&#34;, &#34;svg&#34;, &#34;png&#34;}

        assert isinstance(filename, str), \
            f&#34;&#39;filename&#39; has to be a string, not a {type(filename).__name__}.&#34;
        assert &#34;.&#34; in filename, &#34;Le fichier doit posseder une extension.&#34;
        assert filename.split(&#34;.&#34;)[-1].lower() in EXT_OK, (&#34;Seul les extensions &#34;
            f&#34;&#39;{&#39;, &#39;.join(EXT_OK)}&#39; sont supportees. Pas &#39;.{filename.split(&#39;.&#39;)[-1]}&#39;.&#34;)

        ext = filename.split(&#34;.&#34;)[-1].lower()
        if ext == &#34;dat&#34;:
            with open(filename, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
                file.write(&#34;{:&lt;20} {:&lt;20} {:&lt;20}\n&#34;.format(&#34;spot_X&#34;, &#34;spot_Y&#34;, &#34;spot_I&#34;))
                for spot in self:
                    file.write(&#34;{x:&lt;20} {y:&lt;20} {i:&lt;20}\n&#34;.format(
                        x=spot.get_position()[0],
                        y=spot.get_position()[1],
                        i=spot.get_intensity()))
        elif ext in {&#34;jpg&#34;, &#34;jpeg&#34;, &#34;svg&#34;, &#34;png&#34;}:
            plt = self.show(_return=True)
            plt.savefig(filename)

    def _clean(self):
        &#34;&#34;&#34;
        ** Supprime les attributs superfux. **

        Si les spots sont modifies, cela permet de vider la memoire
        des informations desormais fausses. Si beaucoup d&#39;images
        sont enregistrees dans la RAM, cela permet de faire de la
        place en memoire.
        &#34;&#34;&#34;
        if os.path.exists(self.get_id()): # Il ne faut pas supprimer
            self.image_xy = None # une image que l&#39;on ne peut pas retrouver!
        self.quality = None
        self.image_gnom = None
        self.sorted_spots = {} # Si jamais la set_calibration ou un spot change.
        self.axis = {} # Les axis de zone depandent de beaucoup de choses, on reste donc prudent.
        self.spots_set = None # On libere de la memoire en faisant ca.
        for spot in self:
            spot._clean()

    def __contains__(self, spot):
        &#34;&#34;&#34;
        ** Verifie qu&#39;un spot fait bien parti de ce diagramme. **

        Parameters
        ----------
        spot : laue.spot.Spot, int
            L&#39;instance de spot dont on cherche a savoir
            si il est present ou pas. Ou bien l&#39;index de ce spot.

        Returns
        -------
        boolean
            True si le spot est present dans ce diagramme, False sinon.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt;
        &gt;&gt;&gt; len(diag)
        78
        &gt;&gt;&gt; 77 in diag
        True
        &gt;&gt;&gt; 78 in diag
        False
        &gt;&gt;&gt;
        &gt;&gt;&gt; spot = diag[0]
        &gt;&gt;&gt; spot
        Spot(bbox=(1368, 1873, 6, 5), distortion=1.1804)
        &gt;&gt;&gt; spot in diag
        True
        &gt;&gt;&gt; 
        &#34;&#34;&#34;
        assert isinstance(spot, (Spot, int)), (&#34;&#39;spot&#39; has to be an &#34;
            f&#34;instance of Spot or int, not {type(spot).__name__}.&#34;)

        if isinstance(spot, int):
            if spot &lt; 0 or spot &gt;= len(self):
                return False
            spot = self[spot]

        if self.spots_set is None:
            self.spots_set = set(self)
        return spot in self.spots_set

    def __getitem__(self, items):
        &#34;&#34;&#34;
        ** Permet de recuperer des elements. **

        Parameters
        ----------
        items : int, slice, tuple, laue.spot.Spot
            C&#39;est un element qui permet de choisir un ou plusieurs
            spot dans ce diagram de laue.

        Returns
        -------
        spots : list, laue.spot.Spot
            - L&#39;element renvoye depend du parametre d&#39;entree ``items``:
                - int =&gt; Renvoi le item(ieme) spot. Comme si un
                ``LaueDiagram`` etait une liste de ``laue.spot.Spot``.
                    - Type renvoye: ``laue.spot.Spot``.
                - slice =&gt; Renvoi la liste des spots compris dans
                l&#39;intervalle fournit. Comme si ``LaueDiagram`` est aussi une liste.
                    - Type renvoye: ``list``.
                - tuple =&gt; Cherche un spot ou plusieur selon une notion de distance.
                    - Le premier et/ou deuxieme argument peut etre un spot ou bien 2 nombres x et y.
                    - Le troisieme argument (factultatif) permet de preciser l&#39;espace
                    et la metrique a utiliser pour comparer les spots a la reference.
                    C&#39;est une chaine de caracetere expicite:
                        - &#34;camera&#34; (valeur par defaut si x et y de type ``int``
                        ou que le premier argument est un spot) =&gt;
                        Distance euclidiene dans le plan de la camera (pxl).
                        - &#34;gnomonic&#34; (valeur par defaut si x et y de type ``float``) =&gt;
                        Distance euclidiene dans le plan gnomonique (mm).
                        - &#34;angle&#34; =&gt; Cosine distance entre les vecteurs ``uq`` (axe de reflexion)
                        de chaquns des points (en degre).
                        Le premier argument est interprete comme ``2*theta`` et le second comme ``chi``.
                    - Le quatrieme argument correspond au nombre de voisins a prendre.
                    La valeur par defaut est 1. Cet argument doit etre un entier positif.
                    - Type renvoye: ``list``.
                - spot =&gt; equivalent a ``self[spot, &#34;camera&#34;]``.

        Raises
        ------
        IndexError
            Si aucun spot n&#39;est quandidat ou qu&#39;on shouaite acceder a un spot qui n&#39;existe pas.
        ValueError
            Si les arguments fournis ne sont pas conformes.

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(diag[0])
        &lt;class &#39;laue.spot.Spot&#39;&gt;
        &gt;&gt;&gt; type(diag[3:22]), len(diag[3:22])
        (&lt;class &#39;list&#39;&gt;, 19)
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(diag[500, 700]), len(diag[500, 700])
        (&lt;class &#39;list&#39;&gt;, 1)
        &gt;&gt;&gt; np.round(diag[500, 700].pop().get_position(), 3)
        array([521.018, 724.495])
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(diag[.2, -.3]), len(diag[.2, -.3])
        (&lt;class &#39;list&#39;&gt;, 1)
        &gt;&gt;&gt; np.round(diag[.2, -.3].pop().get_gnomonic(), 3)
        array([ 0.266, -0.299])
        &gt;&gt;&gt;
        &gt;&gt;&gt; len(diag[0.2, .5, &#34;gnomonic&#34;, 6])
        6
        &gt;&gt;&gt; np.array([d.get_gnomonic() for d in diag[0.2, .5, &#34;gnomonic&#34;, 3]])
        array([[0.29464949, 0.39670733],
               [0.06846284, 0.55485944],
               [0.07130572, 0.41748433]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if isinstance(items, (int, np.integer)):
            return self.spots[items]

        if isinstance(items, slice):
            return self.spots[items]

        if isinstance(items, tuple):
            if not items:
                raise ValueError(&#34;Vous ne pouvez pas fournir un tuple vide.&#34;)

            # Recuperation des informations.
            if isinstance(items[0], Spot):
                spot, *infos = items

                # Recherche de la metrique
                if not infos or infos[0] is None:
                    if infos:
                        _, *infos = infos
                    space = &#34;camera&#34;
                else:
                    space, *infos = infos

                x, y = {&#34;camera&#34;: lambda spot: spot.get_position(),
                        &#34;gnomonic&#34;: lambda spot: spot.get_gnomonic(),
                        &#34;angle&#34;: lambda spot: spot.get_twicetheta_chi()
                        }.get(space, lambda spot: (None, None))[spot]
            else:
                if len(items) &lt; 2:
                    raise ValueError(&#34;Si vous chercher a recuperer les spots&#34;
                        &#34;d&#39;un voisinage, vous devez fournir au moins 2 arguments\n.&#34;
                        f&#34;Or il y en a {len(items)}.&#34;)
                x, y, *infos = items

                # Recherche de la metrique
                if type(x) != type(y):
                    raise ValueError(&#34;Les 2 premieres coordonnees doivent etre homogenes&#34;)
                if not isinstance(x, (int, float)):
                    raise ValueError(&#34;Les 2 premiers elements doivent etre de type int ou float, &#34;
                        f&#34;pas de type {type(x).__name__}.&#34;)
                if not infos or infos[0] is None:
                    if infos:
                        _, *infos = infos
                    space = &#34;camera&#34; if isinstance(x, int) else &#34;gnomonic&#34;
                else:
                    space, *infos = infos

            # Recherche du nombre de voisins.
            if not infos or infos[0] is None:
                if infos:
                    _, *infos = infos
                nbr_voisins = 1
            else:
                nbr_voisins, *infos = infos

            # Verifications
            if not isinstance(nbr_voisins, int):
                raise ValueError(&#34;Le nombre de voisin doit etre un entier, &#34;
                    f&#34;pas {type(nbr_voisins).__name__}&#34;)
            if nbr_voisins &lt; 1:
                raise ValueError(&#34;Le nombre de voisin doit etre strictement positif.&#34;)
            if space not in {&#34;camera&#34;, &#34;gnomonic&#34;, &#34;angle&#34;}:
                raise ValueError(&#34;Le dernier argument ne peut etre que &#34;
                    f&#34;&#39;camera&#39;, &#39;gnomonic&#39; ou &#39;angle&#39;. Pas {repr(space)}&#34;)
            if infos:
                raise ValueError(&#34;Il y a trop de parametres.&#34;)

            # Recherche des voisins
            from laue.spot import distance

            d_list = distance((x, y), self.select_spots(), space=space)
            if nbr_voisins == 1:
                return [self.spots[np.argmin(d_list)]]
            return [self.spots[spot_ind] for spot_ind in np.argsort(d_list)[:nbr_voisins]]

        if isinstance(items, Spot):
            return self[items, None, None]

        raise ValueError(&#34;Seul les types &#39;int&#39;, &#39;slice&#39;, &#39;tuple&#39; et &#39;Spot&#39; sont supportees. &#34;
            f&#34;Or le type fourni est {type(items).__name__}.&#34;)

    def __hash__(self):
        &#34;&#34;&#34;
        ** Fonction de hachage. **

        Permet de faire un ``dict`` ou un ``set`` avec
        des instances de ``LaueDiagram``.
        &#34;&#34;&#34;
        return hash(self.get_id())

    def __iter__(self):
        &#34;&#34;&#34;
        ** Permet d&#39;iterer sur les spots. **

        Yields
        ------
        Spot
            Cede les instances des spots qui constituent
            ce diagramme dans un ordre indetermine mais invariant.
            Ces instances heritent de la classe ``laue.spot.Spot``.
            Seul les pointeurs sont cedes, ce qui implique que toute
            modification d&#39;un spot sera globale.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; for spot in diag:
        ...     pass
        ...
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        yield from self.spots

    def __len__(self):
        &#34;&#34;&#34;
        ** Renvoi le nombre de spots. **

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = laue.Experiment(image)[0]
        &gt;&gt;&gt; len(diag)
        78
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return len(self.spots)

    def __str__(self):
        &#34;&#34;&#34;
        ** Renvoi une jolie representation du diagramme de Laue. **
        &#34;&#34;&#34;
        return (&#34;LaueDiagram:\n&#34;
                f&#34;\tname: {self.get_id()}\n&#34;
                f&#34;\tnbr spots: {len(self.select_spots())}\n&#34;
                f&#34;\tquality: {self.get_quality()}&#34;)

    def __repr__(self):
        &#34;&#34;&#34;
        ** Renvoi une chaine evaluable de self. **
        &#34;&#34;&#34;
        return (&#34;LaueDiagram(&#34;
                f&#34;name={repr(self.get_id())}, &#34;
                f&#34;experiment={repr(self.experiment)})&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="laue.tools.splitable.Splitable" href="tools/splitable.html#laue.tools.splitable.Splitable">Splitable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laue.diagram.LaueDiagram.__contains__"><code class="name flex">
<span>def <span class="ident">__contains__</span></span>(<span>self, spot)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Verifie qu'un spot fait bien parti de ce diagramme. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spot</code></strong> :&ensp;<code><a title="laue.spot.Spot" href="spot.html#laue.spot.Spot">Spot</a>, int</code></dt>
<dd>L'instance de spot dont on cherche a savoir
si il est present ou pas. Ou bien l'index de ce spot.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>True si le spot est present dans ce diagramme, False sinon.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt;
&gt;&gt;&gt; len(diag)
78
&gt;&gt;&gt; 77 in diag
True
&gt;&gt;&gt; 78 in diag
False
&gt;&gt;&gt;
&gt;&gt;&gt; spot = diag[0]
&gt;&gt;&gt; spot
Spot(bbox=(1368, 1873, 6, 5), distortion=1.1804)
&gt;&gt;&gt; spot in diag
True
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __contains__(self, spot):
    &#34;&#34;&#34;
    ** Verifie qu&#39;un spot fait bien parti de ce diagramme. **

    Parameters
    ----------
    spot : laue.spot.Spot, int
        L&#39;instance de spot dont on cherche a savoir
        si il est present ou pas. Ou bien l&#39;index de ce spot.

    Returns
    -------
    boolean
        True si le spot est present dans ce diagramme, False sinon.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt;
    &gt;&gt;&gt; len(diag)
    78
    &gt;&gt;&gt; 77 in diag
    True
    &gt;&gt;&gt; 78 in diag
    False
    &gt;&gt;&gt;
    &gt;&gt;&gt; spot = diag[0]
    &gt;&gt;&gt; spot
    Spot(bbox=(1368, 1873, 6, 5), distortion=1.1804)
    &gt;&gt;&gt; spot in diag
    True
    &gt;&gt;&gt; 
    &#34;&#34;&#34;
    assert isinstance(spot, (Spot, int)), (&#34;&#39;spot&#39; has to be an &#34;
        f&#34;instance of Spot or int, not {type(spot).__name__}.&#34;)

    if isinstance(spot, int):
        if spot &lt; 0 or spot &gt;= len(self):
            return False
        spot = self[spot]

    if self.spots_set is None:
        self.spots_set = set(self)
    return spot in self.spots_set</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.__getitem__"><code class="name flex">
<span>def <span class="ident">__getitem__</span></span>(<span>self, items)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Permet de recuperer des elements. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>items</code></strong> :&ensp;<code>int, slice, tuple, <a title="laue.spot.Spot" href="spot.html#laue.spot.Spot">Spot</a></code></dt>
<dd>C'est un element qui permet de choisir un ou plusieurs
spot dans ce diagram de laue.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>spots</code></strong> :&ensp;<code>list, <a title="laue.spot.Spot" href="spot.html#laue.spot.Spot">Spot</a></code></dt>
<dd>
<ul>
<li>L'element renvoye depend du parametre d'entree <code>items</code>:<ul>
<li>int =&gt; Renvoi le item(ieme) spot. Comme si un
<code><a title="laue.diagram.LaueDiagram" href="#laue.diagram.LaueDiagram">LaueDiagram</a></code> etait une liste de <code><a title="laue.spot.Spot" href="spot.html#laue.spot.Spot">Spot</a></code>.<ul>
<li>Type renvoye: <code><a title="laue.spot.Spot" href="spot.html#laue.spot.Spot">Spot</a></code>.</li>
</ul>
</li>
<li>slice =&gt; Renvoi la liste des spots compris dans
l'intervalle fournit. Comme si <code><a title="laue.diagram.LaueDiagram" href="#laue.diagram.LaueDiagram">LaueDiagram</a></code> est aussi une liste.<ul>
<li>Type renvoye: <code>list</code>.</li>
</ul>
</li>
<li>tuple =&gt; Cherche un spot ou plusieur selon une notion de distance.<ul>
<li>Le premier et/ou deuxieme argument peut etre un spot ou bien 2 nombres x et y.</li>
<li>Le troisieme argument (factultatif) permet de preciser l'espace
et la metrique a utiliser pour comparer les spots a la reference.
C'est une chaine de caracetere expicite:<ul>
<li>"camera" (valeur par defaut si x et y de type <code>int</code>
ou que le premier argument est un spot) =&gt;
Distance euclidiene dans le plan de la camera (pxl).</li>
<li>"gnomonic" (valeur par defaut si x et y de type <code>float</code>) =&gt;
Distance euclidiene dans le plan gnomonique (mm).</li>
<li>"angle" =&gt; Cosine distance entre les vecteurs <code>uq</code> (axe de reflexion)
de chaquns des points (en degre).
Le premier argument est interprete comme <code>2*theta</code> et le second comme <code>chi</code>.</li>
</ul>
</li>
<li>Le quatrieme argument correspond au nombre de voisins a prendre.
La valeur par defaut est 1. Cet argument doit etre un entier positif.</li>
<li>Type renvoye: <code>list</code>.</li>
</ul>
</li>
<li>spot =&gt; equivalent a <code>self[spot, "camera"]</code>.</li>
</ul>
</li>
</ul>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>IndexError</code></dt>
<dd>Si aucun spot n'est quandidat ou qu'on shouaite acceder a un spot qui n'existe pas.</dd>
<dt><code>ValueError</code></dt>
<dd>Si les arguments fournis ne sont pas conformes.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image, config_file=&quot;laue/examples/ge_blanc.det&quot;)[0]
&gt;&gt;&gt;
&gt;&gt;&gt; type(diag[0])
&lt;class 'laue.spot.Spot'&gt;
&gt;&gt;&gt; type(diag[3:22]), len(diag[3:22])
(&lt;class 'list'&gt;, 19)
&gt;&gt;&gt;
&gt;&gt;&gt; type(diag[500, 700]), len(diag[500, 700])
(&lt;class 'list'&gt;, 1)
&gt;&gt;&gt; np.round(diag[500, 700].pop().get_position(), 3)
array([521.018, 724.495])
&gt;&gt;&gt;
&gt;&gt;&gt; type(diag[.2, -.3]), len(diag[.2, -.3])
(&lt;class 'list'&gt;, 1)
&gt;&gt;&gt; np.round(diag[.2, -.3].pop().get_gnomonic(), 3)
array([ 0.266, -0.299])
&gt;&gt;&gt;
&gt;&gt;&gt; len(diag[0.2, .5, &quot;gnomonic&quot;, 6])
6
&gt;&gt;&gt; np.array([d.get_gnomonic() for d in diag[0.2, .5, &quot;gnomonic&quot;, 3]])
array([[0.29464949, 0.39670733],
       [0.06846284, 0.55485944],
       [0.07130572, 0.41748433]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __getitem__(self, items):
    &#34;&#34;&#34;
    ** Permet de recuperer des elements. **

    Parameters
    ----------
    items : int, slice, tuple, laue.spot.Spot
        C&#39;est un element qui permet de choisir un ou plusieurs
        spot dans ce diagram de laue.

    Returns
    -------
    spots : list, laue.spot.Spot
        - L&#39;element renvoye depend du parametre d&#39;entree ``items``:
            - int =&gt; Renvoi le item(ieme) spot. Comme si un
            ``LaueDiagram`` etait une liste de ``laue.spot.Spot``.
                - Type renvoye: ``laue.spot.Spot``.
            - slice =&gt; Renvoi la liste des spots compris dans
            l&#39;intervalle fournit. Comme si ``LaueDiagram`` est aussi une liste.
                - Type renvoye: ``list``.
            - tuple =&gt; Cherche un spot ou plusieur selon une notion de distance.
                - Le premier et/ou deuxieme argument peut etre un spot ou bien 2 nombres x et y.
                - Le troisieme argument (factultatif) permet de preciser l&#39;espace
                et la metrique a utiliser pour comparer les spots a la reference.
                C&#39;est une chaine de caracetere expicite:
                    - &#34;camera&#34; (valeur par defaut si x et y de type ``int``
                    ou que le premier argument est un spot) =&gt;
                    Distance euclidiene dans le plan de la camera (pxl).
                    - &#34;gnomonic&#34; (valeur par defaut si x et y de type ``float``) =&gt;
                    Distance euclidiene dans le plan gnomonique (mm).
                    - &#34;angle&#34; =&gt; Cosine distance entre les vecteurs ``uq`` (axe de reflexion)
                    de chaquns des points (en degre).
                    Le premier argument est interprete comme ``2*theta`` et le second comme ``chi``.
                - Le quatrieme argument correspond au nombre de voisins a prendre.
                La valeur par defaut est 1. Cet argument doit etre un entier positif.
                - Type renvoye: ``list``.
            - spot =&gt; equivalent a ``self[spot, &#34;camera&#34;]``.

    Raises
    ------
    IndexError
        Si aucun spot n&#39;est quandidat ou qu&#39;on shouaite acceder a un spot qui n&#39;existe pas.
    ValueError
        Si les arguments fournis ne sont pas conformes.

    Examples
    -------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(diag[0])
    &lt;class &#39;laue.spot.Spot&#39;&gt;
    &gt;&gt;&gt; type(diag[3:22]), len(diag[3:22])
    (&lt;class &#39;list&#39;&gt;, 19)
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(diag[500, 700]), len(diag[500, 700])
    (&lt;class &#39;list&#39;&gt;, 1)
    &gt;&gt;&gt; np.round(diag[500, 700].pop().get_position(), 3)
    array([521.018, 724.495])
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(diag[.2, -.3]), len(diag[.2, -.3])
    (&lt;class &#39;list&#39;&gt;, 1)
    &gt;&gt;&gt; np.round(diag[.2, -.3].pop().get_gnomonic(), 3)
    array([ 0.266, -0.299])
    &gt;&gt;&gt;
    &gt;&gt;&gt; len(diag[0.2, .5, &#34;gnomonic&#34;, 6])
    6
    &gt;&gt;&gt; np.array([d.get_gnomonic() for d in diag[0.2, .5, &#34;gnomonic&#34;, 3]])
    array([[0.29464949, 0.39670733],
           [0.06846284, 0.55485944],
           [0.07130572, 0.41748433]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if isinstance(items, (int, np.integer)):
        return self.spots[items]

    if isinstance(items, slice):
        return self.spots[items]

    if isinstance(items, tuple):
        if not items:
            raise ValueError(&#34;Vous ne pouvez pas fournir un tuple vide.&#34;)

        # Recuperation des informations.
        if isinstance(items[0], Spot):
            spot, *infos = items

            # Recherche de la metrique
            if not infos or infos[0] is None:
                if infos:
                    _, *infos = infos
                space = &#34;camera&#34;
            else:
                space, *infos = infos

            x, y = {&#34;camera&#34;: lambda spot: spot.get_position(),
                    &#34;gnomonic&#34;: lambda spot: spot.get_gnomonic(),
                    &#34;angle&#34;: lambda spot: spot.get_twicetheta_chi()
                    }.get(space, lambda spot: (None, None))[spot]
        else:
            if len(items) &lt; 2:
                raise ValueError(&#34;Si vous chercher a recuperer les spots&#34;
                    &#34;d&#39;un voisinage, vous devez fournir au moins 2 arguments\n.&#34;
                    f&#34;Or il y en a {len(items)}.&#34;)
            x, y, *infos = items

            # Recherche de la metrique
            if type(x) != type(y):
                raise ValueError(&#34;Les 2 premieres coordonnees doivent etre homogenes&#34;)
            if not isinstance(x, (int, float)):
                raise ValueError(&#34;Les 2 premiers elements doivent etre de type int ou float, &#34;
                    f&#34;pas de type {type(x).__name__}.&#34;)
            if not infos or infos[0] is None:
                if infos:
                    _, *infos = infos
                space = &#34;camera&#34; if isinstance(x, int) else &#34;gnomonic&#34;
            else:
                space, *infos = infos

        # Recherche du nombre de voisins.
        if not infos or infos[0] is None:
            if infos:
                _, *infos = infos
            nbr_voisins = 1
        else:
            nbr_voisins, *infos = infos

        # Verifications
        if not isinstance(nbr_voisins, int):
            raise ValueError(&#34;Le nombre de voisin doit etre un entier, &#34;
                f&#34;pas {type(nbr_voisins).__name__}&#34;)
        if nbr_voisins &lt; 1:
            raise ValueError(&#34;Le nombre de voisin doit etre strictement positif.&#34;)
        if space not in {&#34;camera&#34;, &#34;gnomonic&#34;, &#34;angle&#34;}:
            raise ValueError(&#34;Le dernier argument ne peut etre que &#34;
                f&#34;&#39;camera&#39;, &#39;gnomonic&#39; ou &#39;angle&#39;. Pas {repr(space)}&#34;)
        if infos:
            raise ValueError(&#34;Il y a trop de parametres.&#34;)

        # Recherche des voisins
        from laue.spot import distance

        d_list = distance((x, y), self.select_spots(), space=space)
        if nbr_voisins == 1:
            return [self.spots[np.argmin(d_list)]]
        return [self.spots[spot_ind] for spot_ind in np.argsort(d_list)[:nbr_voisins]]

    if isinstance(items, Spot):
        return self[items, None, None]

    raise ValueError(&#34;Seul les types &#39;int&#39;, &#39;slice&#39;, &#39;tuple&#39; et &#39;Spot&#39; sont supportees. &#34;
        f&#34;Or le type fourni est {type(items).__name__}.&#34;)</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.__hash__"><code class="name flex">
<span>def <span class="ident">__hash__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Fonction de hachage. </strong></p>
<p>Permet de faire un <code>dict</code> ou un <code>set</code> avec
des instances de <code><a title="laue.diagram.LaueDiagram" href="#laue.diagram.LaueDiagram">LaueDiagram</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __hash__(self):
    &#34;&#34;&#34;
    ** Fonction de hachage. **

    Permet de faire un ``dict`` ou un ``set`` avec
    des instances de ``LaueDiagram``.
    &#34;&#34;&#34;
    return hash(self.get_id())</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.__iter__"><code class="name flex">
<span>def <span class="ident">__iter__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Permet d'iterer sur les spots. </strong></p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Spot</code></dt>
<dd>Cede les instances des spots qui constituent
ce diagramme dans un ordre indetermine mais invariant.
Ces instances heritent de la classe <code><a title="laue.spot.Spot" href="spot.html#laue.spot.Spot">Spot</a></code>.
Seul les pointeurs sont cedes, ce qui implique que toute
modification d'un spot sera globale.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt; for spot in diag:
...     pass
...
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __iter__(self):
    &#34;&#34;&#34;
    ** Permet d&#39;iterer sur les spots. **

    Yields
    ------
    Spot
        Cede les instances des spots qui constituent
        ce diagramme dans un ordre indetermine mais invariant.
        Ces instances heritent de la classe ``laue.spot.Spot``.
        Seul les pointeurs sont cedes, ce qui implique que toute
        modification d&#39;un spot sera globale.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt; for spot in diag:
    ...     pass
    ...
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    yield from self.spots</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.__len__"><code class="name flex">
<span>def <span class="ident">__len__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Renvoi le nombre de spots. </strong></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt; len(diag)
78
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __len__(self):
    &#34;&#34;&#34;
    ** Renvoi le nombre de spots. **

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt; len(diag)
    78
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return len(self.spots)</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.find_subsets"><code class="name flex">
<span>def <span class="ident">find_subsets</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Alias to <code><a title="laue.tools.splitable.Splitable.find_subsets" href="tools/splitable.html#laue.tools.splitable.Splitable.find_subsets">Splitable.find_subsets()</a></code>. </strong></p>
<p>C'est une methode abstraite definie dans la classe mere.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_subsets(self, *args, **kwargs):
    &#34;&#34;&#34;
    ** Alias to ``laue.tools.splitable.Splitable.find_subsets``. **

    C&#39;est une methode abstraite definie dans la classe mere.
    &#34;&#34;&#34;
    return super().find_subsets(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.find_zone_axes"><code class="name flex">
<span>def <span class="ident">find_zone_axes</span></span>(<span>self, *, dmax=None, nbr=7, tol=None)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Cherche les axes de zone </strong></p>
<h2 id="notes">Notes</h2>
<p>Si le but est d'extraire les axes de zonnes de plusieurs diagrammes
il vaut mieux appeler <code><a title="laue.experiment.base_experiment.Experiment.find_zone_axes" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.find_zone_axes">Experiment.find_zone_axes()</a></code> car
les calculs sont parallelises, contrairement a cette methode.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dmax</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>La distance maximale admissible entre un spot et un axe de zone
pour pouvoir considerer que le spot appartient a l'axe de zone.
Par defaut cette valeur evolue lineairement entre 5 pxl pour
les diagrammes contenants beaucoup de spots a 20 pxl pour les petits.
avec <code>n</code> le nombre de spots dans le diagramme.</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Alignement des points. Voir <code><a title="laue.geometry.Transformer.hough_reduce" href="geometry.html#laue.geometry.Transformer.hough_reduce">Transformer.hough_reduce()</a></code>
pour avoir les informations precises sur 'tol'. Par defaut
cette valeur evolue exponentiellement entre 0.018 pour les diagrammes
de 50 spots et 0.005 pour ceux de 600 spots.</dd>
<dt><strong><code>nbr</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Nombre minimum de points par axe de zone.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>list</code></dt>
<dd>La liste des axes de zone de type <code><a title="laue.zone_axis.ZoneAxis" href="zone_axis.html#laue.zone_axis.ZoneAxis">ZoneAxis</a></code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image, config_file=&quot;laue/examples/ge_blanc.det&quot;)[0]
&gt;&gt;&gt; type(diag.find_zone_axes())
&lt;class 'list'&gt;
&gt;&gt;&gt; type(diag.find_zone_axes().pop())
&lt;class 'laue.zone_axis.ZoneAxis'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_zone_axes(self, *, dmax=None, nbr=7, tol=None,
    _axes_args=None, _get_args=False):
    &#34;&#34;&#34;
    ** Cherche les axes de zone **

    Notes
    -----
    Si le but est d&#39;extraire les axes de zonnes de plusieurs diagrammes
    il vaut mieux appeler ``laue.experiment.base_experiment.Experiment.find_zone_axes`` car
    les calculs sont parallelises, contrairement a cette methode.

    Parameters
    ----------
    dmax : float, optional
        La distance maximale admissible entre un spot et un axe de zone
        pour pouvoir considerer que le spot appartient a l&#39;axe de zone.
        Par defaut cette valeur evolue lineairement entre 5 pxl pour
        les diagrammes contenants beaucoup de spots a 20 pxl pour les petits.
        avec ``n`` le nombre de spots dans le diagramme.
    tol : float, optional
        Alignement des points. Voir ``laue.geometry.Transformer.hough_reduce``
        pour avoir les informations precises sur &#39;tol&#39;. Par defaut
        cette valeur evolue exponentiellement entre 0.018 pour les diagrammes
        de 50 spots et 0.005 pour ceux de 600 spots.
    nbr : int, optional
        Nombre minimum de points par axe de zone.

    Returns
    -------
    axis : list
        La liste des axes de zone de type ``laue.zone_axis.ZoneAxis``.

    Examples
    -------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
    &gt;&gt;&gt; type(diag.find_zone_axes())
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; type(diag.find_zone_axes().pop())
    &lt;class &#39;laue.zone_axis.ZoneAxis&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if dmax is None:
        pxl_max, pxl_min = 20, 5
        d_max, d_min = 1.2*pxl_max/2048, 1.2*pxl_min/2048
        dmax = max(.005, d_max - (d_max-d_min)/800 * len(self))
    if tol is None:
        a = 2.2865e-8
        b = -3.9201e-5
        c = .0205058
        tol = a*len(self)**2 + b*len(self) + c

    assert isinstance(dmax, float), \
        f&#34;&#39;dmax&#39; doit etre un flottant, pas un {type(dmax).__name__}.&#34;
    assert dmax &gt; 0, f&#34;La distance doit etre strictement positive elle vaut {dmax}.&#34;

    if _get_args: # Si il faut seulement preparer le travail.
        gnomonics = self.get_gnomonic_positions()
        return gnomonics, dmax, nbr, tol

    if (dmax, nbr, tol) in self.axis: # Si on a deja la solution.
        return self.axis[(dmax, nbr, tol)]

    if _axes_args is None: # Si le travail n&#39;est pas premache.
        from laue.zone_axis import _get_zone_axes_pickle
        angles, dists, axis_spots_ind, spots_axes_ind = _get_zone_axes_pickle(
            (self.experiment.transformer,
            self.get_gnomonic_positions(),
            dmax, nbr, tol))
    else:
        angles, dists, axis_spots_ind, spots_axes_ind = _axes_args

    # Creation des objets &#39;ZoneAxis&#39;.
    from laue.zone_axis import ZoneAxis
    self.axis[(dmax, nbr, tol)] = [
            ZoneAxis(diagram=self,
                 spots_ind=spots_ind,
                 identifier=i,
                 angle=angle,
                 dist=dist)
            for i, (angle, dist, spots_ind) in enumerate(zip(angles, dists, axis_spots_ind))]

    # Attribution des axes aux spots.
    for spot, axes_ind in zip(self, spots_axes_ind):
        spot.axes = {self.axis[(dmax, nbr, tol)][axis_ind] for axis_ind in axes_ind}
    return self.axis[(dmax, nbr, tol)]</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.get_gnomonic_positions"><code class="name flex">
<span>def <span class="ident">get_gnomonic_positions</span></span>(<span>self, *, n=None, sort=None)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere la position des spots dans le plan gnomonic. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Same as <code><a title="laue.diagram.LaueDiagram.select_spots" href="#laue.diagram.LaueDiagram.select_spots">LaueDiagram.select_spots()</a></code>.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>str</code> or <code>callable</code>, optional</dt>
<dd>Same as <code><a title="laue.diagram.LaueDiagram.select_spots" href="#laue.diagram.LaueDiagram.select_spots">LaueDiagram.select_spots()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>coordonees</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>
<ul>
<li>Le vecteur des coordonnees x puis le vecteur y. (en mm)</li>
<li>La shape de retour est (2, nbr_spots)</li>
</ul>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributError</code></dt>
<dd>Si il manque des infos pour satisfaire cette demande.
En general l'un des parametres de set_calibration.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image, config_file=&quot;laue/examples/ge_blanc.det&quot;)[0]
&gt;&gt;&gt; diag.get_gnomonic_positions().shape
(2, 78)
&gt;&gt;&gt; diag.get_gnomonic_positions(n=4, sort=lambda spot: spot.get_position()[0])
array([[-0.0978478 , -0.20958039, -0.04084784, -0.3524825 ],
       [ 0.5766271 ,  0.48377115,  0.56894475,  0.36476415]],
      dtype=float32)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gnomonic_positions(self, *, n=None, sort=None):
    &#34;&#34;&#34;
    ** Recupere la position des spots dans le plan gnomonic. **

    Parameters
    ----------
    n : int, optional
        Same as ``LaueDiagram.select_spots``.
    sort : str or callable, optional
        Same as ``LaueDiagram.select_spots``.

    Returns
    -------
    coordonees : np.ndarray
        * Le vecteur des coordonnees x puis le vecteur y. (en mm)
        * La shape de retour est (2, nbr_spots)

    Raises
    ------
    AttributError
        Si il manque des infos pour satisfaire cette demande.
        En general l&#39;un des parametres de set_calibration.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
    &gt;&gt;&gt; diag.get_gnomonic_positions().shape
    (2, 78)
    &gt;&gt;&gt; diag.get_gnomonic_positions(n=4, sort=lambda spot: spot.get_position()[0])
    array([[-0.0978478 , -0.20958039, -0.04084784, -0.3524825 ],
           [ 0.5766271 ,  0.48377115,  0.56894475,  0.36476415]],
          dtype=float32)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    # On calcul les projections pour tous les points a la fois.
    if self.spots[0].gnomonic is None:
        coord_gnomonic = self.experiment.transformer.cam_to_gnomonic(
            *self.get_positions(n=n, sort=sort),
            self.experiment.set_calibration())
        for spot, xg, yg in zip(self, *coord_gnomonic):
            spot.gnomonic = (xg, yg)
    # On extrait juste ce qu&#39;il nous interresse.
    else:
        coord_gnomonic = np.array(
            [spot.get_gnomonic() for spot in self.select_spots(n=n, sort=sort)],
            dtype=np.float32).transpose()

    return coord_gnomonic</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Retourne le nom du diagramme. </strong></p>
<ul>
<li>Dans la mesure du possible, le nom du diagramme est le chemin
d'acces au fichier image qui a permis de constituer le diagramme.</li>
<li>Si le chemin d'acces est inconnu, un nom par defaut unique est genere.</li>
</ul>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt; diag.get_id()
'laue/examples/ge_blanc.mccd'
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self):
    &#34;&#34;&#34;
    ** Retourne le nom du diagramme. **

    * Dans la mesure du possible, le nom du diagramme est le chemin
    d&#39;acces au fichier image qui a permis de constituer le diagramme.
    * Si le chemin d&#39;acces est inconnu, un nom par defaut unique est genere.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt; diag.get_id()
    &#39;laue/examples/ge_blanc.mccd&#39;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return self.name</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.get_image_gnomonic"><code class="name flex">
<span>def <span class="ident">get_image_gnomonic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere le contenu de l'image d'un diagramme projete dans le plan gnomonic. </strong></p>
<h2 id="notes">Notes</h2>
<p>Les parametres de set_calibration de la camera sont recuperes avec
un appel a la fonction <code><a title="laue.experiment.base_experiment.Experiment.set_calibration" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.set_calibration">Experiment.set_calibration()</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray(dtype=np.uint16)</code></dt>
<dd>L'image 2d en niveau de gris encodee en uint16.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NameError</code></dt>
<dd>Si l'image est introuvable.</dd>
<dt><code>AttributError</code></dt>
<dd>Si il manque des infos pour satisfaire cette demande.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image, config_file=&quot;laue/examples/ge_blanc.det&quot;)[0]
&gt;&gt;&gt; diag.get_image_gnomonic()
array([[0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       ...,
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image_gnomonic(self):
    &#34;&#34;&#34;
    ** Recupere le contenu de l&#39;image d&#39;un diagramme projete dans le plan gnomonic. **

    Notes
    -----
    Les parametres de set_calibration de la camera sont recuperes avec
    un appel a la fonction ``laue.experiment.base_experiment.Experiment.set_calibration()``.

    Returns
    -------
    image: np.ndarray(dtype=np.uint16)
        L&#39;image 2d en niveau de gris encodee en uint16.
    
    Raises
    ------
    NameError
        Si l&#39;image est introuvable.
    AttributError
        Si il manque des infos pour satisfaire cette demande.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
    &gt;&gt;&gt; diag.get_image_gnomonic()
    array([[0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           ...,
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if self.image_gnom is not None:
        return self.image_gnom

    # Interpolation inverse vers l&#39;image finale.
    map_x, map_y, _ = self.experiment._get_gnomonic_matrix()
    image_xy = self.get_image_xy()
    image_gnom = cv2.remap(image_xy,
        map_x, map_y, interpolation=cv2.INTER_LINEAR)

    if psutil is not None and psutil.virtual_memory().percent &lt; 75:
        self.image_gnom = image_gnom

    return image_gnom</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.get_image_xy"><code class="name flex">
<span>def <span class="ident">get_image_xy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere le contenu de l'image d'un diagramme. </strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray(dtype=np.uint16)</code></dt>
<dd>L'image 2d en niveau de gris encodee en uint16.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>NameError</code></dt>
<dd>Si l'image est introuvable.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt; diag.get_image_xy()
array([[0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       ...,
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0],
       [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
&gt;&gt;&gt; diag.get_image_xy().max()
28899
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image_xy(self):
    &#34;&#34;&#34;
    ** Recupere le contenu de l&#39;image d&#39;un diagramme. **

    Returns
    -------
    image : np.ndarray(dtype=np.uint16)
        L&#39;image 2d en niveau de gris encodee en uint16.
    
    Raises
    ------
    NameError
        Si l&#39;image est introuvable.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt; diag.get_image_xy()
    array([[0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           ...,
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
    &gt;&gt;&gt; diag.get_image_xy().max()
    28899
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if self.image_xy is not None:
        return self.image_xy

    if not os.path.exists(self.get_id()):
        raise NameError(f&#34;Impossible de trouver le fichier {repr(self.get_id())}.&#34;)

    from laue.tools.image import read_image
    image = read_image(self.get_id())

    if psutil is not None and psutil.virtual_memory().percent &lt; 75:
        self.image_xy = image

    return image</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.get_positions"><code class="name flex">
<span>def <span class="ident">get_positions</span></span>(<span>self, *, n=None, sort=None)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere la position des spots dans le plan de la camera. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Same as <code><a title="laue.diagram.LaueDiagram.select_spots" href="#laue.diagram.LaueDiagram.select_spots">LaueDiagram.select_spots()</a></code>.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>str</code> or <code>callable</code>, optional</dt>
<dd>Same as <code><a title="laue.diagram.LaueDiagram.select_spots" href="#laue.diagram.LaueDiagram.select_spots">LaueDiagram.select_spots()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>
<ul>
<li>Le vecteur des coordonnees x puis le vecteur des y. (en pxl)</li>
<li>La shape de retour est (2, nbr_spots).</li>
<li>Les spots ne sont pas tries, l'ordre est le meme que
<code><a title="laue.diagram.LaueDiagram.select_spots" href="#laue.diagram.LaueDiagram.select_spots">LaueDiagram.select_spots()</a></code> sans argument.</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt; diag.get_positions().shape
(2, 78)
&gt;&gt;&gt; diag.get_positions(n=4, sort=lambda spot: spot.get_position()[0])
array([[ 132.0286 ,  160.35379,  192.01744,  214.02731],
       [1204.656  ,  907.2095 , 1296.9255 ,  492.425  ]], dtype=float32)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_positions(self, *, n=None, sort=None):
    &#34;&#34;&#34;
    ** Recupere la position des spots dans le plan de la camera. **

    Parameters
    ----------
    n : int, optional
        Same as ``LaueDiagram.select_spots``.
    sort : str or callable, optional
        Same as ``LaueDiagram.select_spots``.

    Returns
    -------
    np.ndarray
        * Le vecteur des coordonnees x puis le vecteur des y. (en pxl)
        * La shape de retour est (2, nbr_spots).
        * Les spots ne sont pas tries, l&#39;ordre est le meme que
        ``LaueDiagram.select_spots`` sans argument.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt; diag.get_positions().shape
    (2, 78)
    &gt;&gt;&gt; diag.get_positions(n=4, sort=lambda spot: spot.get_position()[0])
    array([[ 132.0286 ,  160.35379,  192.01744,  214.02731],
           [1204.656  ,  907.2095 , 1296.9255 ,  492.425  ]], dtype=float32)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return np.array(
        [spot.get_position() for spot in self.select_spots(n=n, sort=sort)],
        dtype=np.float32).transpose()</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.get_quality"><code class="name flex">
<span>def <span class="ident">get_quality</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Estime a quel point le diagramme est joli. </strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>quality</code></strong> :&ensp;<code>float</code></dt>
<dd>
<ul>
<li>Un scalaire qui permet de juger de la purete du diagramme:</li>
<li>&lt; 1 =&gt; diagramme tres moche, illisible a l'oeil.</li>
<li>&lt; 2 =&gt; diagramme pas bien joli.</li>
<li>&lt; 3 =&gt; diagramme bien joli, avec de belles taches.</li>
<li>> 3 =&gt; diagramme super joli, bien epure avec des taches rondes et intenses.</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt; print(f&quot;quality: {diag.get_quality():.4f}&quot;)
quality: 1.2752
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_quality(self):
    r&#34;&#34;&#34;
    ** Estime a quel point le diagramme est joli. **

    Returns
    -------
    quality : float
        * Un scalaire qui permet de juger de la purete du diagramme:
        * &lt; 1 =&gt; diagramme tres moche, illisible a l&#39;oeil.
        * &lt; 2 =&gt; diagramme pas bien joli.
        * &lt; 3 =&gt; diagramme bien joli, avec de belles taches.
        * \&gt; 3 =&gt; diagramme super joli, bien epure avec des taches rondes et intenses.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt; print(f&#34;quality: {diag.get_quality():.4f}&#34;)
    quality: 1.2752
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def f_nbr(x, n_best_min, n_best_max):
        if x &lt; n_best_min:
            return x / n_best_min
        if n_best_min &lt;= x &lt; n_best_max:
            return 1
        return math.exp(-(x-n_best_max)*(math.log(2)/n_best_max))

    if self.quality is not None:
        return self.quality

    spot_quality = np.mean([spot.get_quality() for spot in self])
    self.quality = f_nbr(len(self), 60, 120) * spot_quality
    return self.quality</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.plot_all"><code class="name flex">
<span>def <span class="ident">plot_all</span></span>(<span>self, *, display=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Affiche le diagramme a l'ecran. </strong></p>
<ul>
<li>Utilise le module <code>matplotlib</code> qui doit etre installe.</li>
<li>Cette methode peut prendre du temps car elle affiche le maximum de choses possible.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>display</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Si True, affiche a l'ecran en faisant appel a <code>plt.show()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.figure.Figure</code></dt>
<dd>La figure matplotlib completee.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image, config_file=&quot;laue/examples/ge_blanc.det&quot;)[0]
&gt;&gt;&gt; diag.plot_all(display=False)
&lt;Figure size 640x480 with 2 Axes&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_all(self, *, display=True):
    &#34;&#34;&#34;
    ** Affiche le diagramme a l&#39;ecran. **

    * Utilise le module ``matplotlib`` qui doit etre installe.
    * Cette methode peut prendre du temps car elle affiche le maximum de choses possible.

    Parameters
    ----------
    display : boolean
        Si True, affiche a l&#39;ecran en faisant appel a ``plt.show()``.

    Returns
    -------
    matplotlib.figure.Figure
        La figure matplotlib completee.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
    &gt;&gt;&gt; diag.plot_all(display=False)
    &lt;Figure size 640x480 with 2 Axes&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    import matplotlib.pyplot as plt

    fig = plt.figure()
    fig.suptitle(self.get_id())
    axe_xy = fig.add_subplot(1, 2, 1)
    axe_gnomonic = fig.add_subplot(1, 2, 2)

    self.plot_xy(axe_xy, display=False)

    try:
        self.plot_gnomonic(axe_gnomonic, display=False)
    except AttributeError:
        pass

    if display:
        plt.show()

    return fig</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.plot_gnomonic"><code class="name flex">
<span>def <span class="ident">plot_gnomonic</span></span>(<span>self, axe_pyplot=None, *, display=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Prepare l'affichage du diagramme dans le plan gnomonic. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axe_pyplot</code></strong> :&ensp;<code>Axe</code></dt>
<dd>Axe matplotlib qui supporte les methodes <code>.scatter</code> et <code>.imshow</code>.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Si True, affiche a l'ecran en faisant appel a <code>plt.show()</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image, config_file=&quot;laue/examples/ge_blanc.det&quot;)[0]
&gt;&gt;&gt;
&gt;&gt;&gt; diag.plot_gnomonic(display=False)
&lt;AxesSubplot:title={'center':'plan gnomonic'}, xlabel='x.Gi (mm)', ylabel='y.Gj (mm)'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; axe = fig.add_subplot()
&gt;&gt;&gt; diag.plot_gnomonic(axe, display=False)
&lt;AxesSubplot:title={'center':'plan gnomonic'}, xlabel='x.Gi (mm)', ylabel='y.Gj (mm)'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_gnomonic(self, axe_pyplot=None, *, display=True):
    &#34;&#34;&#34;
    ** Prepare l&#39;affichage du diagramme dans le plan gnomonic. **

    Parameters
    ----------
    axe_pyplot : Axe
        Axe matplotlib qui supporte les methodes ``.scatter`` et ``.imshow``.
    display : boolean
        Si True, affiche a l&#39;ecran en faisant appel a ``plt.show()``.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)[0]
    &gt;&gt;&gt;
    &gt;&gt;&gt; diag.plot_gnomonic(display=False)
    &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan gnomonic&#39;}, xlabel=&#39;x.Gi (mm)&#39;, ylabel=&#39;y.Gj (mm)&#39;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt; import matplotlib.pyplot as plt
    &gt;&gt;&gt; fig = plt.figure()
    &gt;&gt;&gt; axe = fig.add_subplot()
    &gt;&gt;&gt; diag.plot_gnomonic(axe, display=False)
    &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan gnomonic&#39;}, xlabel=&#39;x.Gi (mm)&#39;, ylabel=&#39;y.Gj (mm)&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if axe_pyplot is None:
        import matplotlib.pyplot as plt
        axe_pyplot = plt.figure().add_subplot()

    axe_pyplot.set_title(&#34;plan gnomonic&#34;)
    axe_pyplot.set_xlabel(&#34;x.Gi (mm)&#34;)
    axe_pyplot.set_ylabel(&#34;y.Gj (mm)&#34;)

    # Affichage image de fond.
    try:
        image = self.get_image_gnomonic()
    except (NameError, AttributeError):
        pass
    else:
        *_, limits = self.experiment._get_gnomonic_matrix()
        mean, std = image.mean(), image.std()
        x_coords, y_coords = self.get_gnomonic_positions()
        axe_pyplot.imshow(image,
            origin=&#39;lower&#39;,
            aspect=((self.experiment.get_images_shape()[1]*x_coords.ptp())
                  / (self.experiment.get_images_shape()[0]*y_coords.ptp())),
            extent=limits,
            vmin=mean-2*std, vmax=mean+4*std, cmap=&#34;gray&#34;)

    # Affichage des axes.
    try:
        for axis in self.find_zone_axes():
            axe_pyplot = axis.plot_gnomonic(axe_pyplot, display=False)
    except AttributeError:
        return axe_pyplot

    # Affichage de spots.
    for spot in self:
        axe_pyplot = spot.plot_gnomonic(axe_pyplot, display=False)

    if display:
        import matplotlib.pyplot as plt
        plt.show()

    return axe_pyplot</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.plot_xy"><code class="name flex">
<span>def <span class="ident">plot_xy</span></span>(<span>self, axe_pyplot=None, *, display=True)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Prepare l'affichage du diagramme dans le plan du capteur. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axe_pyplot</code></strong> :&ensp;<code>Axe</code></dt>
<dd>Axe matplotlib qui supporte les methodes <code>.scatter</code> et <code>.imshow</code>.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Si True, affiche a l'ecran en faisant appel a <code>plt.show()</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt;
&gt;&gt;&gt; diag.plot_xy(display=False)
&lt;AxesSubplot:title={'center':'plan camera'}, xlabel='x.Ci (pxl)', ylabel='y.Cj (pxl)'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig = plt.figure()
&gt;&gt;&gt; axe = fig.add_subplot()
&gt;&gt;&gt; diag.plot_xy(axe, display=False)
&lt;AxesSubplot:title={'center':'plan camera'}, xlabel='x.Ci (pxl)', ylabel='y.Cj (pxl)'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_xy(self, axe_pyplot=None, *, display=True):
    &#34;&#34;&#34;
    ** Prepare l&#39;affichage du diagramme dans le plan du capteur. **

    Parameters
    ----------
    axe_pyplot : Axe
        Axe matplotlib qui supporte les methodes ``.scatter`` et ``.imshow``.
    display : boolean
        Si True, affiche a l&#39;ecran en faisant appel a ``plt.show()``.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt;
    &gt;&gt;&gt; diag.plot_xy(display=False)
    &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan camera&#39;}, xlabel=&#39;x.Ci (pxl)&#39;, ylabel=&#39;y.Cj (pxl)&#39;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt; import matplotlib.pyplot as plt
    &gt;&gt;&gt; fig = plt.figure()
    &gt;&gt;&gt; axe = fig.add_subplot()
    &gt;&gt;&gt; diag.plot_xy(axe, display=False)
    &lt;AxesSubplot:title={&#39;center&#39;:&#39;plan camera&#39;}, xlabel=&#39;x.Ci (pxl)&#39;, ylabel=&#39;y.Cj (pxl)&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if axe_pyplot is None:
        import matplotlib.pyplot as plt
        axe_pyplot = plt.figure().add_subplot()

    axe_pyplot.set_title(&#34;plan camera&#34;)
    axe_pyplot.set_xlabel(&#34;x.Ci (pxl)&#34;)
    axe_pyplot.set_ylabel(&#34;y.Cj (pxl)&#34;)

    # Affichage image de fond.
    try:
        image = self.get_image_xy()
    except NameError:
        pass
    else:
        mean, std = image.mean(), image.std()
        axe_pyplot.imshow(image, vmin=mean-2*std, vmax=mean+4*std, cmap=&#34;gray&#34;)

    # Affichage des spots.
    for spot in self:
        axe_pyplot = spot.plot_xy(axe_pyplot, display=False)

    if display:
        import matplotlib.pyplot as plt
        plt.show()

    return axe_pyplot</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.save_file"><code class="name flex">
<span>def <span class="ident">save_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Enregistre un fichier contenant des informations. </strong></p>
<h2 id="notes">Notes</h2>
<p>Les extensions prises en charge sont
<code>.dat</code>, <code>.jpg</code>, <code>.svg</code>, <code>.png</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Nom ou chemin du fichier de destination.
L'extension doit etre comprise dans le nom du fichier.
Si un fichier du meme nom existe deja, il est ecrase.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import os, tempfile
&gt;&gt;&gt; import laue
&gt;&gt;&gt;
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; rep = tempfile.mkdtemp()
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt; diag.save_file(os.path.join(rep, &quot;ge_blanc.dat&quot;))
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_file(self, filename):
    &#34;&#34;&#34;
    ** Enregistre un fichier contenant des informations. **

    Notes
    -----
    Les extensions prises en charge sont
    ``.dat``, ``.jpg``, ``.svg``, ``.png``

    Parameters
    ----------
    filename : str
        Nom ou chemin du fichier de destination.
        L&#39;extension doit etre comprise dans le nom du fichier.
        Si un fichier du meme nom existe deja, il est ecrase.

    Examples
    --------
    &gt;&gt;&gt; import os, tempfile
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt;
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; rep = tempfile.mkdtemp()
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt; diag.save_file(os.path.join(rep, &#34;ge_blanc.dat&#34;))
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    EXT_OK = {&#34;dat&#34;, &#34;jpg&#34;, &#34;jpeg&#34;, &#34;svg&#34;, &#34;png&#34;}

    assert isinstance(filename, str), \
        f&#34;&#39;filename&#39; has to be a string, not a {type(filename).__name__}.&#34;
    assert &#34;.&#34; in filename, &#34;Le fichier doit posseder une extension.&#34;
    assert filename.split(&#34;.&#34;)[-1].lower() in EXT_OK, (&#34;Seul les extensions &#34;
        f&#34;&#39;{&#39;, &#39;.join(EXT_OK)}&#39; sont supportees. Pas &#39;.{filename.split(&#39;.&#39;)[-1]}&#39;.&#34;)

    ext = filename.split(&#34;.&#34;)[-1].lower()
    if ext == &#34;dat&#34;:
        with open(filename, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
            file.write(&#34;{:&lt;20} {:&lt;20} {:&lt;20}\n&#34;.format(&#34;spot_X&#34;, &#34;spot_Y&#34;, &#34;spot_I&#34;))
            for spot in self:
                file.write(&#34;{x:&lt;20} {y:&lt;20} {i:&lt;20}\n&#34;.format(
                    x=spot.get_position()[0],
                    y=spot.get_position()[1],
                    i=spot.get_intensity()))
    elif ext in {&#34;jpg&#34;, &#34;jpeg&#34;, &#34;svg&#34;, &#34;png&#34;}:
        plt = self.show(_return=True)
        plt.savefig(filename)</code></pre>
</details>
</dd>
<dt id="laue.diagram.LaueDiagram.select_spots"><code class="name flex">
<span>def <span class="ident">select_spots</span></span>(<span>self, *, n=None, sort=None)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere une partie des spots. </strong></p>
<h2 id="notes">Notes</h2>
<p>Les pointeurs des spots renvoyes sont dupliques, c'est une copie superficielle.
Une suppression ou un ajout de spot dans la liste ne changera pas le diagramme
par contre une modification d'un attribut d'un des spots va etre effectif,
et modifira donc definitivement le spot considere.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Nombre de spots a considerer. La valeur <code>None</code> indique
que tous les spots sont renvoyes.</dd>
<dt><strong><code>sort</code></strong> :&ensp;<code>str</code> or <code>callable</code>, optional</dt>
<dd>
<ul>
<li>None =&gt; Les spots ne sont pas tries (le plus rapide). Ils sont cedes dans
un ordre quelquonque mais systematique. L'ordre reste inchange entre 2 appels.</li>
<li>callable =&gt; Clef de tri, qui a chaque spot de type <code><a title="laue.spot.Spot" href="spot.html#laue.spot.Spot">Spot</a></code>.
associe un flotant. Les spots ayant des petits flottant se retrouveront
au debut, ceux avec un gros seront en fin de chaine.</li>
<li>str =&gt; La methode de tri. Il y en a plusieurs possibles:<ul>
<li>"intensity" =&gt; Les spots sont renvoyes par intensite decroissante.</li>
<li>"distortion" =&gt; Les spots sont renvoyes par distortion croissante.</li>
<li>"quality" =&gt; Les spots sont renvoyes par qualite decroissante.</li>
</ul>
</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>La liste des spots. Chaque element est de type <code><a title="laue.spot.Spot" href="spot.html#laue.spot.Spot">Spot</a></code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = laue.Experiment(image)[0]
&gt;&gt;&gt; diag.select_spots(n=2, sort=&quot;intensity&quot;)
[Spot(bbox=(617, 1651, 11, 13), distortion=1.0760), Spot(bbox=(928, 1210, 10, 11), distortion=1.0673)]
&gt;&gt;&gt; diag.select_spots(n=2, sort=&quot;distortion&quot;)
[Spot(bbox=(928, 1210, 10, 11), distortion=1.0673), Spot(bbox=(617, 1651, 11, 13), distortion=1.0760)]
&gt;&gt;&gt; diag.select_spots(n=2, sort=lambda spot: spot.get_position()[0])
[Spot(bbox=(130, 1202, 5, 6), distortion=1.1804), Spot(bbox=(157, 905, 7, 6), distortion=1.1342)]
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_spots(self, *, n=None, sort=None):
    &#34;&#34;&#34;
    ** Recupere une partie des spots. **

    Notes
    -----
    Les pointeurs des spots renvoyes sont dupliques, c&#39;est une copie superficielle.
    Une suppression ou un ajout de spot dans la liste ne changera pas le diagramme
    par contre une modification d&#39;un attribut d&#39;un des spots va etre effectif,
    et modifira donc definitivement le spot considere.

    Parameters
    ----------
    n : int, optional
        Nombre de spots a considerer. La valeur ``None`` indique
        que tous les spots sont renvoyes.
    sort : str or callable, optional
        - None =&gt; Les spots ne sont pas tries (le plus rapide). Ils sont cedes dans
        un ordre quelquonque mais systematique. L&#39;ordre reste inchange entre 2 appels.
        - callable =&gt; Clef de tri, qui a chaque spot de type ``laue.spot.Spot``.
        associe un flotant. Les spots ayant des petits flottant se retrouveront
        au debut, ceux avec un gros seront en fin de chaine.
        - str =&gt; La methode de tri. Il y en a plusieurs possibles:
            - &#34;intensity&#34; =&gt; Les spots sont renvoyes par intensite decroissante.
            - &#34;distortion&#34; =&gt; Les spots sont renvoyes par distortion croissante.
            - &#34;quality&#34; =&gt; Les spots sont renvoyes par qualite decroissante.

    Returns
    -------
    list
        La liste des spots. Chaque element est de type ``laue.spot.Spot``.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = laue.Experiment(image)[0]
    &gt;&gt;&gt; diag.select_spots(n=2, sort=&#34;intensity&#34;)
    [Spot(bbox=(617, 1651, 11, 13), distortion=1.0760), Spot(bbox=(928, 1210, 10, 11), distortion=1.0673)]
    &gt;&gt;&gt; diag.select_spots(n=2, sort=&#34;distortion&#34;)
    [Spot(bbox=(928, 1210, 10, 11), distortion=1.0673), Spot(bbox=(617, 1651, 11, 13), distortion=1.0760)]
    &gt;&gt;&gt; diag.select_spots(n=2, sort=lambda spot: spot.get_position()[0])
    [Spot(bbox=(130, 1202, 5, 6), distortion=1.1804), Spot(bbox=(157, 905, 7, 6), distortion=1.1342)]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert n is None or isinstance(n, int), f&#34;&#39;n&#39; can not be {type(n).__name__}.&#34;
    assert n is None or n &gt; 0, f&#34;&#39;n&#39; can not be {n}.&#34;
    assert (sort is None or hasattr(sort, &#34;__call__&#34;)
        or sort in {&#34;intensity&#34;, &#34;distortion&#34;, &#34;quality&#34;}), \
        f&#34;&#39;sort&#39; ne peut pas etre {sort}.&#34;

    if sort is None: # Si il n&#39;y a pas de tri a faire.
        if n is None:
            return self.spots.copy()
        return self.spots[:n]

    if hasattr(sort, &#34;__call__&#34;):
        l_spots = sorted(self.spots, key=sort)
    if sort in self.sorted_spots: # On enregistre la liste pour de melleur
        l_spots = self.sorted_spots[sort] #  perfs aux apels suivants.
    else:
        if sort == &#34;intensity&#34;:
            l_spots = sorted(self.spots, key=(lambda spot: -spot.get_intensity()))
        elif sort == &#34;distortion&#34;:
            l_spots = sorted(self.spots, key=(lambda spot: spot.get_distortion()))
        elif sort == &#34;quality&#34;:
            l_spots = sorted(self.spots, key=(lambda spot: -spot.get_quality()))
        self.sorted_spots[sort] = l_spots

    if n is not None:
        return l_spots[:n]
    return l_spots</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#permet-de-manipuler-un-diagramme-de-laue-unique">Permet de manipuler un diagramme de Laue unique.</a></li>
<li><a href="#notes">Notes</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laue" href="index.html">laue</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laue.diagram.LaueDiagram" href="#laue.diagram.LaueDiagram">LaueDiagram</a></code></h4>
<ul class="">
<li><code><a title="laue.diagram.LaueDiagram.__contains__" href="#laue.diagram.LaueDiagram.__contains__">__contains__</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.__getitem__" href="#laue.diagram.LaueDiagram.__getitem__">__getitem__</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.__hash__" href="#laue.diagram.LaueDiagram.__hash__">__hash__</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.__iter__" href="#laue.diagram.LaueDiagram.__iter__">__iter__</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.__len__" href="#laue.diagram.LaueDiagram.__len__">__len__</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.find_subsets" href="#laue.diagram.LaueDiagram.find_subsets">find_subsets</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="#laue.diagram.LaueDiagram.find_zone_axes">find_zone_axes</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.get_gnomonic_positions" href="#laue.diagram.LaueDiagram.get_gnomonic_positions">get_gnomonic_positions</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.get_id" href="#laue.diagram.LaueDiagram.get_id">get_id</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.get_image_gnomonic" href="#laue.diagram.LaueDiagram.get_image_gnomonic">get_image_gnomonic</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.get_image_xy" href="#laue.diagram.LaueDiagram.get_image_xy">get_image_xy</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.get_positions" href="#laue.diagram.LaueDiagram.get_positions">get_positions</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.get_quality" href="#laue.diagram.LaueDiagram.get_quality">get_quality</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.plot_all" href="#laue.diagram.LaueDiagram.plot_all">plot_all</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.plot_gnomonic" href="#laue.diagram.LaueDiagram.plot_gnomonic">plot_gnomonic</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.plot_xy" href="#laue.diagram.LaueDiagram.plot_xy">plot_xy</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.save_file" href="#laue.diagram.LaueDiagram.save_file">save_file</a></code></li>
<li><code><a title="laue.diagram.LaueDiagram.select_spots" href="#laue.diagram.LaueDiagram.select_spots">select_spots</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>