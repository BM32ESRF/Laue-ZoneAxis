<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>laue.core.geometry.symbolic API documentation</title>
<meta name="description" content="Recherche les equations symboliques qui expriment
les transformations geometriques." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laue.core.geometry.symbolic</code></h1>
</header>
<section id="section-intro">
<p>Recherche les equations symboliques qui expriment
les transformations geometriques.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
Recherche les equations symboliques qui expriment
les transformations geometriques.
&#34;&#34;&#34;

import hashlib
import inspect
import numbers
import os

import cloudpickle
import numpy as np
import sympy

import laue
import laue.utilities.lambdify as lambdify


class Equations:
    &#34;&#34;&#34;
    Exprime des petites transformations elementaires.

    C&#39;est une interface de la classe ``laue.core.geometry.transformer.Transformer``.
    &#34;&#34;&#34;
    def __init__(self):
        # Les constantes.
        self.dd = sympy.Symbol(&#34;dd&#34;, real=True, positive=True) # Distance entre l&#39;origine et le plan de la camera en mm.
        self.xcen, self.ycen = sympy.symbols(&#34;xcen ycen&#34;, real=True) # Position du point d&#39;incidence normale en pxl par rapport au repere de la camera.
        self.xbet, self.xgam = sympy.symbols(&#34;beta gamma&#34;, real=True) # Rotation autour x camera, Rotation autour axe incidence normale.
        self.pixelsize = sympy.Symbol(&#34;pixelsize&#34;, real=True, positive=True) # Taille des pixels en mm/pxl.

        # Les variables.
        self.x_cam, self.y_cam = sympy.symbols(&#34;x_cam y_cam&#34;, real=True, positive=True) # Position du pxl dans le repere du plan de la camera.
        self.x_gnom, self.y_gnom = sympy.symbols(&#34;x_gnom y_gnom&#34;, real=True) # Position des points dans le plan gnomonic.
        self.theta, self.chi = sympy.symbols(&#34;theta chi&#34;, real=True) # Les angles decrivant le rayon reflechit.

        # Expression des elements du model.
        self.rx = sympy.Matrix([1, 0, 0])
        self.ry = sympy.Matrix([0, 1, 0])
        self.rz = sympy.Matrix([0, 0, 1])

        self.u_i = self.rx # Le rayon de lumiere incident norme parallele a l&#39;axe X dans le repere du cristal.

        self.rot_camera = sympy.rot_axis2(-self.xbet) @ sympy.rot_axis3(self.xgam) # Rotation globale de la camera par rapport au cristal.
        self.ci = self.rot_camera @ -self.ry # Vecteur Xcamera.
        self.cj = self.rot_camera @ self.rx # Vecteur Ycamera.
        self.ck = self.rot_camera @ self.rz # Vecteur Zcamera normal au plan de la camera.

        self.rot_gnom = sympy.rot_axis2(-sympy.pi/4) # Rotation du repere de plan gnomonic par rapport au repere du cristal.
        self.gi = self.rot_gnom @ self.rz # Vecteur Xgnomonic.
        self.gj = self.rot_gnom @ self.ry # Vecteur Ygnomonic.
        self.gk = self.rot_gnom @ -self.rx # Vecteur Zgnomonic normal au plan gnomonic.

    def get_expr_cam_to_uf(self, x_cam, y_cam):
        &#34;&#34;&#34;
        ** Equation permetant de passer de la camera a uf. **

        Notes
        -----
        Le vecteur de sortie (uf) n&#39;est pas normalise.

        Parameters
        ----------
        x_cam
            La position x de la camera.
        y_cam
            La position y de la camera.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uf dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_cam, y_cam = symbols(&#34;x y&#34;)
        &gt;&gt;&gt; transformer.get_expr_cam_to_uf(x_cam, y_cam)
        Matrix([
        [dd*sin(beta) - pixelsize*((x - xcen)*sin(gamma)*cos(beta) - (y - ycen)*cos(beta)*cos(gamma))],
        [                                  -pixelsize*((x - xcen)*cos(gamma) + (y - ycen)*sin(gamma))],
        [dd*cos(beta) + pixelsize*((x - xcen)*sin(beta)*sin(gamma) - (y - ycen)*sin(beta)*cos(gamma))]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        x_cam_atomic, y_cam_atomic = sympy.symbols(&#34;x_cam y_cam&#34;, real=True)
        o_op = self.dd * self.ck # Vecteur OO&#39;.
        op_p = self.pixelsize * ((x_cam_atomic-self.xcen)*self.ci + (y_cam_atomic-self.ycen)*self.cj) # Vecteur O&#39;P
        o_p = o_op + op_p # Relation de Chasles.
        o_p = sympy.signsimp(o_p)
        return o_p.subs({x_cam_atomic: x_cam, y_cam_atomic: y_cam})

    def get_expr_uf_to_cam(self, uf_x, uf_y, uf_z):
        &#34;&#34;&#34;
        ** Equation permettant de passer de uf a la camera. **

        Parameters
        ----------
        uf_x, uf_y, uf_z
            Les 3 coordonnees du vecteur uf exprimees dans le repere principale.

        Returns
        -------
        x_camera : sympy.Basic
            Expression sympy de la position de la tache dans le repere
            de la camera. (selon l&#39;axe x ou Ci)
        y_camera : sympy.Basic
            Comme ``x_camera`` selon l&#39;axe y ou Cj.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&#34;uf_x, uf_y, uf_z&#34;)
        &gt;&gt;&gt; x_cam, y_cam = transformer.get_expr_uf_to_cam(uf_x, uf_y, uf_z)
        &gt;&gt;&gt; x_cam
        (-dd*uf_x*sin(gamma)*cos(beta) - dd*uf_y*cos(gamma) + dd*uf_z*sin(beta)*sin(gamma) + pixelsize*uf_x*xcen*sin(beta) + pixelsize*uf_z*xcen*cos(beta))/(pixelsize*(uf_x*sin(beta) + uf_z*cos(beta)))
        &gt;&gt;&gt; y_cam
        (dd*uf_x*cos(beta)*cos(gamma) - dd*uf_y*sin(gamma) - dd*uf_z*sin(beta)*cos(gamma) + pixelsize*uf_x*ycen*sin(beta) + pixelsize*uf_z*ycen*cos(beta))/(pixelsize*(uf_x*sin(beta) + uf_z*cos(beta)))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        uf_x_atomic, uf_y_atomic, uf_z_atomic = sympy.symbols(&#34;uf_x uf_y uf_z&#34;, real=True)
        u_f = sympy.Matrix([uf_x_atomic, uf_y_atomic, uf_z_atomic])

        # Expression du vecteur O&#39;&#39;P.
        opp_op = self.pixelsize * (self.xcen*self.ci + self.ycen*self.cj) # Vecteur O&#39;&#39;O&#39;.
        o_op = self.dd * self.ck # Vecteur OO&#39;.
        op_o = -o_op # Vecteur O&#39;O.
        camera_plane = sympy.Plane(o_op, normal_vector=self.ck) # Plan de la camera.
        refl_ray = sympy.Line([0, 0, 0], u_f) # Rayon reflechi.
        o_p = sympy.Matrix(camera_plane.intersection(refl_ray).pop())
        opp_p = opp_op + op_o + o_p # Relation de Chasles.

        # Projection dans le plan de la camera pour remonter a x_c, y_c
        x_cam = opp_p.dot(self.ci) / self.pixelsize # Coordonnees en pxl axe x de la camera.
        y_cam = opp_p.dot(self.cj) / self.pixelsize # Coordonnees en pxl axe y de la camera.
        x_cam, y_cam = sympy.trigsimp(x_cam), sympy.trigsimp(y_cam) # Longueur reduite par 2.2 .

        return (x_cam.subs({uf_x_atomic: uf_x, uf_y_atomic: uf_y, uf_z_atomic: uf_z}),
                y_cam.subs({uf_x_atomic: uf_x, uf_y_atomic: uf_y, uf_z_atomic: uf_z}))

    def get_expr_uf_to_uq(self, uf_x, uf_y, uf_z):
        &#34;&#34;&#34;
        ** Equation permettant de passer de uf a uq. **

        Parameters
        ----------
        uf_x, uf_y, uf_z
            Les 3 coordonnees du vecteur uf exprimees dans le repere principal.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uq dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&#34;uf_x, uf_y, uf_z&#34;)
        &gt;&gt;&gt; transformer.get_expr_uf_to_uq(uf_x, uf_y, uf_z)
        Matrix([
        [uf_x - sqrt(uf_x**2 + uf_y**2 + uf_z**2)],
        [                                    uf_y],
        [                                    uf_z]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        uf_x_atomic, uf_y_atomic, uf_z_atomic = sympy.symbols(&#34;uf_x uf_y uf_z&#34;, real=True)
        u_f = sympy.Matrix([uf_x_atomic, uf_y_atomic, uf_z_atomic])
        u_q = u_f - self.u_i*u_f.norm() # Relation de reflexion.
        return u_q.subs({uf_x_atomic: uf_x, uf_y_atomic: uf_y, uf_z_atomic: uf_z})

    def get_expr_uq_to_uf(self, uq_x, uq_y, uq_z):
        &#34;&#34;&#34;
        ** Equation permettant de passer de uq a uf. **

        Parameters
        ----------
        uq_x, uq_y, uq_z
            Les 3 coordonnees du vecteur uq exprimees dans le repere principal.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uf dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uq_x, uq_y, uq_z = symbols(&#34;uq_x, uq_y, uq_z&#34;)
        &gt;&gt;&gt; transformer.get_expr_uq_to_uf(uq_x, uq_y, uq_z)
        Matrix([
        [-uq_x**2 + uq_y**2 + uq_z**2],
        [                -2*uq_x*uq_y],
        [                -2*uq_x*uq_z]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        uq_x_atomic, uq_y_atomic, uq_z_atomic = sympy.symbols(&#34;uq_x uq_y uq_z&#34;, real=True)
        u_q = sympy.Matrix([uq_x_atomic, uq_y_atomic, uq_z_atomic])
        u_f = self.u_i*u_q.norm()**2 - 2*u_q.dot(self.u_i)*u_q # Vecteur unitaire reflechi.
        return u_f.subs({uq_x_atomic: uq_x, uq_y_atomic: uq_y, uq_z_atomic: uq_z})

    def get_expr_uq_to_gnomonic(self, uq_x, uq_y, uq_z):
        &#34;&#34;&#34;
        ** Equation permettant de passer de uq a gnomonic. **

        Parameters
        ----------
        uq_x, uq_y, uq_z
            Les 3 coordonnees du vecteur uq exprimees dans le repere principal.

        Returns
        -------
        x_gnomonic : sympy.Basic
            Expression sympy de la position de la tache dans le repere
            du plan gnomonic. (selon l&#39;axe x ou Gi)
        y_gnomonic : sympy.Basic
            Comme ``x_gnomonic`` selon l&#39;axe y ou Gj.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uq_x, uq_y, uq_z = symbols(&#34;uq_x, uq_y, uq_z&#34;)
        &gt;&gt;&gt; x_gnom, y_gnom = transformer.get_expr_uq_to_gnomonic(uq_x, uq_y, uq_z)
        &gt;&gt;&gt; x_gnom
        -(uq_x + uq_z)/(uq_x - uq_z)
        &gt;&gt;&gt; y_gnom
        -sqrt(2)*uq_y/(uq_x - uq_z)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        uq_x_atomic, uq_y_atomic, uq_z_atomic = sympy.symbols(&#34;uq_x uq_y uq_z&#34;, real=True)
        u_q = sympy.Matrix([uq_x_atomic, uq_y_atomic, uq_z_atomic])
        o_oppp = 1*self.gk # Car sphere unitaire de rayon 1.

        gnom_plane = sympy.Plane(o_oppp, normal_vector=self.gk) # Plan gnomonic.
        normal_ray = sympy.Line([0, 0, 0], u_q) # Droite portee par la normal au plan christalin.
        o_pp = sympy.Matrix(gnom_plane.intersection(normal_ray).pop())
        oppp_pp = -o_oppp + o_pp

        # Projection dans le plan gnomonic pour remonter a x_g, y_g.
        x_gnom = oppp_pp.dot(self.gi) # Coordonnees en mm axe x du plan gnomonic.
        y_gnom = oppp_pp.dot(self.gj) # Coordonnees en mm axe y du plan gnomonic.

        x_gnom = sympy.signsimp(sympy.cancel(x_gnom))

        return (x_gnom.subs({uq_x_atomic: uq_x, uq_y_atomic: uq_y, uq_z_atomic: uq_z}),
                y_gnom.subs({uq_x_atomic: uq_x, uq_y_atomic: uq_y, uq_z_atomic: uq_z}))

    def get_expr_gnomonic_to_uq(self, x_gnom, y_gnom):
        &#34;&#34;&#34;
        ** Equation permettant de passer du plan gnomonique a uq. **

        Parameters
        ----------
        x_gnom
            La position x du plan gnomonic.
        y_gnom
            La position y du plan gnomonic.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uq dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_gnom, y_gnom = symbols(&#34;x y&#34;)
        &gt;&gt;&gt; transformer.get_expr_gnomonic_to_uq(x_gnom, y_gnom)
        Matrix([
        [sqrt(2)*x/2 - sqrt(2)/2],
        [                      y],
        [sqrt(2)*x/2 + sqrt(2)/2]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        x_gnom_atomic, y_gnom_atomic = sympy.symbols(&#34;x_gnom y_gnom&#34;, real=True)

        o_oppp = 1*self.gk # Vecteur OO&#39;&#39;&#39; == gk car le plan gnomonic est tangent a la shere unitaire.
        u_q = o_oppp + (x_gnom_atomic*self.gi + y_gnom_atomic*self.gj) # Relation de chasle.

        return u_q.subs({x_gnom_atomic: x_gnom, y_gnom_atomic: y_gnom})

    def get_expr_uf_to_thetachi(self, uf_x, uf_y, uf_z):
        &#34;&#34;&#34;
        ** Equation permetant de passer de uf a thetachi. **

        Parameters
        ----------
        uf_x, uf_y, uf_z
            Les 3 coordonnees du vecteur uf exprimees dans le repere principal.

        Returns
        -------
        theta : sympy.Basic
            Angle de rotation du plan christalin autour de -x.
        chi : sympy.Basic
            La moitier de l&#39;angle de rotation du plan christalin autour de -y.

        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&#34;uf_x, uf_y, uf_z&#34;, real=True)
        &gt;&gt;&gt; theta, chi = transformer.get_expr_uf_to_thetachi(uf_x, uf_y, uf_z)
        &gt;&gt;&gt; theta
        acos(uf_x/sqrt(uf_x**2 + uf_y**2 + uf_z**2))/2
        &gt;&gt;&gt; chi
        asin(uf_y/sqrt(uf_y**2 + uf_z**2))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def select(theta, chi):
            &#34;&#34;&#34;
            Cherche si theta &gt; 0 et -pi/2 &lt; chi &lt; pi/2
            &#34;&#34;&#34;
            func = sympy.lambdify([x, y, z], [theta, chi], modules=&#34;numpy&#34;)
            theta_vals, chi_vals = func(*np.meshgrid([-.5, .5], [-.5, .5], [.5]))
            if (theta_vals &lt; 0).any() or (chi_vals &lt; -np.pi/2).any() or (chi_vals &gt; np.pi/2).any():
                return False
            return True

        theta_atomic, chi_atomic = sympy.symbols(&#34;theta chi&#34;, real=True)
        x, y, z = sympy.symbols(&#34;x, y, z&#34;, real=True)
        u_f = sympy.Matrix([x, y, z])
        
        theta, chi = [
            (sol[theta_atomic], sol[chi_atomic])
            for sol in
            sympy.solve(
                self.get_expr_thetachi_to_uf(theta_atomic, chi_atomic)-u_f,
                [theta_atomic, chi_atomic],
                dict=True)
            if select(sol[theta_atomic], sol[chi_atomic])
            ].pop()

        uf_x, uf_y, uf_z = sympy.Matrix([uf_x, uf_y, uf_z]).normalized()

        return (theta.subs({x: uf_x, y: uf_y, z: uf_z}),
                chi.subs({x: uf_x, y: uf_y, z: uf_z}).simplify())

    def get_expr_thetachi_to_uf(self, theta, chi):
        &#34;&#34;&#34;
        ** Equation permetant de passer de thetachi a uf. **

        Parameters
        ----------
        theta
            Angle de rotation du plan christalin autour de -x.
        chi
            La moitier de l&#39;angle de rotation du plan christalin autour de -y.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uf dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; theta, chi = symbols(&#34;theta chi&#34;)
        &gt;&gt;&gt; transformer.get_expr_thetachi_to_uf(theta, chi)
        Matrix([
        [         cos(2*theta)],
        [sin(chi)*sin(2*theta)],
        [sin(2*theta)*cos(chi)]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        theta_atomic, chi_atomic = sympy.symbols(&#34;theta chi&#34;, real=True)

        # Expresion du rayon reflechit en fonction des angles.
        rot_refl = sympy.rot_axis1(chi_atomic) @ sympy.rot_axis2(2*theta_atomic)
        u_f = rot_refl @ self.u_i

        return u_f.subs({theta_atomic: theta, chi_atomic: chi})

class Compilator(Equations):
    &#34;&#34;&#34;
    Extrait et enregistre les equations brutes.
    Combine les blocs elementaire afin

    Notes
    -----
    Les equations sont enregistrees de facon globale
    de sorte a eviter la recompilation entre chaque objet,
    et permet aussi d&#39;alleger la serialisation de ``Transformer``.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Genere le dictionaire a protee globale.
        &#34;&#34;&#34;
        Equations.__init__(self)

        if &#34;compiled_expressions&#34; not in globals():
            globals()[&#34;compiled_expressions&#34;] = {}

        self.load()

    def compile(self):
        &#34;&#34;&#34;
        ** Precalcul toutes les equations completes. **
        &#34;&#34;&#34;
        names = [
            &#34;cam_to_gnomonic&#34;,
            &#34;gnomonic_to_cam&#34;,
            &#34;cam_to_thetachi&#34;,
            &#34;thetachi_to_cam&#34;,
            &#34;thetachi_to_gnomonic&#34;,
            &#34;gnomonic_to_thetachi&#34;,
            &#34;dist_line&#34;,
            &#34;hough&#34;,
            &#34;inter_line&#34;]
        names = [n for n in names if n not in globals()[&#34;compiled_expressions&#34;]]

        for name in names:
            getattr(self, f&#34;get_fct_{name}&#34;)()

        self.save() # On enregistre les grandes equations.

    def get_fct_cam_to_gnomonic(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de la camera au plan gnomonic. **
        &#34;&#34;&#34;
        if &#34;fct_cam_to_gnomonic&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_gnomonic&#34;]

        u_f = self.get_expr_cam_to_uf(self.x_cam, self.y_cam)
        u_q = self.get_expr_uf_to_uq(*u_f)
        x_gnom, y_gnom = self.get_expr_uq_to_gnomonic(*u_q)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_gnomonic&#34;] = lambdify.Lambdify(
            args=[self.x_cam, self.y_cam, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
            expr=[x_gnom, y_gnom]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_gnomonic&#34;]

    def get_fct_gnomonic_to_cam(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de l&#39;espace gnomonic a celui de la camera. **
        &#34;&#34;&#34;
        if &#34;fct_gnomonic_to_cam&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_cam&#34;]

        u_q = self.get_expr_gnomonic_to_uq(self.x_gnom, self.y_gnom)
        u_f = self.get_expr_uq_to_uf(*u_q)
        x_c, y_c = self.get_expr_uf_to_cam(*u_f)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_cam&#34;] = lambdify.Lambdify(
            args=[self.x_gnom, self.y_gnom, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
            expr=[x_c, y_c]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_cam&#34;]

    def get_fct_thetachi_to_cam(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de theta chi a la camera. **
        &#34;&#34;&#34;
        if &#34;fct_thetachi_to_cam&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_cam&#34;]

        u_f = self.get_expr_thetachi_to_uf(self.theta, self.chi)
        x_c, y_c = self.get_expr_uf_to_cam(*u_f)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_cam&#34;] = lambdify.Lambdify(
            args=[self.theta, self.chi, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
            expr=[x_c, y_c]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_cam&#34;]

    def get_fct_cam_to_thetachi(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de la camera a la representation theta chi. **
        &#34;&#34;&#34;
        if &#34;fct_cam_to_thetachi&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_thetachi&#34;]

        u_f = self.get_expr_cam_to_uf(self.x_cam, self.y_cam)
        theta, chi = self.get_expr_uf_to_thetachi(*u_f)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_thetachi&#34;] = lambdify.Lambdify(
            args=[self.x_cam, self.y_cam, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
            expr=[theta, chi]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_thetachi&#34;]

    def get_fct_thetachi_to_gnomonic(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de theta chi au plan gnomonic. **
        &#34;&#34;&#34;
        if &#34;fct_thetachi_to_gnomonic&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_gnomonic&#34;]

        u_f = self.get_expr_thetachi_to_uf(self.theta, self.chi)
        u_q = self.get_expr_uf_to_uq(*u_f)
        x_gnom, y_gnom = self.get_expr_uq_to_gnomonic(*u_q)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_gnomonic&#34;] = lambdify.Lambdify(
            args=[self.theta, self.chi],
            expr=[x_gnom, y_gnom]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_gnomonic&#34;]

    def get_fct_gnomonic_to_thetachi(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer du plan gnomonic a la representation theta chi. **
        &#34;&#34;&#34;
        if &#34;fct_gnomonic_to_thetachi&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_thetachi&#34;]

        u_q = self.get_expr_gnomonic_to_uq(self.x_gnom, self.y_gnom)
        u_f = self.get_expr_uq_to_uf(*u_q)
        theta, chi = self.get_expr_uf_to_thetachi(*u_f)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_thetachi&#34;] = lambdify.Lambdify(
            args=[self.x_gnom, self.y_gnom],
            expr=[theta, chi]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_thetachi&#34;]

    def get_fct_dist_line(self):
        &#34;&#34;&#34;
        ** Equation de projection de points sur une droite. **
        &#34;&#34;&#34;
        if &#34;fct_dist_line&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_dist_line&#34;]

        # Creation de la droite.
        theta, dist, x, y = sympy.symbols(&#34;theta alpha x y&#34;, real=True)
        p = sympy.Point(dist*sympy.cos(theta), dist*sympy.sin(theta)) # Point appartenant a la droite.
        op = sympy.Line(sympy.Point(0, 0), p) # Droite normale a la droite principale.
        line = op.perpendicular_line(p) # C&#39;est la droite principale.

        # Projection des points.
        distance = line.distance(sympy.Point(x, y)) # La distance entre la droite et un point.

        # Optimisation.
        distance = sympy.trigsimp(distance) # Permet un gain de 2.90

        # Vectorisation de l&#39;expression.
        globals()[&#34;compiled_expressions&#34;][&#34;fct_dist_line&#34;] = lambdify.Lambdify([theta, dist, x, y], distance)
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_dist_line&#34;]

    def get_fct_hough(self):
        &#34;&#34;&#34;
        ** Equation pour la transformee de hough. **
        &#34;&#34;&#34;
        if &#34;fct_hough&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_hough&#34;]

        xa, ya, xb, yb = sympy.symbols(&#34;x_a y_a x_b y_b&#34;, real=True)
        u = sympy.Matrix([xa-xb, ya-yb]).normalized()
        x = sympy.Matrix([1, 0])

        # Calcul de la distance entre la droite et l&#39;origine.
        d1 = sympy.Line(sympy.Point(xa, ya), sympy.Point(xb, yb)) # C&#39;est la droite passant par les 2 points.
        dist = d1.distance(sympy.Point(0, 0)) # La distance separant l&#39;origine de la droite.

        # Calcul de l&#39;angle entre l&#39;axe horizontal et la droite.
        p = d1.projection(sympy.Point(0, 0)) # Le point ou la distance entre ce point de la droite et l&#39;origine est minimale.
        n = p / sympy.sqrt(p.x**2 + p.y**2) # On normalise le point.
        theta_abs = sympy.acos(n.x) # La valeur absolue de theta.
        theta_sign = sympy.sign(n.y) # Si il est negatif c&#39;est que theta &lt; 0, si il est positif alors theta &gt; 0
        theta = theta_abs * theta_sign # Compris entre -pi et +pi
        # theta = sympy.simplify(theta)

        # Optimisation.
        theta = theta # Permet un gain de 1.00
        dist = sympy.trigsimp(sympy.cancel(dist)) # Permet un gain de 1.40

        # Vectorisation des expressions.
        globals()[&#34;compiled_expressions&#34;][&#34;fct_hough&#34;] = lambdify.Lambdify([xa, ya, xb, yb], [theta, dist])
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_hough&#34;]

    def get_fct_inter_line(self):
        &#34;&#34;&#34;
        ** Equation d&#39;intersection entre 2 droites. **
        &#34;&#34;&#34;
        if &#34;fct_inter_line&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_inter_line&#34;]

        # Creation des 2 droites.
        theta_1, dist_1, theta_2, dist_2 = sympy.symbols(&#34;theta_1, dist_1, theta_2, dist_2&#34;, real=True)
        p1 = sympy.Point(dist_1*sympy.cos(theta_1), dist_1*sympy.sin(theta_1)) # Point appartenant a la premiere droite.
        p2 = sympy.Point(dist_2*sympy.cos(theta_2), dist_2*sympy.sin(theta_2)) # Point appartenant a la seconde droite.
        op1 = sympy.Line(sympy.Point(0, 0), p1) # Droite normale a la premiere droite.
        op2 = sympy.Line(sympy.Point(0, 0), p2) # Droite normale a la deuxieme droite.
        line1 = op1.perpendicular_line(p1) # La premiere droite.
        line2 = op2.perpendicular_line(p2) # La seconde droite.

        # Calcul des coordonnes du point d&#39;intersection.
        point = line1.intersection(line2)[0]
        inter_x = point.x
        inter_y = point.y

        # Optimisation.
        # Il n&#39;y en a pas car les expressions sont deja tres simples.

        # Vectorisation des expressions.
        globals()[&#34;compiled_expressions&#34;][&#34;fct_inter_line&#34;] = lambdify.Lambdify(
            [theta_1, dist_1, theta_2, dist_2], [inter_x, inter_y])
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_inter_line&#34;]

    def _hash(self):
        &#34;&#34;&#34;
        ** Retourne le hash de ce code. **
        &#34;&#34;&#34;
        return hashlib.md5(
            inspect.getsource(Compilator).encode(encoding=&#34;utf-8&#34;)
          + inspect.getsource(Equations).encode(encoding=&#34;utf-8&#34;)
          + inspect.getsource(lambdify).encode(encoding=&#34;utf-8&#34;)
            ).hexdigest()

    def load(self):
        &#34;&#34;&#34;
        ** Charge si il existe, le fichier contenant les expressions. **

        Deverse les expressions dans le dictionaire: ``globals()[&#34;compiled_expressions&#34;]``.
        &#34;&#34;&#34;
        dirname = os.path.dirname(os.path.abspath(laue.__file__))
        file = os.path.join(dirname, &#34;data&#34;, &#34;geometry.data&#34;)
        
        if os.path.exists(file):
            with open(file, &#34;rb&#34;) as f:
                try:
                    content = cloudpickle.load(f)
                except ValueError: # Si c&#39;est pas le bon protocol
                    content = {&#34;hash&#34;: None}
                else:
                    content[&#34;expr&#34;] = {name: lambdify.Lambdify.loads(data) for name, data in content[&#34;expr&#34;].items()}
            if content[&#34;hash&#34;] == self._hash(): # Si les donnees sont a jour.
                globals()[&#34;compiled_expressions&#34;] = {**globals()[&#34;compiled_expressions&#34;], **content[&#34;expr&#34;]}
        return globals()[&#34;compiled_expressions&#34;]

    def save(self):
        &#34;&#34;&#34;
        ** Enregistre un fichier contenant les expressions. **

        Enregistre seulement ce qui est present dans ``globals()[&#34;compiled_expressions&#34;]``.
        N&#39;ecrase pas l&#39;ancien contenu.
        &#34;&#34;&#34;
        dirname = os.path.dirname(os.path.abspath(laue.__file__))
        file = os.path.join(dirname, &#34;data&#34;, &#34;geometry.data&#34;)
        self.load() # Recuperation du contenu du fichier.
        content = {
            &#34;hash&#34;: self._hash(),
            &#34;expr&#34;: {name: l.dumps()
                for name, l in globals()[&#34;compiled_expressions&#34;].items()
                }
            }
        with open(file, &#34;wb&#34;) as f:
            cloudpickle.dump(content, f)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laue.core.geometry.symbolic.Compilator"><code class="flex name class">
<span>class <span class="ident">Compilator</span></span>
</code></dt>
<dd>
<div class="desc"><p>Extrait et enregistre les equations brutes.
Combine les blocs elementaire afin</p>
<h2 id="notes">Notes</h2>
<p>Les equations sont enregistrees de facon globale
de sorte a eviter la recompilation entre chaque objet,
et permet aussi d'alleger la serialisation de <code>Transformer</code>.</p>
<p>Genere le dictionaire a protee globale.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Compilator(Equations):
    &#34;&#34;&#34;
    Extrait et enregistre les equations brutes.
    Combine les blocs elementaire afin

    Notes
    -----
    Les equations sont enregistrees de facon globale
    de sorte a eviter la recompilation entre chaque objet,
    et permet aussi d&#39;alleger la serialisation de ``Transformer``.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Genere le dictionaire a protee globale.
        &#34;&#34;&#34;
        Equations.__init__(self)

        if &#34;compiled_expressions&#34; not in globals():
            globals()[&#34;compiled_expressions&#34;] = {}

        self.load()

    def compile(self):
        &#34;&#34;&#34;
        ** Precalcul toutes les equations completes. **
        &#34;&#34;&#34;
        names = [
            &#34;cam_to_gnomonic&#34;,
            &#34;gnomonic_to_cam&#34;,
            &#34;cam_to_thetachi&#34;,
            &#34;thetachi_to_cam&#34;,
            &#34;thetachi_to_gnomonic&#34;,
            &#34;gnomonic_to_thetachi&#34;,
            &#34;dist_line&#34;,
            &#34;hough&#34;,
            &#34;inter_line&#34;]
        names = [n for n in names if n not in globals()[&#34;compiled_expressions&#34;]]

        for name in names:
            getattr(self, f&#34;get_fct_{name}&#34;)()

        self.save() # On enregistre les grandes equations.

    def get_fct_cam_to_gnomonic(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de la camera au plan gnomonic. **
        &#34;&#34;&#34;
        if &#34;fct_cam_to_gnomonic&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_gnomonic&#34;]

        u_f = self.get_expr_cam_to_uf(self.x_cam, self.y_cam)
        u_q = self.get_expr_uf_to_uq(*u_f)
        x_gnom, y_gnom = self.get_expr_uq_to_gnomonic(*u_q)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_gnomonic&#34;] = lambdify.Lambdify(
            args=[self.x_cam, self.y_cam, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
            expr=[x_gnom, y_gnom]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_gnomonic&#34;]

    def get_fct_gnomonic_to_cam(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de l&#39;espace gnomonic a celui de la camera. **
        &#34;&#34;&#34;
        if &#34;fct_gnomonic_to_cam&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_cam&#34;]

        u_q = self.get_expr_gnomonic_to_uq(self.x_gnom, self.y_gnom)
        u_f = self.get_expr_uq_to_uf(*u_q)
        x_c, y_c = self.get_expr_uf_to_cam(*u_f)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_cam&#34;] = lambdify.Lambdify(
            args=[self.x_gnom, self.y_gnom, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
            expr=[x_c, y_c]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_cam&#34;]

    def get_fct_thetachi_to_cam(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de theta chi a la camera. **
        &#34;&#34;&#34;
        if &#34;fct_thetachi_to_cam&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_cam&#34;]

        u_f = self.get_expr_thetachi_to_uf(self.theta, self.chi)
        x_c, y_c = self.get_expr_uf_to_cam(*u_f)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_cam&#34;] = lambdify.Lambdify(
            args=[self.theta, self.chi, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
            expr=[x_c, y_c]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_cam&#34;]

    def get_fct_cam_to_thetachi(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de la camera a la representation theta chi. **
        &#34;&#34;&#34;
        if &#34;fct_cam_to_thetachi&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_thetachi&#34;]

        u_f = self.get_expr_cam_to_uf(self.x_cam, self.y_cam)
        theta, chi = self.get_expr_uf_to_thetachi(*u_f)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_thetachi&#34;] = lambdify.Lambdify(
            args=[self.x_cam, self.y_cam, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
            expr=[theta, chi]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_thetachi&#34;]

    def get_fct_thetachi_to_gnomonic(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer de theta chi au plan gnomonic. **
        &#34;&#34;&#34;
        if &#34;fct_thetachi_to_gnomonic&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_gnomonic&#34;]

        u_f = self.get_expr_thetachi_to_uf(self.theta, self.chi)
        u_q = self.get_expr_uf_to_uq(*u_f)
        x_gnom, y_gnom = self.get_expr_uq_to_gnomonic(*u_q)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_gnomonic&#34;] = lambdify.Lambdify(
            args=[self.theta, self.chi],
            expr=[x_gnom, y_gnom]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_gnomonic&#34;]

    def get_fct_gnomonic_to_thetachi(self):
        &#34;&#34;&#34;
        ** Equation permetant de passer du plan gnomonic a la representation theta chi. **
        &#34;&#34;&#34;
        if &#34;fct_gnomonic_to_thetachi&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_thetachi&#34;]

        u_q = self.get_expr_gnomonic_to_uq(self.x_gnom, self.y_gnom)
        u_f = self.get_expr_uq_to_uf(*u_q)
        theta, chi = self.get_expr_uf_to_thetachi(*u_f)

        globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_thetachi&#34;] = lambdify.Lambdify(
            args=[self.x_gnom, self.y_gnom],
            expr=[theta, chi]) # On l&#39;enregistre une bonne fois pour toutes.
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_thetachi&#34;]

    def get_fct_dist_line(self):
        &#34;&#34;&#34;
        ** Equation de projection de points sur une droite. **
        &#34;&#34;&#34;
        if &#34;fct_dist_line&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_dist_line&#34;]

        # Creation de la droite.
        theta, dist, x, y = sympy.symbols(&#34;theta alpha x y&#34;, real=True)
        p = sympy.Point(dist*sympy.cos(theta), dist*sympy.sin(theta)) # Point appartenant a la droite.
        op = sympy.Line(sympy.Point(0, 0), p) # Droite normale a la droite principale.
        line = op.perpendicular_line(p) # C&#39;est la droite principale.

        # Projection des points.
        distance = line.distance(sympy.Point(x, y)) # La distance entre la droite et un point.

        # Optimisation.
        distance = sympy.trigsimp(distance) # Permet un gain de 2.90

        # Vectorisation de l&#39;expression.
        globals()[&#34;compiled_expressions&#34;][&#34;fct_dist_line&#34;] = lambdify.Lambdify([theta, dist, x, y], distance)
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_dist_line&#34;]

    def get_fct_hough(self):
        &#34;&#34;&#34;
        ** Equation pour la transformee de hough. **
        &#34;&#34;&#34;
        if &#34;fct_hough&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_hough&#34;]

        xa, ya, xb, yb = sympy.symbols(&#34;x_a y_a x_b y_b&#34;, real=True)
        u = sympy.Matrix([xa-xb, ya-yb]).normalized()
        x = sympy.Matrix([1, 0])

        # Calcul de la distance entre la droite et l&#39;origine.
        d1 = sympy.Line(sympy.Point(xa, ya), sympy.Point(xb, yb)) # C&#39;est la droite passant par les 2 points.
        dist = d1.distance(sympy.Point(0, 0)) # La distance separant l&#39;origine de la droite.

        # Calcul de l&#39;angle entre l&#39;axe horizontal et la droite.
        p = d1.projection(sympy.Point(0, 0)) # Le point ou la distance entre ce point de la droite et l&#39;origine est minimale.
        n = p / sympy.sqrt(p.x**2 + p.y**2) # On normalise le point.
        theta_abs = sympy.acos(n.x) # La valeur absolue de theta.
        theta_sign = sympy.sign(n.y) # Si il est negatif c&#39;est que theta &lt; 0, si il est positif alors theta &gt; 0
        theta = theta_abs * theta_sign # Compris entre -pi et +pi
        # theta = sympy.simplify(theta)

        # Optimisation.
        theta = theta # Permet un gain de 1.00
        dist = sympy.trigsimp(sympy.cancel(dist)) # Permet un gain de 1.40

        # Vectorisation des expressions.
        globals()[&#34;compiled_expressions&#34;][&#34;fct_hough&#34;] = lambdify.Lambdify([xa, ya, xb, yb], [theta, dist])
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_hough&#34;]

    def get_fct_inter_line(self):
        &#34;&#34;&#34;
        ** Equation d&#39;intersection entre 2 droites. **
        &#34;&#34;&#34;
        if &#34;fct_inter_line&#34; in globals()[&#34;compiled_expressions&#34;]:
            return globals()[&#34;compiled_expressions&#34;][&#34;fct_inter_line&#34;]

        # Creation des 2 droites.
        theta_1, dist_1, theta_2, dist_2 = sympy.symbols(&#34;theta_1, dist_1, theta_2, dist_2&#34;, real=True)
        p1 = sympy.Point(dist_1*sympy.cos(theta_1), dist_1*sympy.sin(theta_1)) # Point appartenant a la premiere droite.
        p2 = sympy.Point(dist_2*sympy.cos(theta_2), dist_2*sympy.sin(theta_2)) # Point appartenant a la seconde droite.
        op1 = sympy.Line(sympy.Point(0, 0), p1) # Droite normale a la premiere droite.
        op2 = sympy.Line(sympy.Point(0, 0), p2) # Droite normale a la deuxieme droite.
        line1 = op1.perpendicular_line(p1) # La premiere droite.
        line2 = op2.perpendicular_line(p2) # La seconde droite.

        # Calcul des coordonnes du point d&#39;intersection.
        point = line1.intersection(line2)[0]
        inter_x = point.x
        inter_y = point.y

        # Optimisation.
        # Il n&#39;y en a pas car les expressions sont deja tres simples.

        # Vectorisation des expressions.
        globals()[&#34;compiled_expressions&#34;][&#34;fct_inter_line&#34;] = lambdify.Lambdify(
            [theta_1, dist_1, theta_2, dist_2], [inter_x, inter_y])
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_inter_line&#34;]

    def _hash(self):
        &#34;&#34;&#34;
        ** Retourne le hash de ce code. **
        &#34;&#34;&#34;
        return hashlib.md5(
            inspect.getsource(Compilator).encode(encoding=&#34;utf-8&#34;)
          + inspect.getsource(Equations).encode(encoding=&#34;utf-8&#34;)
          + inspect.getsource(lambdify).encode(encoding=&#34;utf-8&#34;)
            ).hexdigest()

    def load(self):
        &#34;&#34;&#34;
        ** Charge si il existe, le fichier contenant les expressions. **

        Deverse les expressions dans le dictionaire: ``globals()[&#34;compiled_expressions&#34;]``.
        &#34;&#34;&#34;
        dirname = os.path.dirname(os.path.abspath(laue.__file__))
        file = os.path.join(dirname, &#34;data&#34;, &#34;geometry.data&#34;)
        
        if os.path.exists(file):
            with open(file, &#34;rb&#34;) as f:
                try:
                    content = cloudpickle.load(f)
                except ValueError: # Si c&#39;est pas le bon protocol
                    content = {&#34;hash&#34;: None}
                else:
                    content[&#34;expr&#34;] = {name: lambdify.Lambdify.loads(data) for name, data in content[&#34;expr&#34;].items()}
            if content[&#34;hash&#34;] == self._hash(): # Si les donnees sont a jour.
                globals()[&#34;compiled_expressions&#34;] = {**globals()[&#34;compiled_expressions&#34;], **content[&#34;expr&#34;]}
        return globals()[&#34;compiled_expressions&#34;]

    def save(self):
        &#34;&#34;&#34;
        ** Enregistre un fichier contenant les expressions. **

        Enregistre seulement ce qui est present dans ``globals()[&#34;compiled_expressions&#34;]``.
        N&#39;ecrase pas l&#39;ancien contenu.
        &#34;&#34;&#34;
        dirname = os.path.dirname(os.path.abspath(laue.__file__))
        file = os.path.join(dirname, &#34;data&#34;, &#34;geometry.data&#34;)
        self.load() # Recuperation du contenu du fichier.
        content = {
            &#34;hash&#34;: self._hash(),
            &#34;expr&#34;: {name: l.dumps()
                for name, l in globals()[&#34;compiled_expressions&#34;].items()
                }
            }
        with open(file, &#34;wb&#34;) as f:
            cloudpickle.dump(content, f)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="laue.core.geometry.symbolic.Equations" href="#laue.core.geometry.symbolic.Equations">Equations</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="laue.core.geometry.transformer.Transformer" href="transformer.html#laue.core.geometry.transformer.Transformer">Transformer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laue.core.geometry.symbolic.Compilator.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Precalcul toutes les equations completes. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self):
    &#34;&#34;&#34;
    ** Precalcul toutes les equations completes. **
    &#34;&#34;&#34;
    names = [
        &#34;cam_to_gnomonic&#34;,
        &#34;gnomonic_to_cam&#34;,
        &#34;cam_to_thetachi&#34;,
        &#34;thetachi_to_cam&#34;,
        &#34;thetachi_to_gnomonic&#34;,
        &#34;gnomonic_to_thetachi&#34;,
        &#34;dist_line&#34;,
        &#34;hough&#34;,
        &#34;inter_line&#34;]
    names = [n for n in names if n not in globals()[&#34;compiled_expressions&#34;]]

    for name in names:
        getattr(self, f&#34;get_fct_{name}&#34;)()

    self.save() # On enregistre les grandes equations.</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_gnomonic"><code class="name flex">
<span>def <span class="ident">get_fct_cam_to_gnomonic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permetant de passer de la camera au plan gnomonic. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fct_cam_to_gnomonic(self):
    &#34;&#34;&#34;
    ** Equation permetant de passer de la camera au plan gnomonic. **
    &#34;&#34;&#34;
    if &#34;fct_cam_to_gnomonic&#34; in globals()[&#34;compiled_expressions&#34;]:
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_gnomonic&#34;]

    u_f = self.get_expr_cam_to_uf(self.x_cam, self.y_cam)
    u_q = self.get_expr_uf_to_uq(*u_f)
    x_gnom, y_gnom = self.get_expr_uq_to_gnomonic(*u_q)

    globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_gnomonic&#34;] = lambdify.Lambdify(
        args=[self.x_cam, self.y_cam, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
        expr=[x_gnom, y_gnom]) # On l&#39;enregistre une bonne fois pour toutes.
    return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_gnomonic&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_thetachi"><code class="name flex">
<span>def <span class="ident">get_fct_cam_to_thetachi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permetant de passer de la camera a la representation theta chi. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fct_cam_to_thetachi(self):
    &#34;&#34;&#34;
    ** Equation permetant de passer de la camera a la representation theta chi. **
    &#34;&#34;&#34;
    if &#34;fct_cam_to_thetachi&#34; in globals()[&#34;compiled_expressions&#34;]:
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_thetachi&#34;]

    u_f = self.get_expr_cam_to_uf(self.x_cam, self.y_cam)
    theta, chi = self.get_expr_uf_to_thetachi(*u_f)

    globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_thetachi&#34;] = lambdify.Lambdify(
        args=[self.x_cam, self.y_cam, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
        expr=[theta, chi]) # On l&#39;enregistre une bonne fois pour toutes.
    return globals()[&#34;compiled_expressions&#34;][&#34;fct_cam_to_thetachi&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.get_fct_dist_line"><code class="name flex">
<span>def <span class="ident">get_fct_dist_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation de projection de points sur une droite. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fct_dist_line(self):
    &#34;&#34;&#34;
    ** Equation de projection de points sur une droite. **
    &#34;&#34;&#34;
    if &#34;fct_dist_line&#34; in globals()[&#34;compiled_expressions&#34;]:
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_dist_line&#34;]

    # Creation de la droite.
    theta, dist, x, y = sympy.symbols(&#34;theta alpha x y&#34;, real=True)
    p = sympy.Point(dist*sympy.cos(theta), dist*sympy.sin(theta)) # Point appartenant a la droite.
    op = sympy.Line(sympy.Point(0, 0), p) # Droite normale a la droite principale.
    line = op.perpendicular_line(p) # C&#39;est la droite principale.

    # Projection des points.
    distance = line.distance(sympy.Point(x, y)) # La distance entre la droite et un point.

    # Optimisation.
    distance = sympy.trigsimp(distance) # Permet un gain de 2.90

    # Vectorisation de l&#39;expression.
    globals()[&#34;compiled_expressions&#34;][&#34;fct_dist_line&#34;] = lambdify.Lambdify([theta, dist, x, y], distance)
    return globals()[&#34;compiled_expressions&#34;][&#34;fct_dist_line&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_cam"><code class="name flex">
<span>def <span class="ident">get_fct_gnomonic_to_cam</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permetant de passer de l'espace gnomonic a celui de la camera. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fct_gnomonic_to_cam(self):
    &#34;&#34;&#34;
    ** Equation permetant de passer de l&#39;espace gnomonic a celui de la camera. **
    &#34;&#34;&#34;
    if &#34;fct_gnomonic_to_cam&#34; in globals()[&#34;compiled_expressions&#34;]:
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_cam&#34;]

    u_q = self.get_expr_gnomonic_to_uq(self.x_gnom, self.y_gnom)
    u_f = self.get_expr_uq_to_uf(*u_q)
    x_c, y_c = self.get_expr_uf_to_cam(*u_f)

    globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_cam&#34;] = lambdify.Lambdify(
        args=[self.x_gnom, self.y_gnom, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
        expr=[x_c, y_c]) # On l&#39;enregistre une bonne fois pour toutes.
    return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_cam&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_thetachi"><code class="name flex">
<span>def <span class="ident">get_fct_gnomonic_to_thetachi</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permetant de passer du plan gnomonic a la representation theta chi. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fct_gnomonic_to_thetachi(self):
    &#34;&#34;&#34;
    ** Equation permetant de passer du plan gnomonic a la representation theta chi. **
    &#34;&#34;&#34;
    if &#34;fct_gnomonic_to_thetachi&#34; in globals()[&#34;compiled_expressions&#34;]:
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_thetachi&#34;]

    u_q = self.get_expr_gnomonic_to_uq(self.x_gnom, self.y_gnom)
    u_f = self.get_expr_uq_to_uf(*u_q)
    theta, chi = self.get_expr_uf_to_thetachi(*u_f)

    globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_thetachi&#34;] = lambdify.Lambdify(
        args=[self.x_gnom, self.y_gnom],
        expr=[theta, chi]) # On l&#39;enregistre une bonne fois pour toutes.
    return globals()[&#34;compiled_expressions&#34;][&#34;fct_gnomonic_to_thetachi&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.get_fct_hough"><code class="name flex">
<span>def <span class="ident">get_fct_hough</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation pour la transformee de hough. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fct_hough(self):
    &#34;&#34;&#34;
    ** Equation pour la transformee de hough. **
    &#34;&#34;&#34;
    if &#34;fct_hough&#34; in globals()[&#34;compiled_expressions&#34;]:
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_hough&#34;]

    xa, ya, xb, yb = sympy.symbols(&#34;x_a y_a x_b y_b&#34;, real=True)
    u = sympy.Matrix([xa-xb, ya-yb]).normalized()
    x = sympy.Matrix([1, 0])

    # Calcul de la distance entre la droite et l&#39;origine.
    d1 = sympy.Line(sympy.Point(xa, ya), sympy.Point(xb, yb)) # C&#39;est la droite passant par les 2 points.
    dist = d1.distance(sympy.Point(0, 0)) # La distance separant l&#39;origine de la droite.

    # Calcul de l&#39;angle entre l&#39;axe horizontal et la droite.
    p = d1.projection(sympy.Point(0, 0)) # Le point ou la distance entre ce point de la droite et l&#39;origine est minimale.
    n = p / sympy.sqrt(p.x**2 + p.y**2) # On normalise le point.
    theta_abs = sympy.acos(n.x) # La valeur absolue de theta.
    theta_sign = sympy.sign(n.y) # Si il est negatif c&#39;est que theta &lt; 0, si il est positif alors theta &gt; 0
    theta = theta_abs * theta_sign # Compris entre -pi et +pi
    # theta = sympy.simplify(theta)

    # Optimisation.
    theta = theta # Permet un gain de 1.00
    dist = sympy.trigsimp(sympy.cancel(dist)) # Permet un gain de 1.40

    # Vectorisation des expressions.
    globals()[&#34;compiled_expressions&#34;][&#34;fct_hough&#34;] = lambdify.Lambdify([xa, ya, xb, yb], [theta, dist])
    return globals()[&#34;compiled_expressions&#34;][&#34;fct_hough&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.get_fct_inter_line"><code class="name flex">
<span>def <span class="ident">get_fct_inter_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation d'intersection entre 2 droites. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fct_inter_line(self):
    &#34;&#34;&#34;
    ** Equation d&#39;intersection entre 2 droites. **
    &#34;&#34;&#34;
    if &#34;fct_inter_line&#34; in globals()[&#34;compiled_expressions&#34;]:
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_inter_line&#34;]

    # Creation des 2 droites.
    theta_1, dist_1, theta_2, dist_2 = sympy.symbols(&#34;theta_1, dist_1, theta_2, dist_2&#34;, real=True)
    p1 = sympy.Point(dist_1*sympy.cos(theta_1), dist_1*sympy.sin(theta_1)) # Point appartenant a la premiere droite.
    p2 = sympy.Point(dist_2*sympy.cos(theta_2), dist_2*sympy.sin(theta_2)) # Point appartenant a la seconde droite.
    op1 = sympy.Line(sympy.Point(0, 0), p1) # Droite normale a la premiere droite.
    op2 = sympy.Line(sympy.Point(0, 0), p2) # Droite normale a la deuxieme droite.
    line1 = op1.perpendicular_line(p1) # La premiere droite.
    line2 = op2.perpendicular_line(p2) # La seconde droite.

    # Calcul des coordonnes du point d&#39;intersection.
    point = line1.intersection(line2)[0]
    inter_x = point.x
    inter_y = point.y

    # Optimisation.
    # Il n&#39;y en a pas car les expressions sont deja tres simples.

    # Vectorisation des expressions.
    globals()[&#34;compiled_expressions&#34;][&#34;fct_inter_line&#34;] = lambdify.Lambdify(
        [theta_1, dist_1, theta_2, dist_2], [inter_x, inter_y])
    return globals()[&#34;compiled_expressions&#34;][&#34;fct_inter_line&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_cam"><code class="name flex">
<span>def <span class="ident">get_fct_thetachi_to_cam</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permetant de passer de theta chi a la camera. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fct_thetachi_to_cam(self):
    &#34;&#34;&#34;
    ** Equation permetant de passer de theta chi a la camera. **
    &#34;&#34;&#34;
    if &#34;fct_thetachi_to_cam&#34; in globals()[&#34;compiled_expressions&#34;]:
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_cam&#34;]

    u_f = self.get_expr_thetachi_to_uf(self.theta, self.chi)
    x_c, y_c = self.get_expr_uf_to_cam(*u_f)

    globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_cam&#34;] = lambdify.Lambdify(
        args=[self.theta, self.chi, self.dd, self.xcen, self.ycen, self.xbet, self.xgam, self.pixelsize],
        expr=[x_c, y_c]) # On l&#39;enregistre une bonne fois pour toutes.
    return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_cam&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_gnomonic"><code class="name flex">
<span>def <span class="ident">get_fct_thetachi_to_gnomonic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permetant de passer de theta chi au plan gnomonic. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fct_thetachi_to_gnomonic(self):
    &#34;&#34;&#34;
    ** Equation permetant de passer de theta chi au plan gnomonic. **
    &#34;&#34;&#34;
    if &#34;fct_thetachi_to_gnomonic&#34; in globals()[&#34;compiled_expressions&#34;]:
        return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_gnomonic&#34;]

    u_f = self.get_expr_thetachi_to_uf(self.theta, self.chi)
    u_q = self.get_expr_uf_to_uq(*u_f)
    x_gnom, y_gnom = self.get_expr_uq_to_gnomonic(*u_q)

    globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_gnomonic&#34;] = lambdify.Lambdify(
        args=[self.theta, self.chi],
        expr=[x_gnom, y_gnom]) # On l&#39;enregistre une bonne fois pour toutes.
    return globals()[&#34;compiled_expressions&#34;][&#34;fct_thetachi_to_gnomonic&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Charge si il existe, le fichier contenant les expressions. </strong></p>
<p>Deverse les expressions dans le dictionaire: <code>globals()["compiled_expressions"]</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self):
    &#34;&#34;&#34;
    ** Charge si il existe, le fichier contenant les expressions. **

    Deverse les expressions dans le dictionaire: ``globals()[&#34;compiled_expressions&#34;]``.
    &#34;&#34;&#34;
    dirname = os.path.dirname(os.path.abspath(laue.__file__))
    file = os.path.join(dirname, &#34;data&#34;, &#34;geometry.data&#34;)
    
    if os.path.exists(file):
        with open(file, &#34;rb&#34;) as f:
            try:
                content = cloudpickle.load(f)
            except ValueError: # Si c&#39;est pas le bon protocol
                content = {&#34;hash&#34;: None}
            else:
                content[&#34;expr&#34;] = {name: lambdify.Lambdify.loads(data) for name, data in content[&#34;expr&#34;].items()}
        if content[&#34;hash&#34;] == self._hash(): # Si les donnees sont a jour.
            globals()[&#34;compiled_expressions&#34;] = {**globals()[&#34;compiled_expressions&#34;], **content[&#34;expr&#34;]}
    return globals()[&#34;compiled_expressions&#34;]</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Compilator.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Enregistre un fichier contenant les expressions. </strong></p>
<p>Enregistre seulement ce qui est present dans <code>globals()["compiled_expressions"]</code>.
N'ecrase pas l'ancien contenu.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
    &#34;&#34;&#34;
    ** Enregistre un fichier contenant les expressions. **

    Enregistre seulement ce qui est present dans ``globals()[&#34;compiled_expressions&#34;]``.
    N&#39;ecrase pas l&#39;ancien contenu.
    &#34;&#34;&#34;
    dirname = os.path.dirname(os.path.abspath(laue.__file__))
    file = os.path.join(dirname, &#34;data&#34;, &#34;geometry.data&#34;)
    self.load() # Recuperation du contenu du fichier.
    content = {
        &#34;hash&#34;: self._hash(),
        &#34;expr&#34;: {name: l.dumps()
            for name, l in globals()[&#34;compiled_expressions&#34;].items()
            }
        }
    with open(file, &#34;wb&#34;) as f:
        cloudpickle.dump(content, f)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="laue.core.geometry.symbolic.Equations" href="#laue.core.geometry.symbolic.Equations">Equations</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_cam_to_uf" href="#laue.core.geometry.symbolic.Equations.get_expr_cam_to_uf">get_expr_cam_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_gnomonic_to_uq" href="#laue.core.geometry.symbolic.Equations.get_expr_gnomonic_to_uq">get_expr_gnomonic_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_thetachi_to_uf" href="#laue.core.geometry.symbolic.Equations.get_expr_thetachi_to_uf">get_expr_thetachi_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uf_to_cam" href="#laue.core.geometry.symbolic.Equations.get_expr_uf_to_cam">get_expr_uf_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uf_to_thetachi" href="#laue.core.geometry.symbolic.Equations.get_expr_uf_to_thetachi">get_expr_uf_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uf_to_uq" href="#laue.core.geometry.symbolic.Equations.get_expr_uf_to_uq">get_expr_uf_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uq_to_gnomonic" href="#laue.core.geometry.symbolic.Equations.get_expr_uq_to_gnomonic">get_expr_uq_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uq_to_uf" href="#laue.core.geometry.symbolic.Equations.get_expr_uq_to_uf">get_expr_uq_to_uf</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="laue.core.geometry.symbolic.Equations"><code class="flex name class">
<span>class <span class="ident">Equations</span></span>
</code></dt>
<dd>
<div class="desc"><p>Exprime des petites transformations elementaires.</p>
<p>C'est une interface de la classe <code><a title="laue.core.geometry.transformer.Transformer" href="transformer.html#laue.core.geometry.transformer.Transformer">Transformer</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Equations:
    &#34;&#34;&#34;
    Exprime des petites transformations elementaires.

    C&#39;est une interface de la classe ``laue.core.geometry.transformer.Transformer``.
    &#34;&#34;&#34;
    def __init__(self):
        # Les constantes.
        self.dd = sympy.Symbol(&#34;dd&#34;, real=True, positive=True) # Distance entre l&#39;origine et le plan de la camera en mm.
        self.xcen, self.ycen = sympy.symbols(&#34;xcen ycen&#34;, real=True) # Position du point d&#39;incidence normale en pxl par rapport au repere de la camera.
        self.xbet, self.xgam = sympy.symbols(&#34;beta gamma&#34;, real=True) # Rotation autour x camera, Rotation autour axe incidence normale.
        self.pixelsize = sympy.Symbol(&#34;pixelsize&#34;, real=True, positive=True) # Taille des pixels en mm/pxl.

        # Les variables.
        self.x_cam, self.y_cam = sympy.symbols(&#34;x_cam y_cam&#34;, real=True, positive=True) # Position du pxl dans le repere du plan de la camera.
        self.x_gnom, self.y_gnom = sympy.symbols(&#34;x_gnom y_gnom&#34;, real=True) # Position des points dans le plan gnomonic.
        self.theta, self.chi = sympy.symbols(&#34;theta chi&#34;, real=True) # Les angles decrivant le rayon reflechit.

        # Expression des elements du model.
        self.rx = sympy.Matrix([1, 0, 0])
        self.ry = sympy.Matrix([0, 1, 0])
        self.rz = sympy.Matrix([0, 0, 1])

        self.u_i = self.rx # Le rayon de lumiere incident norme parallele a l&#39;axe X dans le repere du cristal.

        self.rot_camera = sympy.rot_axis2(-self.xbet) @ sympy.rot_axis3(self.xgam) # Rotation globale de la camera par rapport au cristal.
        self.ci = self.rot_camera @ -self.ry # Vecteur Xcamera.
        self.cj = self.rot_camera @ self.rx # Vecteur Ycamera.
        self.ck = self.rot_camera @ self.rz # Vecteur Zcamera normal au plan de la camera.

        self.rot_gnom = sympy.rot_axis2(-sympy.pi/4) # Rotation du repere de plan gnomonic par rapport au repere du cristal.
        self.gi = self.rot_gnom @ self.rz # Vecteur Xgnomonic.
        self.gj = self.rot_gnom @ self.ry # Vecteur Ygnomonic.
        self.gk = self.rot_gnom @ -self.rx # Vecteur Zgnomonic normal au plan gnomonic.

    def get_expr_cam_to_uf(self, x_cam, y_cam):
        &#34;&#34;&#34;
        ** Equation permetant de passer de la camera a uf. **

        Notes
        -----
        Le vecteur de sortie (uf) n&#39;est pas normalise.

        Parameters
        ----------
        x_cam
            La position x de la camera.
        y_cam
            La position y de la camera.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uf dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_cam, y_cam = symbols(&#34;x y&#34;)
        &gt;&gt;&gt; transformer.get_expr_cam_to_uf(x_cam, y_cam)
        Matrix([
        [dd*sin(beta) - pixelsize*((x - xcen)*sin(gamma)*cos(beta) - (y - ycen)*cos(beta)*cos(gamma))],
        [                                  -pixelsize*((x - xcen)*cos(gamma) + (y - ycen)*sin(gamma))],
        [dd*cos(beta) + pixelsize*((x - xcen)*sin(beta)*sin(gamma) - (y - ycen)*sin(beta)*cos(gamma))]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        x_cam_atomic, y_cam_atomic = sympy.symbols(&#34;x_cam y_cam&#34;, real=True)
        o_op = self.dd * self.ck # Vecteur OO&#39;.
        op_p = self.pixelsize * ((x_cam_atomic-self.xcen)*self.ci + (y_cam_atomic-self.ycen)*self.cj) # Vecteur O&#39;P
        o_p = o_op + op_p # Relation de Chasles.
        o_p = sympy.signsimp(o_p)
        return o_p.subs({x_cam_atomic: x_cam, y_cam_atomic: y_cam})

    def get_expr_uf_to_cam(self, uf_x, uf_y, uf_z):
        &#34;&#34;&#34;
        ** Equation permettant de passer de uf a la camera. **

        Parameters
        ----------
        uf_x, uf_y, uf_z
            Les 3 coordonnees du vecteur uf exprimees dans le repere principale.

        Returns
        -------
        x_camera : sympy.Basic
            Expression sympy de la position de la tache dans le repere
            de la camera. (selon l&#39;axe x ou Ci)
        y_camera : sympy.Basic
            Comme ``x_camera`` selon l&#39;axe y ou Cj.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&#34;uf_x, uf_y, uf_z&#34;)
        &gt;&gt;&gt; x_cam, y_cam = transformer.get_expr_uf_to_cam(uf_x, uf_y, uf_z)
        &gt;&gt;&gt; x_cam
        (-dd*uf_x*sin(gamma)*cos(beta) - dd*uf_y*cos(gamma) + dd*uf_z*sin(beta)*sin(gamma) + pixelsize*uf_x*xcen*sin(beta) + pixelsize*uf_z*xcen*cos(beta))/(pixelsize*(uf_x*sin(beta) + uf_z*cos(beta)))
        &gt;&gt;&gt; y_cam
        (dd*uf_x*cos(beta)*cos(gamma) - dd*uf_y*sin(gamma) - dd*uf_z*sin(beta)*cos(gamma) + pixelsize*uf_x*ycen*sin(beta) + pixelsize*uf_z*ycen*cos(beta))/(pixelsize*(uf_x*sin(beta) + uf_z*cos(beta)))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        uf_x_atomic, uf_y_atomic, uf_z_atomic = sympy.symbols(&#34;uf_x uf_y uf_z&#34;, real=True)
        u_f = sympy.Matrix([uf_x_atomic, uf_y_atomic, uf_z_atomic])

        # Expression du vecteur O&#39;&#39;P.
        opp_op = self.pixelsize * (self.xcen*self.ci + self.ycen*self.cj) # Vecteur O&#39;&#39;O&#39;.
        o_op = self.dd * self.ck # Vecteur OO&#39;.
        op_o = -o_op # Vecteur O&#39;O.
        camera_plane = sympy.Plane(o_op, normal_vector=self.ck) # Plan de la camera.
        refl_ray = sympy.Line([0, 0, 0], u_f) # Rayon reflechi.
        o_p = sympy.Matrix(camera_plane.intersection(refl_ray).pop())
        opp_p = opp_op + op_o + o_p # Relation de Chasles.

        # Projection dans le plan de la camera pour remonter a x_c, y_c
        x_cam = opp_p.dot(self.ci) / self.pixelsize # Coordonnees en pxl axe x de la camera.
        y_cam = opp_p.dot(self.cj) / self.pixelsize # Coordonnees en pxl axe y de la camera.
        x_cam, y_cam = sympy.trigsimp(x_cam), sympy.trigsimp(y_cam) # Longueur reduite par 2.2 .

        return (x_cam.subs({uf_x_atomic: uf_x, uf_y_atomic: uf_y, uf_z_atomic: uf_z}),
                y_cam.subs({uf_x_atomic: uf_x, uf_y_atomic: uf_y, uf_z_atomic: uf_z}))

    def get_expr_uf_to_uq(self, uf_x, uf_y, uf_z):
        &#34;&#34;&#34;
        ** Equation permettant de passer de uf a uq. **

        Parameters
        ----------
        uf_x, uf_y, uf_z
            Les 3 coordonnees du vecteur uf exprimees dans le repere principal.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uq dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&#34;uf_x, uf_y, uf_z&#34;)
        &gt;&gt;&gt; transformer.get_expr_uf_to_uq(uf_x, uf_y, uf_z)
        Matrix([
        [uf_x - sqrt(uf_x**2 + uf_y**2 + uf_z**2)],
        [                                    uf_y],
        [                                    uf_z]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        uf_x_atomic, uf_y_atomic, uf_z_atomic = sympy.symbols(&#34;uf_x uf_y uf_z&#34;, real=True)
        u_f = sympy.Matrix([uf_x_atomic, uf_y_atomic, uf_z_atomic])
        u_q = u_f - self.u_i*u_f.norm() # Relation de reflexion.
        return u_q.subs({uf_x_atomic: uf_x, uf_y_atomic: uf_y, uf_z_atomic: uf_z})

    def get_expr_uq_to_uf(self, uq_x, uq_y, uq_z):
        &#34;&#34;&#34;
        ** Equation permettant de passer de uq a uf. **

        Parameters
        ----------
        uq_x, uq_y, uq_z
            Les 3 coordonnees du vecteur uq exprimees dans le repere principal.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uf dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uq_x, uq_y, uq_z = symbols(&#34;uq_x, uq_y, uq_z&#34;)
        &gt;&gt;&gt; transformer.get_expr_uq_to_uf(uq_x, uq_y, uq_z)
        Matrix([
        [-uq_x**2 + uq_y**2 + uq_z**2],
        [                -2*uq_x*uq_y],
        [                -2*uq_x*uq_z]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        uq_x_atomic, uq_y_atomic, uq_z_atomic = sympy.symbols(&#34;uq_x uq_y uq_z&#34;, real=True)
        u_q = sympy.Matrix([uq_x_atomic, uq_y_atomic, uq_z_atomic])
        u_f = self.u_i*u_q.norm()**2 - 2*u_q.dot(self.u_i)*u_q # Vecteur unitaire reflechi.
        return u_f.subs({uq_x_atomic: uq_x, uq_y_atomic: uq_y, uq_z_atomic: uq_z})

    def get_expr_uq_to_gnomonic(self, uq_x, uq_y, uq_z):
        &#34;&#34;&#34;
        ** Equation permettant de passer de uq a gnomonic. **

        Parameters
        ----------
        uq_x, uq_y, uq_z
            Les 3 coordonnees du vecteur uq exprimees dans le repere principal.

        Returns
        -------
        x_gnomonic : sympy.Basic
            Expression sympy de la position de la tache dans le repere
            du plan gnomonic. (selon l&#39;axe x ou Gi)
        y_gnomonic : sympy.Basic
            Comme ``x_gnomonic`` selon l&#39;axe y ou Gj.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uq_x, uq_y, uq_z = symbols(&#34;uq_x, uq_y, uq_z&#34;)
        &gt;&gt;&gt; x_gnom, y_gnom = transformer.get_expr_uq_to_gnomonic(uq_x, uq_y, uq_z)
        &gt;&gt;&gt; x_gnom
        -(uq_x + uq_z)/(uq_x - uq_z)
        &gt;&gt;&gt; y_gnom
        -sqrt(2)*uq_y/(uq_x - uq_z)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        uq_x_atomic, uq_y_atomic, uq_z_atomic = sympy.symbols(&#34;uq_x uq_y uq_z&#34;, real=True)
        u_q = sympy.Matrix([uq_x_atomic, uq_y_atomic, uq_z_atomic])
        o_oppp = 1*self.gk # Car sphere unitaire de rayon 1.

        gnom_plane = sympy.Plane(o_oppp, normal_vector=self.gk) # Plan gnomonic.
        normal_ray = sympy.Line([0, 0, 0], u_q) # Droite portee par la normal au plan christalin.
        o_pp = sympy.Matrix(gnom_plane.intersection(normal_ray).pop())
        oppp_pp = -o_oppp + o_pp

        # Projection dans le plan gnomonic pour remonter a x_g, y_g.
        x_gnom = oppp_pp.dot(self.gi) # Coordonnees en mm axe x du plan gnomonic.
        y_gnom = oppp_pp.dot(self.gj) # Coordonnees en mm axe y du plan gnomonic.

        x_gnom = sympy.signsimp(sympy.cancel(x_gnom))

        return (x_gnom.subs({uq_x_atomic: uq_x, uq_y_atomic: uq_y, uq_z_atomic: uq_z}),
                y_gnom.subs({uq_x_atomic: uq_x, uq_y_atomic: uq_y, uq_z_atomic: uq_z}))

    def get_expr_gnomonic_to_uq(self, x_gnom, y_gnom):
        &#34;&#34;&#34;
        ** Equation permettant de passer du plan gnomonique a uq. **

        Parameters
        ----------
        x_gnom
            La position x du plan gnomonic.
        y_gnom
            La position y du plan gnomonic.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uq dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_gnom, y_gnom = symbols(&#34;x y&#34;)
        &gt;&gt;&gt; transformer.get_expr_gnomonic_to_uq(x_gnom, y_gnom)
        Matrix([
        [sqrt(2)*x/2 - sqrt(2)/2],
        [                      y],
        [sqrt(2)*x/2 + sqrt(2)/2]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        x_gnom_atomic, y_gnom_atomic = sympy.symbols(&#34;x_gnom y_gnom&#34;, real=True)

        o_oppp = 1*self.gk # Vecteur OO&#39;&#39;&#39; == gk car le plan gnomonic est tangent a la shere unitaire.
        u_q = o_oppp + (x_gnom_atomic*self.gi + y_gnom_atomic*self.gj) # Relation de chasle.

        return u_q.subs({x_gnom_atomic: x_gnom, y_gnom_atomic: y_gnom})

    def get_expr_uf_to_thetachi(self, uf_x, uf_y, uf_z):
        &#34;&#34;&#34;
        ** Equation permetant de passer de uf a thetachi. **

        Parameters
        ----------
        uf_x, uf_y, uf_z
            Les 3 coordonnees du vecteur uf exprimees dans le repere principal.

        Returns
        -------
        theta : sympy.Basic
            Angle de rotation du plan christalin autour de -x.
        chi : sympy.Basic
            La moitier de l&#39;angle de rotation du plan christalin autour de -y.

        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&#34;uf_x, uf_y, uf_z&#34;, real=True)
        &gt;&gt;&gt; theta, chi = transformer.get_expr_uf_to_thetachi(uf_x, uf_y, uf_z)
        &gt;&gt;&gt; theta
        acos(uf_x/sqrt(uf_x**2 + uf_y**2 + uf_z**2))/2
        &gt;&gt;&gt; chi
        asin(uf_y/sqrt(uf_y**2 + uf_z**2))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def select(theta, chi):
            &#34;&#34;&#34;
            Cherche si theta &gt; 0 et -pi/2 &lt; chi &lt; pi/2
            &#34;&#34;&#34;
            func = sympy.lambdify([x, y, z], [theta, chi], modules=&#34;numpy&#34;)
            theta_vals, chi_vals = func(*np.meshgrid([-.5, .5], [-.5, .5], [.5]))
            if (theta_vals &lt; 0).any() or (chi_vals &lt; -np.pi/2).any() or (chi_vals &gt; np.pi/2).any():
                return False
            return True

        theta_atomic, chi_atomic = sympy.symbols(&#34;theta chi&#34;, real=True)
        x, y, z = sympy.symbols(&#34;x, y, z&#34;, real=True)
        u_f = sympy.Matrix([x, y, z])
        
        theta, chi = [
            (sol[theta_atomic], sol[chi_atomic])
            for sol in
            sympy.solve(
                self.get_expr_thetachi_to_uf(theta_atomic, chi_atomic)-u_f,
                [theta_atomic, chi_atomic],
                dict=True)
            if select(sol[theta_atomic], sol[chi_atomic])
            ].pop()

        uf_x, uf_y, uf_z = sympy.Matrix([uf_x, uf_y, uf_z]).normalized()

        return (theta.subs({x: uf_x, y: uf_y, z: uf_z}),
                chi.subs({x: uf_x, y: uf_y, z: uf_z}).simplify())

    def get_expr_thetachi_to_uf(self, theta, chi):
        &#34;&#34;&#34;
        ** Equation permetant de passer de thetachi a uf. **

        Parameters
        ----------
        theta
            Angle de rotation du plan christalin autour de -x.
        chi
            La moitier de l&#39;angle de rotation du plan christalin autour de -y.

        Returns
        -------
        sympy.Matrix
            La matrice sympy de taille 3 representant
            le vecteur uf dans le repere principal.

        Examples
        --------
        &gt;&gt;&gt; from sympy import symbols
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; theta, chi = symbols(&#34;theta chi&#34;)
        &gt;&gt;&gt; transformer.get_expr_thetachi_to_uf(theta, chi)
        Matrix([
        [         cos(2*theta)],
        [sin(chi)*sin(2*theta)],
        [sin(2*theta)*cos(chi)]])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        theta_atomic, chi_atomic = sympy.symbols(&#34;theta chi&#34;, real=True)

        # Expresion du rayon reflechit en fonction des angles.
        rot_refl = sympy.rot_axis1(chi_atomic) @ sympy.rot_axis2(2*theta_atomic)
        u_f = rot_refl @ self.u_i

        return u_f.subs({theta_atomic: theta, chi_atomic: chi})</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="laue.core.geometry.symbolic.Compilator" href="#laue.core.geometry.symbolic.Compilator">Compilator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laue.core.geometry.symbolic.Equations.get_expr_cam_to_uf"><code class="name flex">
<span>def <span class="ident">get_expr_cam_to_uf</span></span>(<span>self, x_cam, y_cam)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permetant de passer de la camera a uf. </strong></p>
<h2 id="notes">Notes</h2>
<p>Le vecteur de sortie (uf) n'est pas normalise.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_cam</code></strong></dt>
<dd>La position x de la camera.</dd>
<dt><strong><code>y_cam</code></strong></dt>
<dd>La position y de la camera.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>La matrice sympy de taille 3 representant
le vecteur uf dans le repere principal.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; x_cam, y_cam = symbols(&quot;x y&quot;)
&gt;&gt;&gt; transformer.get_expr_cam_to_uf(x_cam, y_cam)
Matrix([
[dd*sin(beta) - pixelsize*((x - xcen)*sin(gamma)*cos(beta) - (y - ycen)*cos(beta)*cos(gamma))],
[                                  -pixelsize*((x - xcen)*cos(gamma) + (y - ycen)*sin(gamma))],
[dd*cos(beta) + pixelsize*((x - xcen)*sin(beta)*sin(gamma) - (y - ycen)*sin(beta)*cos(gamma))]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expr_cam_to_uf(self, x_cam, y_cam):
    &#34;&#34;&#34;
    ** Equation permetant de passer de la camera a uf. **

    Notes
    -----
    Le vecteur de sortie (uf) n&#39;est pas normalise.

    Parameters
    ----------
    x_cam
        La position x de la camera.
    y_cam
        La position y de la camera.

    Returns
    -------
    sympy.Matrix
        La matrice sympy de taille 3 representant
        le vecteur uf dans le repere principal.

    Examples
    --------
    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; x_cam, y_cam = symbols(&#34;x y&#34;)
    &gt;&gt;&gt; transformer.get_expr_cam_to_uf(x_cam, y_cam)
    Matrix([
    [dd*sin(beta) - pixelsize*((x - xcen)*sin(gamma)*cos(beta) - (y - ycen)*cos(beta)*cos(gamma))],
    [                                  -pixelsize*((x - xcen)*cos(gamma) + (y - ycen)*sin(gamma))],
    [dd*cos(beta) + pixelsize*((x - xcen)*sin(beta)*sin(gamma) - (y - ycen)*sin(beta)*cos(gamma))]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    x_cam_atomic, y_cam_atomic = sympy.symbols(&#34;x_cam y_cam&#34;, real=True)
    o_op = self.dd * self.ck # Vecteur OO&#39;.
    op_p = self.pixelsize * ((x_cam_atomic-self.xcen)*self.ci + (y_cam_atomic-self.ycen)*self.cj) # Vecteur O&#39;P
    o_p = o_op + op_p # Relation de Chasles.
    o_p = sympy.signsimp(o_p)
    return o_p.subs({x_cam_atomic: x_cam, y_cam_atomic: y_cam})</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Equations.get_expr_gnomonic_to_uq"><code class="name flex">
<span>def <span class="ident">get_expr_gnomonic_to_uq</span></span>(<span>self, x_gnom, y_gnom)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permettant de passer du plan gnomonique a uq. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_gnom</code></strong></dt>
<dd>La position x du plan gnomonic.</dd>
<dt><strong><code>y_gnom</code></strong></dt>
<dd>La position y du plan gnomonic.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>La matrice sympy de taille 3 representant
le vecteur uq dans le repere principal.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; x_gnom, y_gnom = symbols(&quot;x y&quot;)
&gt;&gt;&gt; transformer.get_expr_gnomonic_to_uq(x_gnom, y_gnom)
Matrix([
[sqrt(2)*x/2 - sqrt(2)/2],
[                      y],
[sqrt(2)*x/2 + sqrt(2)/2]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expr_gnomonic_to_uq(self, x_gnom, y_gnom):
    &#34;&#34;&#34;
    ** Equation permettant de passer du plan gnomonique a uq. **

    Parameters
    ----------
    x_gnom
        La position x du plan gnomonic.
    y_gnom
        La position y du plan gnomonic.

    Returns
    -------
    sympy.Matrix
        La matrice sympy de taille 3 representant
        le vecteur uq dans le repere principal.

    Examples
    --------
    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; x_gnom, y_gnom = symbols(&#34;x y&#34;)
    &gt;&gt;&gt; transformer.get_expr_gnomonic_to_uq(x_gnom, y_gnom)
    Matrix([
    [sqrt(2)*x/2 - sqrt(2)/2],
    [                      y],
    [sqrt(2)*x/2 + sqrt(2)/2]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    x_gnom_atomic, y_gnom_atomic = sympy.symbols(&#34;x_gnom y_gnom&#34;, real=True)

    o_oppp = 1*self.gk # Vecteur OO&#39;&#39;&#39; == gk car le plan gnomonic est tangent a la shere unitaire.
    u_q = o_oppp + (x_gnom_atomic*self.gi + y_gnom_atomic*self.gj) # Relation de chasle.

    return u_q.subs({x_gnom_atomic: x_gnom, y_gnom_atomic: y_gnom})</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Equations.get_expr_thetachi_to_uf"><code class="name flex">
<span>def <span class="ident">get_expr_thetachi_to_uf</span></span>(<span>self, theta, chi)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permetant de passer de thetachi a uf. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong></dt>
<dd>Angle de rotation du plan christalin autour de -x.</dd>
<dt><strong><code>chi</code></strong></dt>
<dd>La moitier de l'angle de rotation du plan christalin autour de -y.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>La matrice sympy de taille 3 representant
le vecteur uf dans le repere principal.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; theta, chi = symbols(&quot;theta chi&quot;)
&gt;&gt;&gt; transformer.get_expr_thetachi_to_uf(theta, chi)
Matrix([
[         cos(2*theta)],
[sin(chi)*sin(2*theta)],
[sin(2*theta)*cos(chi)]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expr_thetachi_to_uf(self, theta, chi):
    &#34;&#34;&#34;
    ** Equation permetant de passer de thetachi a uf. **

    Parameters
    ----------
    theta
        Angle de rotation du plan christalin autour de -x.
    chi
        La moitier de l&#39;angle de rotation du plan christalin autour de -y.

    Returns
    -------
    sympy.Matrix
        La matrice sympy de taille 3 representant
        le vecteur uf dans le repere principal.

    Examples
    --------
    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; theta, chi = symbols(&#34;theta chi&#34;)
    &gt;&gt;&gt; transformer.get_expr_thetachi_to_uf(theta, chi)
    Matrix([
    [         cos(2*theta)],
    [sin(chi)*sin(2*theta)],
    [sin(2*theta)*cos(chi)]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    theta_atomic, chi_atomic = sympy.symbols(&#34;theta chi&#34;, real=True)

    # Expresion du rayon reflechit en fonction des angles.
    rot_refl = sympy.rot_axis1(chi_atomic) @ sympy.rot_axis2(2*theta_atomic)
    u_f = rot_refl @ self.u_i

    return u_f.subs({theta_atomic: theta, chi_atomic: chi})</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Equations.get_expr_uf_to_cam"><code class="name flex">
<span>def <span class="ident">get_expr_uf_to_cam</span></span>(<span>self, uf_x, uf_y, uf_z)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permettant de passer de uf a la camera. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uf_x</code></strong>, <strong><code>uf_y</code></strong>, <strong><code>uf_z</code></strong></dt>
<dd>Les 3 coordonnees du vecteur uf exprimees dans le repere principale.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x_camera</code></strong> :&ensp;<code>sympy.Basic</code></dt>
<dd>Expression sympy de la position de la tache dans le repere
de la camera. (selon l'axe x ou Ci)</dd>
<dt><strong><code>y_camera</code></strong> :&ensp;<code>sympy.Basic</code></dt>
<dd>Comme <code>x_camera</code> selon l'axe y ou Cj.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&quot;uf_x, uf_y, uf_z&quot;)
&gt;&gt;&gt; x_cam, y_cam = transformer.get_expr_uf_to_cam(uf_x, uf_y, uf_z)
&gt;&gt;&gt; x_cam
(-dd*uf_x*sin(gamma)*cos(beta) - dd*uf_y*cos(gamma) + dd*uf_z*sin(beta)*sin(gamma) + pixelsize*uf_x*xcen*sin(beta) + pixelsize*uf_z*xcen*cos(beta))/(pixelsize*(uf_x*sin(beta) + uf_z*cos(beta)))
&gt;&gt;&gt; y_cam
(dd*uf_x*cos(beta)*cos(gamma) - dd*uf_y*sin(gamma) - dd*uf_z*sin(beta)*cos(gamma) + pixelsize*uf_x*ycen*sin(beta) + pixelsize*uf_z*ycen*cos(beta))/(pixelsize*(uf_x*sin(beta) + uf_z*cos(beta)))
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expr_uf_to_cam(self, uf_x, uf_y, uf_z):
    &#34;&#34;&#34;
    ** Equation permettant de passer de uf a la camera. **

    Parameters
    ----------
    uf_x, uf_y, uf_z
        Les 3 coordonnees du vecteur uf exprimees dans le repere principale.

    Returns
    -------
    x_camera : sympy.Basic
        Expression sympy de la position de la tache dans le repere
        de la camera. (selon l&#39;axe x ou Ci)
    y_camera : sympy.Basic
        Comme ``x_camera`` selon l&#39;axe y ou Cj.

    Examples
    --------
    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&#34;uf_x, uf_y, uf_z&#34;)
    &gt;&gt;&gt; x_cam, y_cam = transformer.get_expr_uf_to_cam(uf_x, uf_y, uf_z)
    &gt;&gt;&gt; x_cam
    (-dd*uf_x*sin(gamma)*cos(beta) - dd*uf_y*cos(gamma) + dd*uf_z*sin(beta)*sin(gamma) + pixelsize*uf_x*xcen*sin(beta) + pixelsize*uf_z*xcen*cos(beta))/(pixelsize*(uf_x*sin(beta) + uf_z*cos(beta)))
    &gt;&gt;&gt; y_cam
    (dd*uf_x*cos(beta)*cos(gamma) - dd*uf_y*sin(gamma) - dd*uf_z*sin(beta)*cos(gamma) + pixelsize*uf_x*ycen*sin(beta) + pixelsize*uf_z*ycen*cos(beta))/(pixelsize*(uf_x*sin(beta) + uf_z*cos(beta)))
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    uf_x_atomic, uf_y_atomic, uf_z_atomic = sympy.symbols(&#34;uf_x uf_y uf_z&#34;, real=True)
    u_f = sympy.Matrix([uf_x_atomic, uf_y_atomic, uf_z_atomic])

    # Expression du vecteur O&#39;&#39;P.
    opp_op = self.pixelsize * (self.xcen*self.ci + self.ycen*self.cj) # Vecteur O&#39;&#39;O&#39;.
    o_op = self.dd * self.ck # Vecteur OO&#39;.
    op_o = -o_op # Vecteur O&#39;O.
    camera_plane = sympy.Plane(o_op, normal_vector=self.ck) # Plan de la camera.
    refl_ray = sympy.Line([0, 0, 0], u_f) # Rayon reflechi.
    o_p = sympy.Matrix(camera_plane.intersection(refl_ray).pop())
    opp_p = opp_op + op_o + o_p # Relation de Chasles.

    # Projection dans le plan de la camera pour remonter a x_c, y_c
    x_cam = opp_p.dot(self.ci) / self.pixelsize # Coordonnees en pxl axe x de la camera.
    y_cam = opp_p.dot(self.cj) / self.pixelsize # Coordonnees en pxl axe y de la camera.
    x_cam, y_cam = sympy.trigsimp(x_cam), sympy.trigsimp(y_cam) # Longueur reduite par 2.2 .

    return (x_cam.subs({uf_x_atomic: uf_x, uf_y_atomic: uf_y, uf_z_atomic: uf_z}),
            y_cam.subs({uf_x_atomic: uf_x, uf_y_atomic: uf_y, uf_z_atomic: uf_z}))</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Equations.get_expr_uf_to_thetachi"><code class="name flex">
<span>def <span class="ident">get_expr_uf_to_thetachi</span></span>(<span>self, uf_x, uf_y, uf_z)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permetant de passer de uf a thetachi. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uf_x</code></strong>, <strong><code>uf_y</code></strong>, <strong><code>uf_z</code></strong></dt>
<dd>Les 3 coordonnees du vecteur uf exprimees dans le repere principal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>sympy.Basic</code></dt>
<dd>Angle de rotation du plan christalin autour de -x.</dd>
<dt><strong><code>chi</code></strong> :&ensp;<code>sympy.Basic</code></dt>
<dd>La moitier de l'angle de rotation du plan christalin autour de -y.</dd>
</dl>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&quot;uf_x, uf_y, uf_z&quot;, real=True)
&gt;&gt;&gt; theta, chi = transformer.get_expr_uf_to_thetachi(uf_x, uf_y, uf_z)
&gt;&gt;&gt; theta
acos(uf_x/sqrt(uf_x**2 + uf_y**2 + uf_z**2))/2
&gt;&gt;&gt; chi
asin(uf_y/sqrt(uf_y**2 + uf_z**2))
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expr_uf_to_thetachi(self, uf_x, uf_y, uf_z):
    &#34;&#34;&#34;
    ** Equation permetant de passer de uf a thetachi. **

    Parameters
    ----------
    uf_x, uf_y, uf_z
        Les 3 coordonnees du vecteur uf exprimees dans le repere principal.

    Returns
    -------
    theta : sympy.Basic
        Angle de rotation du plan christalin autour de -x.
    chi : sympy.Basic
        La moitier de l&#39;angle de rotation du plan christalin autour de -y.

    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&#34;uf_x, uf_y, uf_z&#34;, real=True)
    &gt;&gt;&gt; theta, chi = transformer.get_expr_uf_to_thetachi(uf_x, uf_y, uf_z)
    &gt;&gt;&gt; theta
    acos(uf_x/sqrt(uf_x**2 + uf_y**2 + uf_z**2))/2
    &gt;&gt;&gt; chi
    asin(uf_y/sqrt(uf_y**2 + uf_z**2))
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def select(theta, chi):
        &#34;&#34;&#34;
        Cherche si theta &gt; 0 et -pi/2 &lt; chi &lt; pi/2
        &#34;&#34;&#34;
        func = sympy.lambdify([x, y, z], [theta, chi], modules=&#34;numpy&#34;)
        theta_vals, chi_vals = func(*np.meshgrid([-.5, .5], [-.5, .5], [.5]))
        if (theta_vals &lt; 0).any() or (chi_vals &lt; -np.pi/2).any() or (chi_vals &gt; np.pi/2).any():
            return False
        return True

    theta_atomic, chi_atomic = sympy.symbols(&#34;theta chi&#34;, real=True)
    x, y, z = sympy.symbols(&#34;x, y, z&#34;, real=True)
    u_f = sympy.Matrix([x, y, z])
    
    theta, chi = [
        (sol[theta_atomic], sol[chi_atomic])
        for sol in
        sympy.solve(
            self.get_expr_thetachi_to_uf(theta_atomic, chi_atomic)-u_f,
            [theta_atomic, chi_atomic],
            dict=True)
        if select(sol[theta_atomic], sol[chi_atomic])
        ].pop()

    uf_x, uf_y, uf_z = sympy.Matrix([uf_x, uf_y, uf_z]).normalized()

    return (theta.subs({x: uf_x, y: uf_y, z: uf_z}),
            chi.subs({x: uf_x, y: uf_y, z: uf_z}).simplify())</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Equations.get_expr_uf_to_uq"><code class="name flex">
<span>def <span class="ident">get_expr_uf_to_uq</span></span>(<span>self, uf_x, uf_y, uf_z)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permettant de passer de uf a uq. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uf_x</code></strong>, <strong><code>uf_y</code></strong>, <strong><code>uf_z</code></strong></dt>
<dd>Les 3 coordonnees du vecteur uf exprimees dans le repere principal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>La matrice sympy de taille 3 representant
le vecteur uq dans le repere principal.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&quot;uf_x, uf_y, uf_z&quot;)
&gt;&gt;&gt; transformer.get_expr_uf_to_uq(uf_x, uf_y, uf_z)
Matrix([
[uf_x - sqrt(uf_x**2 + uf_y**2 + uf_z**2)],
[                                    uf_y],
[                                    uf_z]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expr_uf_to_uq(self, uf_x, uf_y, uf_z):
    &#34;&#34;&#34;
    ** Equation permettant de passer de uf a uq. **

    Parameters
    ----------
    uf_x, uf_y, uf_z
        Les 3 coordonnees du vecteur uf exprimees dans le repere principal.

    Returns
    -------
    sympy.Matrix
        La matrice sympy de taille 3 representant
        le vecteur uq dans le repere principal.

    Examples
    --------
    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; uf_x, uf_y, uf_z = symbols(&#34;uf_x, uf_y, uf_z&#34;)
    &gt;&gt;&gt; transformer.get_expr_uf_to_uq(uf_x, uf_y, uf_z)
    Matrix([
    [uf_x - sqrt(uf_x**2 + uf_y**2 + uf_z**2)],
    [                                    uf_y],
    [                                    uf_z]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    uf_x_atomic, uf_y_atomic, uf_z_atomic = sympy.symbols(&#34;uf_x uf_y uf_z&#34;, real=True)
    u_f = sympy.Matrix([uf_x_atomic, uf_y_atomic, uf_z_atomic])
    u_q = u_f - self.u_i*u_f.norm() # Relation de reflexion.
    return u_q.subs({uf_x_atomic: uf_x, uf_y_atomic: uf_y, uf_z_atomic: uf_z})</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Equations.get_expr_uq_to_gnomonic"><code class="name flex">
<span>def <span class="ident">get_expr_uq_to_gnomonic</span></span>(<span>self, uq_x, uq_y, uq_z)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permettant de passer de uq a gnomonic. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uq_x</code></strong>, <strong><code>uq_y</code></strong>, <strong><code>uq_z</code></strong></dt>
<dd>Les 3 coordonnees du vecteur uq exprimees dans le repere principal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x_gnomonic</code></strong> :&ensp;<code>sympy.Basic</code></dt>
<dd>Expression sympy de la position de la tache dans le repere
du plan gnomonic. (selon l'axe x ou Gi)</dd>
<dt><strong><code>y_gnomonic</code></strong> :&ensp;<code>sympy.Basic</code></dt>
<dd>Comme <code>x_gnomonic</code> selon l'axe y ou Gj.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; uq_x, uq_y, uq_z = symbols(&quot;uq_x, uq_y, uq_z&quot;)
&gt;&gt;&gt; x_gnom, y_gnom = transformer.get_expr_uq_to_gnomonic(uq_x, uq_y, uq_z)
&gt;&gt;&gt; x_gnom
-(uq_x + uq_z)/(uq_x - uq_z)
&gt;&gt;&gt; y_gnom
-sqrt(2)*uq_y/(uq_x - uq_z)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expr_uq_to_gnomonic(self, uq_x, uq_y, uq_z):
    &#34;&#34;&#34;
    ** Equation permettant de passer de uq a gnomonic. **

    Parameters
    ----------
    uq_x, uq_y, uq_z
        Les 3 coordonnees du vecteur uq exprimees dans le repere principal.

    Returns
    -------
    x_gnomonic : sympy.Basic
        Expression sympy de la position de la tache dans le repere
        du plan gnomonic. (selon l&#39;axe x ou Gi)
    y_gnomonic : sympy.Basic
        Comme ``x_gnomonic`` selon l&#39;axe y ou Gj.

    Examples
    --------
    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; uq_x, uq_y, uq_z = symbols(&#34;uq_x, uq_y, uq_z&#34;)
    &gt;&gt;&gt; x_gnom, y_gnom = transformer.get_expr_uq_to_gnomonic(uq_x, uq_y, uq_z)
    &gt;&gt;&gt; x_gnom
    -(uq_x + uq_z)/(uq_x - uq_z)
    &gt;&gt;&gt; y_gnom
    -sqrt(2)*uq_y/(uq_x - uq_z)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    uq_x_atomic, uq_y_atomic, uq_z_atomic = sympy.symbols(&#34;uq_x uq_y uq_z&#34;, real=True)
    u_q = sympy.Matrix([uq_x_atomic, uq_y_atomic, uq_z_atomic])
    o_oppp = 1*self.gk # Car sphere unitaire de rayon 1.

    gnom_plane = sympy.Plane(o_oppp, normal_vector=self.gk) # Plan gnomonic.
    normal_ray = sympy.Line([0, 0, 0], u_q) # Droite portee par la normal au plan christalin.
    o_pp = sympy.Matrix(gnom_plane.intersection(normal_ray).pop())
    oppp_pp = -o_oppp + o_pp

    # Projection dans le plan gnomonic pour remonter a x_g, y_g.
    x_gnom = oppp_pp.dot(self.gi) # Coordonnees en mm axe x du plan gnomonic.
    y_gnom = oppp_pp.dot(self.gj) # Coordonnees en mm axe y du plan gnomonic.

    x_gnom = sympy.signsimp(sympy.cancel(x_gnom))

    return (x_gnom.subs({uq_x_atomic: uq_x, uq_y_atomic: uq_y, uq_z_atomic: uq_z}),
            y_gnom.subs({uq_x_atomic: uq_x, uq_y_atomic: uq_y, uq_z_atomic: uq_z}))</code></pre>
</details>
</dd>
<dt id="laue.core.geometry.symbolic.Equations.get_expr_uq_to_uf"><code class="name flex">
<span>def <span class="ident">get_expr_uq_to_uf</span></span>(<span>self, uq_x, uq_y, uq_z)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Equation permettant de passer de uq a uf. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>uq_x</code></strong>, <strong><code>uq_y</code></strong>, <strong><code>uq_z</code></strong></dt>
<dd>Les 3 coordonnees du vecteur uq exprimees dans le repere principal.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sympy.Matrix</code></dt>
<dd>La matrice sympy de taille 3 representant
le vecteur uf dans le repere principal.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy import symbols
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; uq_x, uq_y, uq_z = symbols(&quot;uq_x, uq_y, uq_z&quot;)
&gt;&gt;&gt; transformer.get_expr_uq_to_uf(uq_x, uq_y, uq_z)
Matrix([
[-uq_x**2 + uq_y**2 + uq_z**2],
[                -2*uq_x*uq_y],
[                -2*uq_x*uq_z]])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expr_uq_to_uf(self, uq_x, uq_y, uq_z):
    &#34;&#34;&#34;
    ** Equation permettant de passer de uq a uf. **

    Parameters
    ----------
    uq_x, uq_y, uq_z
        Les 3 coordonnees du vecteur uq exprimees dans le repere principal.

    Returns
    -------
    sympy.Matrix
        La matrice sympy de taille 3 representant
        le vecteur uf dans le repere principal.

    Examples
    --------
    &gt;&gt;&gt; from sympy import symbols
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; uq_x, uq_y, uq_z = symbols(&#34;uq_x, uq_y, uq_z&#34;)
    &gt;&gt;&gt; transformer.get_expr_uq_to_uf(uq_x, uq_y, uq_z)
    Matrix([
    [-uq_x**2 + uq_y**2 + uq_z**2],
    [                -2*uq_x*uq_y],
    [                -2*uq_x*uq_z]])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    uq_x_atomic, uq_y_atomic, uq_z_atomic = sympy.symbols(&#34;uq_x uq_y uq_z&#34;, real=True)
    u_q = sympy.Matrix([uq_x_atomic, uq_y_atomic, uq_z_atomic])
    u_f = self.u_i*u_q.norm()**2 - 2*u_q.dot(self.u_i)*u_q # Vecteur unitaire reflechi.
    return u_f.subs({uq_x_atomic: uq_x, uq_y_atomic: uq_y, uq_z_atomic: uq_z})</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laue.core.geometry" href="index.html">laue.core.geometry</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laue.core.geometry.symbolic.Compilator" href="#laue.core.geometry.symbolic.Compilator">Compilator</a></code></h4>
<ul class="">
<li><code><a title="laue.core.geometry.symbolic.Compilator.compile" href="#laue.core.geometry.symbolic.Compilator.compile">compile</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_gnomonic" href="#laue.core.geometry.symbolic.Compilator.get_fct_cam_to_gnomonic">get_fct_cam_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_thetachi" href="#laue.core.geometry.symbolic.Compilator.get_fct_cam_to_thetachi">get_fct_cam_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_dist_line" href="#laue.core.geometry.symbolic.Compilator.get_fct_dist_line">get_fct_dist_line</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_cam" href="#laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_cam">get_fct_gnomonic_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_thetachi" href="#laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_thetachi">get_fct_gnomonic_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_hough" href="#laue.core.geometry.symbolic.Compilator.get_fct_hough">get_fct_hough</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_inter_line" href="#laue.core.geometry.symbolic.Compilator.get_fct_inter_line">get_fct_inter_line</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_cam" href="#laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_cam">get_fct_thetachi_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_gnomonic" href="#laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_gnomonic">get_fct_thetachi_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.load" href="#laue.core.geometry.symbolic.Compilator.load">load</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.save" href="#laue.core.geometry.symbolic.Compilator.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="laue.core.geometry.symbolic.Equations" href="#laue.core.geometry.symbolic.Equations">Equations</a></code></h4>
<ul class="">
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_cam_to_uf" href="#laue.core.geometry.symbolic.Equations.get_expr_cam_to_uf">get_expr_cam_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_gnomonic_to_uq" href="#laue.core.geometry.symbolic.Equations.get_expr_gnomonic_to_uq">get_expr_gnomonic_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_thetachi_to_uf" href="#laue.core.geometry.symbolic.Equations.get_expr_thetachi_to_uf">get_expr_thetachi_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uf_to_cam" href="#laue.core.geometry.symbolic.Equations.get_expr_uf_to_cam">get_expr_uf_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uf_to_thetachi" href="#laue.core.geometry.symbolic.Equations.get_expr_uf_to_thetachi">get_expr_uf_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uf_to_uq" href="#laue.core.geometry.symbolic.Equations.get_expr_uf_to_uq">get_expr_uf_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uq_to_gnomonic" href="#laue.core.geometry.symbolic.Equations.get_expr_uq_to_gnomonic">get_expr_uq_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Equations.get_expr_uq_to_uf" href="#laue.core.geometry.symbolic.Equations.get_expr_uq_to_uf">get_expr_uq_to_uf</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>