<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>laue.core.subsets API documentation</title>
<meta name="description" content="** Permet de separer les differents grains d&#39;un diagramme. **
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laue.core.subsets</code></h1>
</header>
<section id="section-intro">
<h2 id="permet-de-separer-les-differents-grains-dun-diagramme"><strong> Permet de separer les differents grains d'un diagramme. </strong></h2>
<p>Pour separer les grains d'un diagramme, les etapes sont les suivantes:</p>
<ol>
<li>Chercher les <strong>axes de zone</strong>.</li>
<li>Chercher les spots aux <strong>intersections</strong> des axes de zones.
(Pour la suite on ne considere plus que ces spots.)</li>
<li>Construire un <strong>graphe</strong> qui relie les spots qui partagent un meme axe de zone.</li>
<li>Supprimer les aretes non pertinantes.<ol>
<li>On parcours chaque arete du graphe.</li>
<li>Si il n'y a pas de voisins communs parmis les voisins des 2 somet de cette arete.</li>
<li>On supprime cette arete.</li>
</ol>
</li>
<li>Extraire les <strong>composantes connexes</strong> du graphe.</li>
<li>Associer les axes de zone aux sous-graphes conexes.</li>
</ol>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
** Permet de separer les differents grains d&#39;un diagramme. **
------------------------------------------------------------

Pour separer les grains d&#39;un diagramme, les etapes sont les suivantes:

1. Chercher les **axes de zone**.
2. Chercher les spots aux **intersections** des axes de zones.
    (Pour la suite on ne considere plus que ces spots.)
3. Construire un **graphe** qui relie les spots qui partagent un meme axe de zone.
4. Supprimer les aretes non pertinantes.
    1. On parcours chaque arete du graphe.
    2. Si il n&#39;y a pas de voisins communs parmis les voisins des 2 somet de cette arete.
    3. On supprime cette arete.
5. Extraire les **composantes connexes** du graphe.
6. Associer les axes de zone aux sous-graphes conexes.
&#34;&#34;&#34;

import math


class Splitable:
    &#34;&#34;&#34;
    Interface pour la classe ``laue.diagram.LaueDiagram``.
    &#34;&#34;&#34;
    def find_subsets(self, *, angle_max=math.pi/24, spots_max=20, distance_max=.08,
        _atomic_subsets_res=None, _get_args=False):
        &#34;&#34;&#34;
        ** Recherche des spots qui appartiennent a un meme grain. **

        L&#39;algorithme est le suivant:

        - Creation d&#39;un graphe dont les somets sont des spots.
            - Selection des spots interressants.
                - Selection des spots qui sont a des intersection d&#39;axes de zone.
                - Trie des spots par nombre d&#39;axes de zone decroissant.
                - Selection des ``spots_max`` spots qui intersectent suffisement d&#39;axes.
            - Creation des aretes.
                - Pour chaque paire de somets (paire de spots).
                    - Si il sont lies par un axe de zone.
                        - Alors on les relie avec une arete dont le poid est la
                        qualite du meilleur axe de zone qui passe par ces 2 spots.
        - Supression de certaines aretes.
            - Reperage des paires de spots qui apartiennent a des grains differents.
                - Pour chaque paire de somets (paire de spots).
                    - Si les 2 spots sont trop proche (distance &lt; ``distance_max``).
                        - Alors on repere cette paire de spots.
                    - Si par ces 2 spots passe 2 axes de zone angulairement &lt; ``angle_max``.
                        - Alors on repere cette paire de spots.
            - Tant qu&#39;il existe au moin un chemin permetant de relier une paire de spots marque.
                - On cherche l&#39;arete qui, si on l&#39;a retire, permet de reduire le plus fortement
                le nombre de paire de somet marque qui sont encore relies.
                - Parmis les aretes quandidates, on supprime celle qui est lie a l&#39;axe de
                zone de plus mauvaise qualite.
        - Creation des clusters.
            - On extrait toutes les composantes conexes du graphe.
            - On elimine les composantes qui ne contienent qu&#39;un seul sommet.
            - **return** les composantes conexes restantes.

        Notes
        -----
        Les spots trouves sont souvent des spots ayant un indice de Miller
        relativement faible.

        Returns
        -------
        list
            Chaque element est un &#39;cluster&#39; de spots qui ont une forte probabilite
            d&#39;appartenir a un meme grain. Par contre, il n&#39;y a aucune garantie
            que 2 clusters appartienent chacuns a 2 grains differents.
            Les cluster sont des ``set`` de spot de type ``laue.spot.Spot``.

        Parameters
        ----------
        angle_max : float
            L&#39;angle maximal entre 2 axes de zones. (en radian)
            Si par un spot, il passe 2 axes de zonnes angulairement plus seres
            que cet angle limite, alors ces 2 axes ne sont comptes que comme 1 seul.
            en consequence, plus cet angle est grand, moins on est selectif sur les spots.
            Ce meme angle intervient ailleur. Si il existe 2 axes de zones passants chacuns
            par un spots differents, que ces 2 axes sont angulairement plus sere
            que ``angle_max``, et que ces 2 spots sont relies par un autre axe de zone,
            alors ces 2 spots se retrouveront dans des clusters differents.
        spots_max : int
            Le nombre maximum total de spots consideres. Plus ce nombre est grand
            plus il y a des chance qu&#39;il y ai une solution mais moins cette solution
            aura des chances d&#39;etre pertinante. Le temps de calcul est aussi quadratiquement
            lie au nombre de sommets.
        distance_max : float
            2 spots qui sont separes d&#39;une distance inferieure a ce parametre se retrouveront
            dans des clusters differents. Cette distance est la distance euclidiene du plan
            gnomonic (en mm).

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = next(iter(laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)))
        &gt;&gt;&gt; type(diag.find_subsets())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; len(diag.find_subsets()) # nbr de clusters
        1
        &gt;&gt;&gt; type(diag.find_subsets().pop())
        &lt;class &#39;set&#39;&gt;
        &gt;&gt;&gt; len(diag.find_subsets().pop()) # nbr de spot dans le premier cluster
        3
        &gt;&gt;&gt; type(diag.find_subsets().pop().pop())
        &lt;class &#39;laue.spot.Spot&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(angle_max, float), \
            f&#34;&#39;angle_max&#39; has to be a float, not a {type(angle_max).__name__}.&#34;
        assert isinstance(spots_max, int), \
            f&#34;&#39;spots_max&#39; has to be an integer, not a {type(spots_max).__name__}.&#34;
        assert isinstance(distance_max, float), \
            f&#34;&#39;distance_max&#39; has to be of type float, not {type(distance_max).__name__}.&#34;
        assert 0 &lt; angle_max &lt;= math.pi/4, (&#34;L&#39;angle doit etre exprime en radian. &#34;
            f&#34;Il doit etre dans l&#39;intervalle ]0, pi/4]. Or il vaut {angle_max}.&#34;)
        assert 2 &lt;= spots_max, \
            f&#34;Il faut au moins considerer 2 spots, {spots_max} c&#39;est pas possible.&#34;
        assert 0 &lt; distance_max &lt; .3, (&#34;La distance de sepration des grains est exprimee &#34;
            &#34;en mm dans le plan gnomonic. Elle doit etre comprise entre ]0, .3]. &#34;
            f&#34;Or elle vaut {distance_max}, ce qui sort de cet intervalle.&#34;)

        args = _get_spots_axes(self)
        config = dict(angle_max=angle_max,
                      spots_max=spots_max,
                      distance_max=distance_max)
        if _get_args: # Si il faut seulement preparer le travail.
            return args, config

        if _atomic_subsets_res is None: # Si il faut faire les calculs.
            _atomic_subsets_res = atomic_find_subsets(*args, **config)
        
        subsets = [{self[spot_id] for spot_id in subset} for subset in _atomic_subsets_res]
        return subsets

def _get_spots_axes(diag):
    &#34;&#34;&#34;
    Recupere et met en forme les spots et les axes.
    Retourne &#39;spots&#39; et &#39;axes&#39; compatible avec ``find_subset``.
    &#34;&#34;&#34;
    spots = {
        i: {
            &#34;gnom&#34;: spot.get_gnomonic(),
            &#34;axes&#34;: {axis.get_id() for axis in spot.find_zone_axes()}
        }
        for i, spot in enumerate(diag)
    }
    axes = {
        axes.get_id(): {
            &#34;polar&#34;: axes.get_polar_coords(),
            &#34;quality&#34;: axes.get_quality(),
            &#34;spots&#34;: {spot.get_id() for spot in axes}
        }
        for axes in diag.find_zone_axes()
    }
    return spots, axes

def atomic_find_subsets(spots_dict, axes_dict, **kwargs):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de separation de grains. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.Experiment.find_subsets``
    ou encore via ``laue.diagram.LaueDiagram.find_subsets`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.Experiment.find_subsets`` gere nativement le parallelisme.

    Parameters
    ----------
    spots_dict : dict
        Une representation des spots et des information minimales
        qui y sont raccrochees. Il doit prendre la forme suivante:
        ``{spot_ind: {&#34;gnom&#34;: (x_gnom, y_gnom), &#34;axes&#34;: {1, 3, ...}}, ...}``
    axes_dict : dict
        Une representations des axes de zone. Doit etre de la forme:
        ``{axe_ind: {&#34;polar&#34;: (theta, dist), &#34;quality&#34;: .7, &#34;spots&#34;: {1, 4, 5, 6}}, ...}``
    **kwargs
        Doit au moins contenir les 3 champs ``angle_max``, ``spots_max`` et ``distance_max``.

    Returns
    -------
    list
        Chaque element est un ensemble d&#39;indice de spot appartenant au meme grain.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; spots_dict = {0: {&#39;gnom&#39;: (0.3136510725564478, -0.44091934214920697), &#39;axes&#39;: set()},
    ...               1: {&#39;gnom&#39;: (0.3092269223801162, -0.3703963974694111), &#39;axes&#39;: {0}},
    ...               2: {&#39;gnom&#39;: (0.29464954430652696, 0.39670741889986955), &#39;axes&#39;: {1}},
    ...               3: {&#39;gnom&#39;: (0.30191318963902786, 0.011759364157261544), &#39;axes&#39;: {2}},
    ...               4: {&#39;gnom&#39;: (0.2656586060012433, -0.29892567761860783), &#39;axes&#39;: {0}},
    ...               5: {&#39;gnom&#39;: (0.2537441830952802, 0.32256757073867776), &#39;axes&#39;: {1}},
    ...               6: {&#39;gnom&#39;: (0.259687191990358, 0.011094867051531301), &#39;axes&#39;: {2}},
    ...               7: {&#39;gnom&#39;: (0.21447480004378858, -0.2150686716681864), &#39;axes&#39;: {0}},
    ...               8: {&#39;gnom&#39;: (0.2057015738443993, 0.2356420984106664), &#39;axes&#39;: {1}},
    ...               9: {&#39;gnom&#39;: (0.09095514707222462, -0.5356714822419564), &#39;axes&#39;: {3, 4}},
    ...               10: {&#39;gnom&#39;: (0.06846289051965272, 0.5548594993575858), &#39;axes&#39;: {3, 5}},
    ...               11: {&#39;gnom&#39;: (0.16685972592987006, -0.1362785647833782), &#39;axes&#39;: {0}},
    ...               12: {&#39;gnom&#39;: (0.16092652407854113, 0.15424696872260854), &#39;axes&#39;: {1}},
    ...               13: {&#39;gnom&#39;: (0.0880179013812851, -0.40043047804756454), &#39;axes&#39;: {3}},
    ...               14: {&#39;gnom&#39;: (0.07130573600458438, 0.4174843621463065), &#39;axes&#39;: {3}},
    ...               15: {&#39;gnom&#39;: (0.08639048300887514, -0.31911672107326594), &#39;axes&#39;: {3}},
    ...               16: {&#39;gnom&#39;: (0.07308383568548608, 0.3351760458933546), &#39;axes&#39;: {3}},
    ...               17: {&#39;gnom&#39;: (-0.016567440130016563, -0.5541568143935384), &#39;axes&#39;: {6}},
    ...               18: {&#39;gnom&#39;: (-0.04084781468303007, 0.5689448068249144), &#39;axes&#39;: {7}},
    ...               19: {&#39;gnom&#39;: (0.0011982188252073992, -0.45016007120047424), &#39;axes&#39;: set()},
    ...               20: {&#39;gnom&#39;: (-0.018154025485441625, 0.46402526754308027), &#39;axes&#39;: set()},
    ...               21: {&#39;gnom&#39;: (-0.07286049562681773, -0.5640133440412382), &#39;axes&#39;: set()},
    ...               22: {&#39;gnom&#39;: (0.0798366324753105, 0.007023938379407561), &#39;axes&#39;: {0, 1, 2, 3}},
    ...               23: {&#39;gnom&#39;: (-0.0026903259324252246, 0.3921879524265071), &#39;axes&#39;: {5}},
    ...               24: {&#39;gnom&#39;: (-0.09784778756977644, 0.5766271192972883), &#39;axes&#39;: set()},
    ...               25: {&#39;gnom&#39;: (0.008002458469782677, -0.12293574282766238), &#39;axes&#39;: {1}},
    ...               26: {&#39;gnom&#39;: (0.0027460490484708115, 0.13394781189060836), &#39;axes&#39;: {0}},
    ...               27: {&#39;gnom&#39;: (-0.00523750349077013, -0.1470394198008183), &#39;axes&#39;: {1}},
    ...               28: {&#39;gnom&#39;: (-0.011614516626281228, 0.15777148638160254), &#39;axes&#39;: {0}},
    ...               29: {&#39;gnom&#39;: (-0.02477598980567221, -0.1823836791494654), &#39;axes&#39;: {1}},
    ...               30: {&#39;gnom&#39;: (-0.03264505249777272, 0.19229497060446735), &#39;axes&#39;: {0}},
    ...               31: {&#39;gnom&#39;: (-0.05554717740227801, -0.23832176191125093), &#39;axes&#39;: {1, 4}},
    ...               32: {&#39;gnom&#39;: (-0.06606796372263056, 0.24757266647939288), &#39;axes&#39;: {0, 5}},
    ...               33: {&#39;gnom&#39;: (-0.07907768658950604, -0.28096918114364355), &#39;axes&#39;: {1}},
    ...               34: {&#39;gnom&#39;: (-0.09156428823859053, 0.2893970244445073), &#39;axes&#39;: {0}},
    ...               35: {&#39;gnom&#39;: (-0.1126289846318788, -0.3416241560303849), &#39;axes&#39;: {1, 6}},
    ...               36: {&#39;gnom&#39;: (-0.060637577826655534, 0.0040391083212410655), &#39;axes&#39;: {2}},
    ...               37: {&#39;gnom&#39;: (-0.12787900102974828, 0.3491863530719953), &#39;axes&#39;: {0, 7}},
    ...               38: {&#39;gnom&#39;: (-0.1638208798822865, -0.4347286698438957), &#39;axes&#39;: {1}},
    ...               39: {&#39;gnom&#39;: (-0.18763951100210385, -0.4776573606384503), &#39;axes&#39;: {1}},
    ...               40: {&#39;gnom&#39;: (-0.1835787305562983, 0.4411739247300923), &#39;axes&#39;: {0}},
    ...               41: {&#39;gnom&#39;: (-0.08524649743749545, 0.003436523504335945), &#39;axes&#39;: {2}},
    ...               42: {&#39;gnom&#39;: (-0.2523542667003644, -0.5949096601292776), &#39;axes&#39;: {8, 1}},
    ...               43: {&#39;gnom&#39;: (-0.20958039716029048, 0.4837711867805186), &#39;axes&#39;: {0}},
    ...               44: {&#39;gnom&#39;: (-0.11758167206566646, -0.1123768702642382), &#39;axes&#39;: {4}},
    ...               45: {&#39;gnom&#39;: (-0.12266805447587614, 0.11817207059217111), &#39;axes&#39;: {5}},
    ...               46: {&#39;gnom&#39;: (-0.17376685735949005, 0.0016472083664571353), &#39;axes&#39;: {2, 4, 5}},
    ...               47: {&#39;gnom&#39;: (-0.20724297206742168, -0.25150647771157364), &#39;axes&#39;: set()},
    ...               48: {&#39;gnom&#39;: (-0.19501092265693473, -0.15910834995174863), &#39;axes&#39;: {6}},
    ...               49: {&#39;gnom&#39;: (-0.21870028043714163, 0.25404867230414246), &#39;axes&#39;: set()},
    ...               50: {&#39;gnom&#39;: (-0.2022799134764107, 0.16163477331619278), &#39;axes&#39;: {7}},
    ...               51: {&#39;gnom&#39;: (-0.2581018757728966, -0.3579924435989167), &#39;axes&#39;: {8}},
    ...               52: {&#39;gnom&#39;: (-0.2748170617964089, 0.3596407013965223), &#39;axes&#39;: {8}},
    ...               53: {&#39;gnom&#39;: (-0.21290266125204668, 0.0008346770568725252), &#39;axes&#39;: {2}},
    ...               54: {&#39;gnom&#39;: (-0.21986841578944072, -0.10369811043407293), &#39;axes&#39;: {5, 6}},
    ...               55: {&#39;gnom&#39;: (-0.224622744015843, 0.10503684334781563), &#39;axes&#39;: {4, 7}},
    ...               56: {&#39;gnom&#39;: (-0.25955409478645797, -0.29848728294016463), &#39;axes&#39;: {8}},
    ...               57: {&#39;gnom&#39;: (-0.27338619051240226, 0.299389601118816), &#39;axes&#39;: {8}},
    ...               58: {&#39;gnom&#39;: (-0.3156632165624574, -0.4202358686963255), &#39;axes&#39;: set()},
    ...               59: {&#39;gnom&#39;: (-0.2618304221414466, -0.19929059589121062), &#39;axes&#39;: {8, 5}},
    ...               60: {&#39;gnom&#39;: (-0.2711073666720387, 0.1994839074523256), &#39;axes&#39;: {8, 4}},
    ...               61: {&#39;gnom&#39;: (-0.2637120677768278, -0.11984479170021081), &#39;axes&#39;: {8}},
    ...               62: {&#39;gnom&#39;: (-0.26934469418071083, 0.11943958616023759), &#39;axes&#39;: {8}},
    ...               63: {&#39;gnom&#39;: (-0.26653796331705015, -0.00040349411462381246), &#39;axes&#39;: {8, 2, 6, 7}},
    ...               64: {&#39;gnom&#39;: (-0.3351088299984176, -0.36661822106768144), &#39;axes&#39;: {5}},
    ...               65: {&#39;gnom&#39;: (-0.30919293226499917, -0.22782988778598667), &#39;axes&#39;: set()},
    ...               66: {&#39;gnom&#39;: (-0.3524825023650732, 0.3647641920521141), &#39;axes&#39;: {4}},
    ...               67: {&#39;gnom&#39;: (-0.31990969642322137, 0.22611752961083748), &#39;axes&#39;: set()},
    ...               68: {&#39;gnom&#39;: (-0.3144023520521512, -0.0013698968940222644), &#39;axes&#39;: {2}},
    ...               69: {&#39;gnom&#39;: (-0.3223772542169661, -0.14153279317889217), &#39;axes&#39;: {7}},
    ...               70: {&#39;gnom&#39;: (-0.3290872223583307, 0.13867490378055763), &#39;axes&#39;: {6}},
    ...               71: {&#39;gnom&#39;: (-0.34380505280556134, -0.0019232844125064402), &#39;axes&#39;: {2}},
    ...               72: {&#39;gnom&#39;: (-0.3716527272451695, -0.2655541496297943), &#39;axes&#39;: {7}},
    ...               73: {&#39;gnom&#39;: (-0.384382394518522, 0.26137948985364423), &#39;axes&#39;: {6}},
    ...               74: {&#39;gnom&#39;: (-0.4150393355485816, -0.37556396956837046), &#39;axes&#39;: {7}},
    ...               75: {&#39;gnom&#39;: (-0.4213116259525938, -0.1277995546595711), &#39;axes&#39;: set()},
    ...               76: {&#39;gnom&#39;: (-0.42743697409652126, 0.12091462467337603), &#39;axes&#39;: set()},
    ...               77: {&#39;gnom&#39;: (-0.4305672928685682, -0.10207732996277492), &#39;axes&#39;: set()}}
    &gt;&gt;&gt; axes_dict = {0: {&#39;polar&#39;: (0.5456325, 0.07189146), &#39;quality&#39;: 0.7786729549943984, &#39;spots&#39;: {32, 1, 34, 4, 37, 7, 40, 11, 43, 22, 26, 28, 30}},
    ...              1: {&#39;polar&#39;: (-0.50404394, 0.066435024), &#39;quality&#39;: 0.8495679649229442, &#39;spots&#39;: {33, 2, 35, 5, 38, 39, 8, 42, 12, 22, 25, 27, 29, 31}},
    ...              2: {&#39;polar&#39;: (1.5920126, 0.0053436677), &#39;quality&#39;: 0.5048333500772214, &#39;spots&#39;: {3, 36, 68, 6, 71, 41, 46, 53, 22, 63}},
    ...              3: {&#39;polar&#39;: (0.020630987, 0.07989738), &#39;quality&#39;: 0.32446216058045907, &#39;spots&#39;: {9, 10, 13, 14, 15, 16, 22}},
    ...              4: {&#39;polar&#39;: (-2.6840417, 0.15513226), &#39;quality&#39;: 0.32470155528405464, &#39;spots&#39;: {66, 9, 44, 46, 55, 60, 31}},
    ...              5: {&#39;polar&#39;: (2.7287471, 0.15980783), &#39;quality&#39;: 0.36693478788694234, &#39;spots&#39;: {32, 64, 10, 45, 46, 54, 23, 59}},
    ...              6: {&#39;polar&#39;: (-2.7180853, 0.24310948), &#39;quality&#39;: 0.324204821510315, &#39;spots&#39;: {35, 70, 73, 48, 17, 54, 63}},
    ...              7: {&#39;polar&#39;: (2.7643242, 0.24759501), &#39;quality&#39;: 0.3668147624332471, &#39;spots&#39;: {69, 37, 72, 74, 18, 50, 55, 63}},
    ...              8: {&#39;polar&#39;: (-3.118213, 0.26645306), &#39;quality&#39;: 0.5046664108258551, &#39;spots&#39;: {42, 51, 52, 56, 57, 59, 60, 61, 62, 63}}}
    &gt;&gt;&gt; kwargs = {&#39;angle_max&#39;: 0.1308996938995747, &#39;spots_max&#39;: 20, &#39;distance_max&#39;: 0.08}
    &gt;&gt;&gt; laue.atomic_find_subsets(spots_dict, axes_dict, **kwargs)
    [{9, 10, 22}]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.zone_axis import distance as distance_axis
    from laue.spot import distance as distance_pic
    import networkx

    def count_variant_axis(spot_id):
        &#34;&#34;&#34;
        Compte le nombre d&#39;axes de zone qui different beaucoup.
        (ie considere 2 axes proche comme un seul axe)
        &#34;&#34;&#34;
        axes_id = spots_dict[spot_id][&#34;axes&#34;]
        if len(axes_id) &lt;= 1:
            return len(axes_id)
        axes = [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes_id]
        nbr_near = (distance_axis(axes, axes, weight=1) &lt; kwargs[&#34;angle_max&#34;]).sum()
        nbr = len(axes) - (nbr_near-len(axes))//2
        return nbr

    def simul_remove_axis(graph, axis, excluded):
        &#34;&#34;&#34;
        Retire les aretes liees a cet axe, puis regarde ce que ca donne.
        &#34;&#34;&#34;
        graph_bis = graph.copy()
        for spot1, spot2, axis_found in graph.edges.data(&#34;axis&#34;):
            if axis_found is axis:
                graph_bis.remove_edge(spot1, spot2)
        excluded_bis = [edge for edge in excluded if networkx.algorithms.has_path(graph_bis, *edge)]
        return excluded_bis, graph_bis

    # Extraction des spots.
    spots_at_cross = sorted(spots_dict, key=count_variant_axis, reverse=True)[:kwargs[&#34;spots_max&#34;]]
    max_cross = count_variant_axis(spots_at_cross[0])
    limit = math.sqrt(max(2**2, max_cross)) # Permet d&#39;eviter &#39;ValueError: math domain error&#39;
    spots_at_cross = [spot_id for spot_id in spots_at_cross if count_variant_axis(spot_id) &gt;= limit]

    # Creation des noeuds du graphe.
    graph = networkx.Graph()
    graph.add_nodes_from(spots_at_cross)

    # Ajout grossier de certaine aretes.
    excluded = [] # La liste des noeuds appartenant a des grains differents.
    candidate_axes = set() # L&#39;ensemble des axes de zone consideres.
    for i, spot1 in enumerate(spots_at_cross[:-1]): # On faite toutes les combinaisons
        for spot2 in spots_at_cross[i+1:]: # de 2 sommets possibles.

            ## Exclusion des spots trop proches.
            if distance_pic(
                    spots_dict[spot1][&#34;gnom&#34;],
                    spots_dict[spot2][&#34;gnom&#34;],
                    space=&#34;gnomonic&#34;
                    ) &lt; kwargs[&#34;distance_max&#34;]:
                excluded.append((spot1, spot2))
                continue

            ## On ne relie pas les spots qui n&#39;ont pas d&#39;axe commun.
            common_axes = spots_dict[spot1][&#34;axes&#34;] &amp; spots_dict[spot2][&#34;axes&#34;]
            if not common_axes:
                continue

            ## Exclusion des spots ayant 2 axes de zone paralleles.
            axes1, axes2 = spots_dict[spot1][&#34;axes&#34;]-common_axes, spots_dict[spot2][&#34;axes&#34;]-common_axes
            if axes1 and axes2 and distance_axis(
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes1],
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes2],
                    weight=1).min() &lt; kwargs[&#34;angle_max&#34;]: # tolerance angulaire de pi/32
                excluded.append((spot1, spot2))
                continue

            ## Ajout dans le graphe.
            best_axis = sorted(common_axes, key=lambda axis_id: axes_dict[axis_id][&#34;quality&#34;])[-1]
            candidate_axes.add(best_axis)
            graph.add_edge(spot1, spot2, quality=axes_dict[best_axis][&#34;quality&#34;], axis=best_axis)

    # Suppression des aretes en trop afin de discosier les grains.
    excluded = [edge for edge in excluded if networkx.algorithms.has_path(graph, *edge)]
    while excluded:
        predictions = [(*simul_remove_axis(graph, axis_id, excluded), axis_id) for axis_id in candidate_axes]
        best_len = min(len(excluded_bis) for excluded_bis, _, _ in predictions)
        predictions = [p for p in predictions if len(p[0]) == best_len]
        costs = [axes_dict[axis_id][&#34;quality&#34;] for _, _, axis_id in predictions]
        min_quality = min(costs)
        predictions = [p for p in predictions if axes_dict[p[2]][&#34;quality&#34;] == min_quality]
        excluded, graph, axis_id = predictions.pop()
        candidate_axes.remove(axis_id)

    # Creation des clusters.
    subsets = list(networkx.algorithms.connected_components(graph))
    subsets = sorted(subsets, key=lambda con: len(con), reverse=True)
    subsets = [con for con in subsets if len(con) &gt;= 2]
    return subsets

def _pickelable(args):
    &#34;&#34;&#34;
    args = ((spots_dict, axes_dict), kwargs)
    &#34;&#34;&#34;
    return atomic_find_subsets(*args[0], **args[1])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laue.core.subsets.atomic_find_subsets"><code class="name flex">
<span>def <span class="ident">atomic_find_subsets</span></span>(<span>spots_dict, axes_dict, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Fonction 'bas niveau' de separation de grains. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Cette fonction n'est pas faite pour etre utilisee directement,
il vaut mieux s'en servir a travers <code><a title="laue.Experiment.find_subsets" href="../index.html#laue.Experiment.find_subsets">Experiment.find_subsets()</a></code>
ou encore via <code><a title="laue.diagram.LaueDiagram.find_subsets" href="#laue.core.subsets.Splitable.find_subsets">Splitable.find_subsets()</a></code> car le context
est mieu gere, les entrees sont plus simples et les sorties aussi.</li>
<li>Il n'y a pas de verifications sur les entrees car elles sont faite
dans les methodes de plus haut niveau.</li>
<li>Cette fonction n'est pas parallelisee. Par contre la methode
<code><a title="laue.Experiment.find_subsets" href="../index.html#laue.Experiment.find_subsets">Experiment.find_subsets()</a></code> gere nativement le parallelisme.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spots_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Une representation des spots et des information minimales
qui y sont raccrochees. Il doit prendre la forme suivante:
<code>{spot_ind: {"gnom": (x_gnom, y_gnom), "axes": {1, 3, ...}}, ...}</code></dd>
<dt><strong><code>axes_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Une representations des axes de zone. Doit etre de la forme:
<code>{axe_ind: {"polar": (theta, dist), "quality": .7, "spots": {1, 4, 5, 6}}, ...}</code></dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Doit au moins contenir les 3 champs <code>angle_max</code>, <code>spots_max</code> et <code>distance_max</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Chaque element est un ensemble d'indice de spot appartenant au meme grain.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; spots_dict = {0: {'gnom': (0.3136510725564478, -0.44091934214920697), 'axes': set()},
...               1: {'gnom': (0.3092269223801162, -0.3703963974694111), 'axes': {0}},
...               2: {'gnom': (0.29464954430652696, 0.39670741889986955), 'axes': {1}},
...               3: {'gnom': (0.30191318963902786, 0.011759364157261544), 'axes': {2}},
...               4: {'gnom': (0.2656586060012433, -0.29892567761860783), 'axes': {0}},
...               5: {'gnom': (0.2537441830952802, 0.32256757073867776), 'axes': {1}},
...               6: {'gnom': (0.259687191990358, 0.011094867051531301), 'axes': {2}},
...               7: {'gnom': (0.21447480004378858, -0.2150686716681864), 'axes': {0}},
...               8: {'gnom': (0.2057015738443993, 0.2356420984106664), 'axes': {1}},
...               9: {'gnom': (0.09095514707222462, -0.5356714822419564), 'axes': {3, 4}},
...               10: {'gnom': (0.06846289051965272, 0.5548594993575858), 'axes': {3, 5}},
...               11: {'gnom': (0.16685972592987006, -0.1362785647833782), 'axes': {0}},
...               12: {'gnom': (0.16092652407854113, 0.15424696872260854), 'axes': {1}},
...               13: {'gnom': (0.0880179013812851, -0.40043047804756454), 'axes': {3}},
...               14: {'gnom': (0.07130573600458438, 0.4174843621463065), 'axes': {3}},
...               15: {'gnom': (0.08639048300887514, -0.31911672107326594), 'axes': {3}},
...               16: {'gnom': (0.07308383568548608, 0.3351760458933546), 'axes': {3}},
...               17: {'gnom': (-0.016567440130016563, -0.5541568143935384), 'axes': {6}},
...               18: {'gnom': (-0.04084781468303007, 0.5689448068249144), 'axes': {7}},
...               19: {'gnom': (0.0011982188252073992, -0.45016007120047424), 'axes': set()},
...               20: {'gnom': (-0.018154025485441625, 0.46402526754308027), 'axes': set()},
...               21: {'gnom': (-0.07286049562681773, -0.5640133440412382), 'axes': set()},
...               22: {'gnom': (0.0798366324753105, 0.007023938379407561), 'axes': {0, 1, 2, 3}},
...               23: {'gnom': (-0.0026903259324252246, 0.3921879524265071), 'axes': {5}},
...               24: {'gnom': (-0.09784778756977644, 0.5766271192972883), 'axes': set()},
...               25: {'gnom': (0.008002458469782677, -0.12293574282766238), 'axes': {1}},
...               26: {'gnom': (0.0027460490484708115, 0.13394781189060836), 'axes': {0}},
...               27: {'gnom': (-0.00523750349077013, -0.1470394198008183), 'axes': {1}},
...               28: {'gnom': (-0.011614516626281228, 0.15777148638160254), 'axes': {0}},
...               29: {'gnom': (-0.02477598980567221, -0.1823836791494654), 'axes': {1}},
...               30: {'gnom': (-0.03264505249777272, 0.19229497060446735), 'axes': {0}},
...               31: {'gnom': (-0.05554717740227801, -0.23832176191125093), 'axes': {1, 4}},
...               32: {'gnom': (-0.06606796372263056, 0.24757266647939288), 'axes': {0, 5}},
...               33: {'gnom': (-0.07907768658950604, -0.28096918114364355), 'axes': {1}},
...               34: {'gnom': (-0.09156428823859053, 0.2893970244445073), 'axes': {0}},
...               35: {'gnom': (-0.1126289846318788, -0.3416241560303849), 'axes': {1, 6}},
...               36: {'gnom': (-0.060637577826655534, 0.0040391083212410655), 'axes': {2}},
...               37: {'gnom': (-0.12787900102974828, 0.3491863530719953), 'axes': {0, 7}},
...               38: {'gnom': (-0.1638208798822865, -0.4347286698438957), 'axes': {1}},
...               39: {'gnom': (-0.18763951100210385, -0.4776573606384503), 'axes': {1}},
...               40: {'gnom': (-0.1835787305562983, 0.4411739247300923), 'axes': {0}},
...               41: {'gnom': (-0.08524649743749545, 0.003436523504335945), 'axes': {2}},
...               42: {'gnom': (-0.2523542667003644, -0.5949096601292776), 'axes': {8, 1}},
...               43: {'gnom': (-0.20958039716029048, 0.4837711867805186), 'axes': {0}},
...               44: {'gnom': (-0.11758167206566646, -0.1123768702642382), 'axes': {4}},
...               45: {'gnom': (-0.12266805447587614, 0.11817207059217111), 'axes': {5}},
...               46: {'gnom': (-0.17376685735949005, 0.0016472083664571353), 'axes': {2, 4, 5}},
...               47: {'gnom': (-0.20724297206742168, -0.25150647771157364), 'axes': set()},
...               48: {'gnom': (-0.19501092265693473, -0.15910834995174863), 'axes': {6}},
...               49: {'gnom': (-0.21870028043714163, 0.25404867230414246), 'axes': set()},
...               50: {'gnom': (-0.2022799134764107, 0.16163477331619278), 'axes': {7}},
...               51: {'gnom': (-0.2581018757728966, -0.3579924435989167), 'axes': {8}},
...               52: {'gnom': (-0.2748170617964089, 0.3596407013965223), 'axes': {8}},
...               53: {'gnom': (-0.21290266125204668, 0.0008346770568725252), 'axes': {2}},
...               54: {'gnom': (-0.21986841578944072, -0.10369811043407293), 'axes': {5, 6}},
...               55: {'gnom': (-0.224622744015843, 0.10503684334781563), 'axes': {4, 7}},
...               56: {'gnom': (-0.25955409478645797, -0.29848728294016463), 'axes': {8}},
...               57: {'gnom': (-0.27338619051240226, 0.299389601118816), 'axes': {8}},
...               58: {'gnom': (-0.3156632165624574, -0.4202358686963255), 'axes': set()},
...               59: {'gnom': (-0.2618304221414466, -0.19929059589121062), 'axes': {8, 5}},
...               60: {'gnom': (-0.2711073666720387, 0.1994839074523256), 'axes': {8, 4}},
...               61: {'gnom': (-0.2637120677768278, -0.11984479170021081), 'axes': {8}},
...               62: {'gnom': (-0.26934469418071083, 0.11943958616023759), 'axes': {8}},
...               63: {'gnom': (-0.26653796331705015, -0.00040349411462381246), 'axes': {8, 2, 6, 7}},
...               64: {'gnom': (-0.3351088299984176, -0.36661822106768144), 'axes': {5}},
...               65: {'gnom': (-0.30919293226499917, -0.22782988778598667), 'axes': set()},
...               66: {'gnom': (-0.3524825023650732, 0.3647641920521141), 'axes': {4}},
...               67: {'gnom': (-0.31990969642322137, 0.22611752961083748), 'axes': set()},
...               68: {'gnom': (-0.3144023520521512, -0.0013698968940222644), 'axes': {2}},
...               69: {'gnom': (-0.3223772542169661, -0.14153279317889217), 'axes': {7}},
...               70: {'gnom': (-0.3290872223583307, 0.13867490378055763), 'axes': {6}},
...               71: {'gnom': (-0.34380505280556134, -0.0019232844125064402), 'axes': {2}},
...               72: {'gnom': (-0.3716527272451695, -0.2655541496297943), 'axes': {7}},
...               73: {'gnom': (-0.384382394518522, 0.26137948985364423), 'axes': {6}},
...               74: {'gnom': (-0.4150393355485816, -0.37556396956837046), 'axes': {7}},
...               75: {'gnom': (-0.4213116259525938, -0.1277995546595711), 'axes': set()},
...               76: {'gnom': (-0.42743697409652126, 0.12091462467337603), 'axes': set()},
...               77: {'gnom': (-0.4305672928685682, -0.10207732996277492), 'axes': set()}}
&gt;&gt;&gt; axes_dict = {0: {'polar': (0.5456325, 0.07189146), 'quality': 0.7786729549943984, 'spots': {32, 1, 34, 4, 37, 7, 40, 11, 43, 22, 26, 28, 30}},
...              1: {'polar': (-0.50404394, 0.066435024), 'quality': 0.8495679649229442, 'spots': {33, 2, 35, 5, 38, 39, 8, 42, 12, 22, 25, 27, 29, 31}},
...              2: {'polar': (1.5920126, 0.0053436677), 'quality': 0.5048333500772214, 'spots': {3, 36, 68, 6, 71, 41, 46, 53, 22, 63}},
...              3: {'polar': (0.020630987, 0.07989738), 'quality': 0.32446216058045907, 'spots': {9, 10, 13, 14, 15, 16, 22}},
...              4: {'polar': (-2.6840417, 0.15513226), 'quality': 0.32470155528405464, 'spots': {66, 9, 44, 46, 55, 60, 31}},
...              5: {'polar': (2.7287471, 0.15980783), 'quality': 0.36693478788694234, 'spots': {32, 64, 10, 45, 46, 54, 23, 59}},
...              6: {'polar': (-2.7180853, 0.24310948), 'quality': 0.324204821510315, 'spots': {35, 70, 73, 48, 17, 54, 63}},
...              7: {'polar': (2.7643242, 0.24759501), 'quality': 0.3668147624332471, 'spots': {69, 37, 72, 74, 18, 50, 55, 63}},
...              8: {'polar': (-3.118213, 0.26645306), 'quality': 0.5046664108258551, 'spots': {42, 51, 52, 56, 57, 59, 60, 61, 62, 63}}}
&gt;&gt;&gt; kwargs = {'angle_max': 0.1308996938995747, 'spots_max': 20, 'distance_max': 0.08}
&gt;&gt;&gt; laue.atomic_find_subsets(spots_dict, axes_dict, **kwargs)
[{9, 10, 22}]
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_find_subsets(spots_dict, axes_dict, **kwargs):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de separation de grains. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.Experiment.find_subsets``
    ou encore via ``laue.diagram.LaueDiagram.find_subsets`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.Experiment.find_subsets`` gere nativement le parallelisme.

    Parameters
    ----------
    spots_dict : dict
        Une representation des spots et des information minimales
        qui y sont raccrochees. Il doit prendre la forme suivante:
        ``{spot_ind: {&#34;gnom&#34;: (x_gnom, y_gnom), &#34;axes&#34;: {1, 3, ...}}, ...}``
    axes_dict : dict
        Une representations des axes de zone. Doit etre de la forme:
        ``{axe_ind: {&#34;polar&#34;: (theta, dist), &#34;quality&#34;: .7, &#34;spots&#34;: {1, 4, 5, 6}}, ...}``
    **kwargs
        Doit au moins contenir les 3 champs ``angle_max``, ``spots_max`` et ``distance_max``.

    Returns
    -------
    list
        Chaque element est un ensemble d&#39;indice de spot appartenant au meme grain.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; spots_dict = {0: {&#39;gnom&#39;: (0.3136510725564478, -0.44091934214920697), &#39;axes&#39;: set()},
    ...               1: {&#39;gnom&#39;: (0.3092269223801162, -0.3703963974694111), &#39;axes&#39;: {0}},
    ...               2: {&#39;gnom&#39;: (0.29464954430652696, 0.39670741889986955), &#39;axes&#39;: {1}},
    ...               3: {&#39;gnom&#39;: (0.30191318963902786, 0.011759364157261544), &#39;axes&#39;: {2}},
    ...               4: {&#39;gnom&#39;: (0.2656586060012433, -0.29892567761860783), &#39;axes&#39;: {0}},
    ...               5: {&#39;gnom&#39;: (0.2537441830952802, 0.32256757073867776), &#39;axes&#39;: {1}},
    ...               6: {&#39;gnom&#39;: (0.259687191990358, 0.011094867051531301), &#39;axes&#39;: {2}},
    ...               7: {&#39;gnom&#39;: (0.21447480004378858, -0.2150686716681864), &#39;axes&#39;: {0}},
    ...               8: {&#39;gnom&#39;: (0.2057015738443993, 0.2356420984106664), &#39;axes&#39;: {1}},
    ...               9: {&#39;gnom&#39;: (0.09095514707222462, -0.5356714822419564), &#39;axes&#39;: {3, 4}},
    ...               10: {&#39;gnom&#39;: (0.06846289051965272, 0.5548594993575858), &#39;axes&#39;: {3, 5}},
    ...               11: {&#39;gnom&#39;: (0.16685972592987006, -0.1362785647833782), &#39;axes&#39;: {0}},
    ...               12: {&#39;gnom&#39;: (0.16092652407854113, 0.15424696872260854), &#39;axes&#39;: {1}},
    ...               13: {&#39;gnom&#39;: (0.0880179013812851, -0.40043047804756454), &#39;axes&#39;: {3}},
    ...               14: {&#39;gnom&#39;: (0.07130573600458438, 0.4174843621463065), &#39;axes&#39;: {3}},
    ...               15: {&#39;gnom&#39;: (0.08639048300887514, -0.31911672107326594), &#39;axes&#39;: {3}},
    ...               16: {&#39;gnom&#39;: (0.07308383568548608, 0.3351760458933546), &#39;axes&#39;: {3}},
    ...               17: {&#39;gnom&#39;: (-0.016567440130016563, -0.5541568143935384), &#39;axes&#39;: {6}},
    ...               18: {&#39;gnom&#39;: (-0.04084781468303007, 0.5689448068249144), &#39;axes&#39;: {7}},
    ...               19: {&#39;gnom&#39;: (0.0011982188252073992, -0.45016007120047424), &#39;axes&#39;: set()},
    ...               20: {&#39;gnom&#39;: (-0.018154025485441625, 0.46402526754308027), &#39;axes&#39;: set()},
    ...               21: {&#39;gnom&#39;: (-0.07286049562681773, -0.5640133440412382), &#39;axes&#39;: set()},
    ...               22: {&#39;gnom&#39;: (0.0798366324753105, 0.007023938379407561), &#39;axes&#39;: {0, 1, 2, 3}},
    ...               23: {&#39;gnom&#39;: (-0.0026903259324252246, 0.3921879524265071), &#39;axes&#39;: {5}},
    ...               24: {&#39;gnom&#39;: (-0.09784778756977644, 0.5766271192972883), &#39;axes&#39;: set()},
    ...               25: {&#39;gnom&#39;: (0.008002458469782677, -0.12293574282766238), &#39;axes&#39;: {1}},
    ...               26: {&#39;gnom&#39;: (0.0027460490484708115, 0.13394781189060836), &#39;axes&#39;: {0}},
    ...               27: {&#39;gnom&#39;: (-0.00523750349077013, -0.1470394198008183), &#39;axes&#39;: {1}},
    ...               28: {&#39;gnom&#39;: (-0.011614516626281228, 0.15777148638160254), &#39;axes&#39;: {0}},
    ...               29: {&#39;gnom&#39;: (-0.02477598980567221, -0.1823836791494654), &#39;axes&#39;: {1}},
    ...               30: {&#39;gnom&#39;: (-0.03264505249777272, 0.19229497060446735), &#39;axes&#39;: {0}},
    ...               31: {&#39;gnom&#39;: (-0.05554717740227801, -0.23832176191125093), &#39;axes&#39;: {1, 4}},
    ...               32: {&#39;gnom&#39;: (-0.06606796372263056, 0.24757266647939288), &#39;axes&#39;: {0, 5}},
    ...               33: {&#39;gnom&#39;: (-0.07907768658950604, -0.28096918114364355), &#39;axes&#39;: {1}},
    ...               34: {&#39;gnom&#39;: (-0.09156428823859053, 0.2893970244445073), &#39;axes&#39;: {0}},
    ...               35: {&#39;gnom&#39;: (-0.1126289846318788, -0.3416241560303849), &#39;axes&#39;: {1, 6}},
    ...               36: {&#39;gnom&#39;: (-0.060637577826655534, 0.0040391083212410655), &#39;axes&#39;: {2}},
    ...               37: {&#39;gnom&#39;: (-0.12787900102974828, 0.3491863530719953), &#39;axes&#39;: {0, 7}},
    ...               38: {&#39;gnom&#39;: (-0.1638208798822865, -0.4347286698438957), &#39;axes&#39;: {1}},
    ...               39: {&#39;gnom&#39;: (-0.18763951100210385, -0.4776573606384503), &#39;axes&#39;: {1}},
    ...               40: {&#39;gnom&#39;: (-0.1835787305562983, 0.4411739247300923), &#39;axes&#39;: {0}},
    ...               41: {&#39;gnom&#39;: (-0.08524649743749545, 0.003436523504335945), &#39;axes&#39;: {2}},
    ...               42: {&#39;gnom&#39;: (-0.2523542667003644, -0.5949096601292776), &#39;axes&#39;: {8, 1}},
    ...               43: {&#39;gnom&#39;: (-0.20958039716029048, 0.4837711867805186), &#39;axes&#39;: {0}},
    ...               44: {&#39;gnom&#39;: (-0.11758167206566646, -0.1123768702642382), &#39;axes&#39;: {4}},
    ...               45: {&#39;gnom&#39;: (-0.12266805447587614, 0.11817207059217111), &#39;axes&#39;: {5}},
    ...               46: {&#39;gnom&#39;: (-0.17376685735949005, 0.0016472083664571353), &#39;axes&#39;: {2, 4, 5}},
    ...               47: {&#39;gnom&#39;: (-0.20724297206742168, -0.25150647771157364), &#39;axes&#39;: set()},
    ...               48: {&#39;gnom&#39;: (-0.19501092265693473, -0.15910834995174863), &#39;axes&#39;: {6}},
    ...               49: {&#39;gnom&#39;: (-0.21870028043714163, 0.25404867230414246), &#39;axes&#39;: set()},
    ...               50: {&#39;gnom&#39;: (-0.2022799134764107, 0.16163477331619278), &#39;axes&#39;: {7}},
    ...               51: {&#39;gnom&#39;: (-0.2581018757728966, -0.3579924435989167), &#39;axes&#39;: {8}},
    ...               52: {&#39;gnom&#39;: (-0.2748170617964089, 0.3596407013965223), &#39;axes&#39;: {8}},
    ...               53: {&#39;gnom&#39;: (-0.21290266125204668, 0.0008346770568725252), &#39;axes&#39;: {2}},
    ...               54: {&#39;gnom&#39;: (-0.21986841578944072, -0.10369811043407293), &#39;axes&#39;: {5, 6}},
    ...               55: {&#39;gnom&#39;: (-0.224622744015843, 0.10503684334781563), &#39;axes&#39;: {4, 7}},
    ...               56: {&#39;gnom&#39;: (-0.25955409478645797, -0.29848728294016463), &#39;axes&#39;: {8}},
    ...               57: {&#39;gnom&#39;: (-0.27338619051240226, 0.299389601118816), &#39;axes&#39;: {8}},
    ...               58: {&#39;gnom&#39;: (-0.3156632165624574, -0.4202358686963255), &#39;axes&#39;: set()},
    ...               59: {&#39;gnom&#39;: (-0.2618304221414466, -0.19929059589121062), &#39;axes&#39;: {8, 5}},
    ...               60: {&#39;gnom&#39;: (-0.2711073666720387, 0.1994839074523256), &#39;axes&#39;: {8, 4}},
    ...               61: {&#39;gnom&#39;: (-0.2637120677768278, -0.11984479170021081), &#39;axes&#39;: {8}},
    ...               62: {&#39;gnom&#39;: (-0.26934469418071083, 0.11943958616023759), &#39;axes&#39;: {8}},
    ...               63: {&#39;gnom&#39;: (-0.26653796331705015, -0.00040349411462381246), &#39;axes&#39;: {8, 2, 6, 7}},
    ...               64: {&#39;gnom&#39;: (-0.3351088299984176, -0.36661822106768144), &#39;axes&#39;: {5}},
    ...               65: {&#39;gnom&#39;: (-0.30919293226499917, -0.22782988778598667), &#39;axes&#39;: set()},
    ...               66: {&#39;gnom&#39;: (-0.3524825023650732, 0.3647641920521141), &#39;axes&#39;: {4}},
    ...               67: {&#39;gnom&#39;: (-0.31990969642322137, 0.22611752961083748), &#39;axes&#39;: set()},
    ...               68: {&#39;gnom&#39;: (-0.3144023520521512, -0.0013698968940222644), &#39;axes&#39;: {2}},
    ...               69: {&#39;gnom&#39;: (-0.3223772542169661, -0.14153279317889217), &#39;axes&#39;: {7}},
    ...               70: {&#39;gnom&#39;: (-0.3290872223583307, 0.13867490378055763), &#39;axes&#39;: {6}},
    ...               71: {&#39;gnom&#39;: (-0.34380505280556134, -0.0019232844125064402), &#39;axes&#39;: {2}},
    ...               72: {&#39;gnom&#39;: (-0.3716527272451695, -0.2655541496297943), &#39;axes&#39;: {7}},
    ...               73: {&#39;gnom&#39;: (-0.384382394518522, 0.26137948985364423), &#39;axes&#39;: {6}},
    ...               74: {&#39;gnom&#39;: (-0.4150393355485816, -0.37556396956837046), &#39;axes&#39;: {7}},
    ...               75: {&#39;gnom&#39;: (-0.4213116259525938, -0.1277995546595711), &#39;axes&#39;: set()},
    ...               76: {&#39;gnom&#39;: (-0.42743697409652126, 0.12091462467337603), &#39;axes&#39;: set()},
    ...               77: {&#39;gnom&#39;: (-0.4305672928685682, -0.10207732996277492), &#39;axes&#39;: set()}}
    &gt;&gt;&gt; axes_dict = {0: {&#39;polar&#39;: (0.5456325, 0.07189146), &#39;quality&#39;: 0.7786729549943984, &#39;spots&#39;: {32, 1, 34, 4, 37, 7, 40, 11, 43, 22, 26, 28, 30}},
    ...              1: {&#39;polar&#39;: (-0.50404394, 0.066435024), &#39;quality&#39;: 0.8495679649229442, &#39;spots&#39;: {33, 2, 35, 5, 38, 39, 8, 42, 12, 22, 25, 27, 29, 31}},
    ...              2: {&#39;polar&#39;: (1.5920126, 0.0053436677), &#39;quality&#39;: 0.5048333500772214, &#39;spots&#39;: {3, 36, 68, 6, 71, 41, 46, 53, 22, 63}},
    ...              3: {&#39;polar&#39;: (0.020630987, 0.07989738), &#39;quality&#39;: 0.32446216058045907, &#39;spots&#39;: {9, 10, 13, 14, 15, 16, 22}},
    ...              4: {&#39;polar&#39;: (-2.6840417, 0.15513226), &#39;quality&#39;: 0.32470155528405464, &#39;spots&#39;: {66, 9, 44, 46, 55, 60, 31}},
    ...              5: {&#39;polar&#39;: (2.7287471, 0.15980783), &#39;quality&#39;: 0.36693478788694234, &#39;spots&#39;: {32, 64, 10, 45, 46, 54, 23, 59}},
    ...              6: {&#39;polar&#39;: (-2.7180853, 0.24310948), &#39;quality&#39;: 0.324204821510315, &#39;spots&#39;: {35, 70, 73, 48, 17, 54, 63}},
    ...              7: {&#39;polar&#39;: (2.7643242, 0.24759501), &#39;quality&#39;: 0.3668147624332471, &#39;spots&#39;: {69, 37, 72, 74, 18, 50, 55, 63}},
    ...              8: {&#39;polar&#39;: (-3.118213, 0.26645306), &#39;quality&#39;: 0.5046664108258551, &#39;spots&#39;: {42, 51, 52, 56, 57, 59, 60, 61, 62, 63}}}
    &gt;&gt;&gt; kwargs = {&#39;angle_max&#39;: 0.1308996938995747, &#39;spots_max&#39;: 20, &#39;distance_max&#39;: 0.08}
    &gt;&gt;&gt; laue.atomic_find_subsets(spots_dict, axes_dict, **kwargs)
    [{9, 10, 22}]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.zone_axis import distance as distance_axis
    from laue.spot import distance as distance_pic
    import networkx

    def count_variant_axis(spot_id):
        &#34;&#34;&#34;
        Compte le nombre d&#39;axes de zone qui different beaucoup.
        (ie considere 2 axes proche comme un seul axe)
        &#34;&#34;&#34;
        axes_id = spots_dict[spot_id][&#34;axes&#34;]
        if len(axes_id) &lt;= 1:
            return len(axes_id)
        axes = [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes_id]
        nbr_near = (distance_axis(axes, axes, weight=1) &lt; kwargs[&#34;angle_max&#34;]).sum()
        nbr = len(axes) - (nbr_near-len(axes))//2
        return nbr

    def simul_remove_axis(graph, axis, excluded):
        &#34;&#34;&#34;
        Retire les aretes liees a cet axe, puis regarde ce que ca donne.
        &#34;&#34;&#34;
        graph_bis = graph.copy()
        for spot1, spot2, axis_found in graph.edges.data(&#34;axis&#34;):
            if axis_found is axis:
                graph_bis.remove_edge(spot1, spot2)
        excluded_bis = [edge for edge in excluded if networkx.algorithms.has_path(graph_bis, *edge)]
        return excluded_bis, graph_bis

    # Extraction des spots.
    spots_at_cross = sorted(spots_dict, key=count_variant_axis, reverse=True)[:kwargs[&#34;spots_max&#34;]]
    max_cross = count_variant_axis(spots_at_cross[0])
    limit = math.sqrt(max(2**2, max_cross)) # Permet d&#39;eviter &#39;ValueError: math domain error&#39;
    spots_at_cross = [spot_id for spot_id in spots_at_cross if count_variant_axis(spot_id) &gt;= limit]

    # Creation des noeuds du graphe.
    graph = networkx.Graph()
    graph.add_nodes_from(spots_at_cross)

    # Ajout grossier de certaine aretes.
    excluded = [] # La liste des noeuds appartenant a des grains differents.
    candidate_axes = set() # L&#39;ensemble des axes de zone consideres.
    for i, spot1 in enumerate(spots_at_cross[:-1]): # On faite toutes les combinaisons
        for spot2 in spots_at_cross[i+1:]: # de 2 sommets possibles.

            ## Exclusion des spots trop proches.
            if distance_pic(
                    spots_dict[spot1][&#34;gnom&#34;],
                    spots_dict[spot2][&#34;gnom&#34;],
                    space=&#34;gnomonic&#34;
                    ) &lt; kwargs[&#34;distance_max&#34;]:
                excluded.append((spot1, spot2))
                continue

            ## On ne relie pas les spots qui n&#39;ont pas d&#39;axe commun.
            common_axes = spots_dict[spot1][&#34;axes&#34;] &amp; spots_dict[spot2][&#34;axes&#34;]
            if not common_axes:
                continue

            ## Exclusion des spots ayant 2 axes de zone paralleles.
            axes1, axes2 = spots_dict[spot1][&#34;axes&#34;]-common_axes, spots_dict[spot2][&#34;axes&#34;]-common_axes
            if axes1 and axes2 and distance_axis(
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes1],
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes2],
                    weight=1).min() &lt; kwargs[&#34;angle_max&#34;]: # tolerance angulaire de pi/32
                excluded.append((spot1, spot2))
                continue

            ## Ajout dans le graphe.
            best_axis = sorted(common_axes, key=lambda axis_id: axes_dict[axis_id][&#34;quality&#34;])[-1]
            candidate_axes.add(best_axis)
            graph.add_edge(spot1, spot2, quality=axes_dict[best_axis][&#34;quality&#34;], axis=best_axis)

    # Suppression des aretes en trop afin de discosier les grains.
    excluded = [edge for edge in excluded if networkx.algorithms.has_path(graph, *edge)]
    while excluded:
        predictions = [(*simul_remove_axis(graph, axis_id, excluded), axis_id) for axis_id in candidate_axes]
        best_len = min(len(excluded_bis) for excluded_bis, _, _ in predictions)
        predictions = [p for p in predictions if len(p[0]) == best_len]
        costs = [axes_dict[axis_id][&#34;quality&#34;] for _, _, axis_id in predictions]
        min_quality = min(costs)
        predictions = [p for p in predictions if axes_dict[p[2]][&#34;quality&#34;] == min_quality]
        excluded, graph, axis_id = predictions.pop()
        candidate_axes.remove(axis_id)

    # Creation des clusters.
    subsets = list(networkx.algorithms.connected_components(graph))
    subsets = sorted(subsets, key=lambda con: len(con), reverse=True)
    subsets = [con for con in subsets if len(con) &gt;= 2]
    return subsets</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laue.core.subsets.Splitable"><code class="flex name class">
<span>class <span class="ident">Splitable</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface pour la classe <code><a title="laue.diagram.LaueDiagram" href="../diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Splitable:
    &#34;&#34;&#34;
    Interface pour la classe ``laue.diagram.LaueDiagram``.
    &#34;&#34;&#34;
    def find_subsets(self, *, angle_max=math.pi/24, spots_max=20, distance_max=.08,
        _atomic_subsets_res=None, _get_args=False):
        &#34;&#34;&#34;
        ** Recherche des spots qui appartiennent a un meme grain. **

        L&#39;algorithme est le suivant:

        - Creation d&#39;un graphe dont les somets sont des spots.
            - Selection des spots interressants.
                - Selection des spots qui sont a des intersection d&#39;axes de zone.
                - Trie des spots par nombre d&#39;axes de zone decroissant.
                - Selection des ``spots_max`` spots qui intersectent suffisement d&#39;axes.
            - Creation des aretes.
                - Pour chaque paire de somets (paire de spots).
                    - Si il sont lies par un axe de zone.
                        - Alors on les relie avec une arete dont le poid est la
                        qualite du meilleur axe de zone qui passe par ces 2 spots.
        - Supression de certaines aretes.
            - Reperage des paires de spots qui apartiennent a des grains differents.
                - Pour chaque paire de somets (paire de spots).
                    - Si les 2 spots sont trop proche (distance &lt; ``distance_max``).
                        - Alors on repere cette paire de spots.
                    - Si par ces 2 spots passe 2 axes de zone angulairement &lt; ``angle_max``.
                        - Alors on repere cette paire de spots.
            - Tant qu&#39;il existe au moin un chemin permetant de relier une paire de spots marque.
                - On cherche l&#39;arete qui, si on l&#39;a retire, permet de reduire le plus fortement
                le nombre de paire de somet marque qui sont encore relies.
                - Parmis les aretes quandidates, on supprime celle qui est lie a l&#39;axe de
                zone de plus mauvaise qualite.
        - Creation des clusters.
            - On extrait toutes les composantes conexes du graphe.
            - On elimine les composantes qui ne contienent qu&#39;un seul sommet.
            - **return** les composantes conexes restantes.

        Notes
        -----
        Les spots trouves sont souvent des spots ayant un indice de Miller
        relativement faible.

        Returns
        -------
        list
            Chaque element est un &#39;cluster&#39; de spots qui ont une forte probabilite
            d&#39;appartenir a un meme grain. Par contre, il n&#39;y a aucune garantie
            que 2 clusters appartienent chacuns a 2 grains differents.
            Les cluster sont des ``set`` de spot de type ``laue.spot.Spot``.

        Parameters
        ----------
        angle_max : float
            L&#39;angle maximal entre 2 axes de zones. (en radian)
            Si par un spot, il passe 2 axes de zonnes angulairement plus seres
            que cet angle limite, alors ces 2 axes ne sont comptes que comme 1 seul.
            en consequence, plus cet angle est grand, moins on est selectif sur les spots.
            Ce meme angle intervient ailleur. Si il existe 2 axes de zones passants chacuns
            par un spots differents, que ces 2 axes sont angulairement plus sere
            que ``angle_max``, et que ces 2 spots sont relies par un autre axe de zone,
            alors ces 2 spots se retrouveront dans des clusters differents.
        spots_max : int
            Le nombre maximum total de spots consideres. Plus ce nombre est grand
            plus il y a des chance qu&#39;il y ai une solution mais moins cette solution
            aura des chances d&#39;etre pertinante. Le temps de calcul est aussi quadratiquement
            lie au nombre de sommets.
        distance_max : float
            2 spots qui sont separes d&#39;une distance inferieure a ce parametre se retrouveront
            dans des clusters differents. Cette distance est la distance euclidiene du plan
            gnomonic (en mm).

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; diag = next(iter(laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)))
        &gt;&gt;&gt; type(diag.find_subsets())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; len(diag.find_subsets()) # nbr de clusters
        1
        &gt;&gt;&gt; type(diag.find_subsets().pop())
        &lt;class &#39;set&#39;&gt;
        &gt;&gt;&gt; len(diag.find_subsets().pop()) # nbr de spot dans le premier cluster
        3
        &gt;&gt;&gt; type(diag.find_subsets().pop().pop())
        &lt;class &#39;laue.spot.Spot&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(angle_max, float), \
            f&#34;&#39;angle_max&#39; has to be a float, not a {type(angle_max).__name__}.&#34;
        assert isinstance(spots_max, int), \
            f&#34;&#39;spots_max&#39; has to be an integer, not a {type(spots_max).__name__}.&#34;
        assert isinstance(distance_max, float), \
            f&#34;&#39;distance_max&#39; has to be of type float, not {type(distance_max).__name__}.&#34;
        assert 0 &lt; angle_max &lt;= math.pi/4, (&#34;L&#39;angle doit etre exprime en radian. &#34;
            f&#34;Il doit etre dans l&#39;intervalle ]0, pi/4]. Or il vaut {angle_max}.&#34;)
        assert 2 &lt;= spots_max, \
            f&#34;Il faut au moins considerer 2 spots, {spots_max} c&#39;est pas possible.&#34;
        assert 0 &lt; distance_max &lt; .3, (&#34;La distance de sepration des grains est exprimee &#34;
            &#34;en mm dans le plan gnomonic. Elle doit etre comprise entre ]0, .3]. &#34;
            f&#34;Or elle vaut {distance_max}, ce qui sort de cet intervalle.&#34;)

        args = _get_spots_axes(self)
        config = dict(angle_max=angle_max,
                      spots_max=spots_max,
                      distance_max=distance_max)
        if _get_args: # Si il faut seulement preparer le travail.
            return args, config

        if _atomic_subsets_res is None: # Si il faut faire les calculs.
            _atomic_subsets_res = atomic_find_subsets(*args, **config)
        
        subsets = [{self[spot_id] for spot_id in subset} for subset in _atomic_subsets_res]
        return subsets</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="laue.diagram.LaueDiagram" href="../diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laue.core.subsets.Splitable.find_subsets"><code class="name flex">
<span>def <span class="ident">find_subsets</span></span>(<span>self, *, angle_max=0.1308996938995747, spots_max=20, distance_max=0.08)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recherche des spots qui appartiennent a un meme grain. </strong></p>
<p>L'algorithme est le suivant:</p>
<ul>
<li>Creation d'un graphe dont les somets sont des spots.<ul>
<li>Selection des spots interressants.<ul>
<li>Selection des spots qui sont a des intersection d'axes de zone.</li>
<li>Trie des spots par nombre d'axes de zone decroissant.</li>
<li>Selection des <code>spots_max</code> spots qui intersectent suffisement d'axes.</li>
</ul>
</li>
<li>Creation des aretes.<ul>
<li>Pour chaque paire de somets (paire de spots).<ul>
<li>Si il sont lies par un axe de zone.<ul>
<li>Alors on les relie avec une arete dont le poid est la
qualite du meilleur axe de zone qui passe par ces 2 spots.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Supression de certaines aretes.<ul>
<li>Reperage des paires de spots qui apartiennent a des grains differents.<ul>
<li>Pour chaque paire de somets (paire de spots).<ul>
<li>Si les 2 spots sont trop proche (distance &lt; <code>distance_max</code>).<ul>
<li>Alors on repere cette paire de spots.</li>
</ul>
</li>
<li>Si par ces 2 spots passe 2 axes de zone angulairement &lt; <code>angle_max</code>.<ul>
<li>Alors on repere cette paire de spots.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Tant qu'il existe au moin un chemin permetant de relier une paire de spots marque.<ul>
<li>On cherche l'arete qui, si on l'a retire, permet de reduire le plus fortement
le nombre de paire de somet marque qui sont encore relies.</li>
<li>Parmis les aretes quandidates, on supprime celle qui est lie a l'axe de
zone de plus mauvaise qualite.</li>
</ul>
</li>
</ul>
</li>
<li>Creation des clusters.<ul>
<li>On extrait toutes les composantes conexes du graphe.</li>
<li>On elimine les composantes qui ne contienent qu'un seul sommet.</li>
<li><strong>return</strong> les composantes conexes restantes.</li>
</ul>
</li>
</ul>
<h2 id="notes">Notes</h2>
<p>Les spots trouves sont souvent des spots ayant un indice de Miller
relativement faible.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Chaque element est un 'cluster' de spots qui ont une forte probabilite
d'appartenir a un meme grain. Par contre, il n'y a aucune garantie
que 2 clusters appartienent chacuns a 2 grains differents.
Les cluster sont des <code>set</code> de spot de type <code><a title="laue.spot.Spot" href="../spot.html#laue.spot.Spot">Spot</a></code>.</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle_max</code></strong> :&ensp;<code>float</code></dt>
<dd>L'angle maximal entre 2 axes de zones. (en radian)
Si par un spot, il passe 2 axes de zonnes angulairement plus seres
que cet angle limite, alors ces 2 axes ne sont comptes que comme 1 seul.
en consequence, plus cet angle est grand, moins on est selectif sur les spots.
Ce meme angle intervient ailleur. Si il existe 2 axes de zones passants chacuns
par un spots differents, que ces 2 axes sont angulairement plus sere
que <code>angle_max</code>, et que ces 2 spots sont relies par un autre axe de zone,
alors ces 2 spots se retrouveront dans des clusters differents.</dd>
<dt><strong><code>spots_max</code></strong> :&ensp;<code>int</code></dt>
<dd>Le nombre maximum total de spots consideres. Plus ce nombre est grand
plus il y a des chance qu'il y ai une solution mais moins cette solution
aura des chances d'etre pertinante. Le temps de calcul est aussi quadratiquement
lie au nombre de sommets.</dd>
<dt><strong><code>distance_max</code></strong> :&ensp;<code>float</code></dt>
<dd>2 spots qui sont separes d'une distance inferieure a ce parametre se retrouveront
dans des clusters differents. Cette distance est la distance euclidiene du plan
gnomonic (en mm).</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; diag = next(iter(laue.Experiment(image, config_file=&quot;laue/examples/ge_blanc.det&quot;)))
&gt;&gt;&gt; type(diag.find_subsets())
&lt;class 'list'&gt;
&gt;&gt;&gt; len(diag.find_subsets()) # nbr de clusters
1
&gt;&gt;&gt; type(diag.find_subsets().pop())
&lt;class 'set'&gt;
&gt;&gt;&gt; len(diag.find_subsets().pop()) # nbr de spot dans le premier cluster
3
&gt;&gt;&gt; type(diag.find_subsets().pop().pop())
&lt;class 'laue.spot.Spot'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_subsets(self, *, angle_max=math.pi/24, spots_max=20, distance_max=.08,
    _atomic_subsets_res=None, _get_args=False):
    &#34;&#34;&#34;
    ** Recherche des spots qui appartiennent a un meme grain. **

    L&#39;algorithme est le suivant:

    - Creation d&#39;un graphe dont les somets sont des spots.
        - Selection des spots interressants.
            - Selection des spots qui sont a des intersection d&#39;axes de zone.
            - Trie des spots par nombre d&#39;axes de zone decroissant.
            - Selection des ``spots_max`` spots qui intersectent suffisement d&#39;axes.
        - Creation des aretes.
            - Pour chaque paire de somets (paire de spots).
                - Si il sont lies par un axe de zone.
                    - Alors on les relie avec une arete dont le poid est la
                    qualite du meilleur axe de zone qui passe par ces 2 spots.
    - Supression de certaines aretes.
        - Reperage des paires de spots qui apartiennent a des grains differents.
            - Pour chaque paire de somets (paire de spots).
                - Si les 2 spots sont trop proche (distance &lt; ``distance_max``).
                    - Alors on repere cette paire de spots.
                - Si par ces 2 spots passe 2 axes de zone angulairement &lt; ``angle_max``.
                    - Alors on repere cette paire de spots.
        - Tant qu&#39;il existe au moin un chemin permetant de relier une paire de spots marque.
            - On cherche l&#39;arete qui, si on l&#39;a retire, permet de reduire le plus fortement
            le nombre de paire de somet marque qui sont encore relies.
            - Parmis les aretes quandidates, on supprime celle qui est lie a l&#39;axe de
            zone de plus mauvaise qualite.
    - Creation des clusters.
        - On extrait toutes les composantes conexes du graphe.
        - On elimine les composantes qui ne contienent qu&#39;un seul sommet.
        - **return** les composantes conexes restantes.

    Notes
    -----
    Les spots trouves sont souvent des spots ayant un indice de Miller
    relativement faible.

    Returns
    -------
    list
        Chaque element est un &#39;cluster&#39; de spots qui ont une forte probabilite
        d&#39;appartenir a un meme grain. Par contre, il n&#39;y a aucune garantie
        que 2 clusters appartienent chacuns a 2 grains differents.
        Les cluster sont des ``set`` de spot de type ``laue.spot.Spot``.

    Parameters
    ----------
    angle_max : float
        L&#39;angle maximal entre 2 axes de zones. (en radian)
        Si par un spot, il passe 2 axes de zonnes angulairement plus seres
        que cet angle limite, alors ces 2 axes ne sont comptes que comme 1 seul.
        en consequence, plus cet angle est grand, moins on est selectif sur les spots.
        Ce meme angle intervient ailleur. Si il existe 2 axes de zones passants chacuns
        par un spots differents, que ces 2 axes sont angulairement plus sere
        que ``angle_max``, et que ces 2 spots sont relies par un autre axe de zone,
        alors ces 2 spots se retrouveront dans des clusters differents.
    spots_max : int
        Le nombre maximum total de spots consideres. Plus ce nombre est grand
        plus il y a des chance qu&#39;il y ai une solution mais moins cette solution
        aura des chances d&#39;etre pertinante. Le temps de calcul est aussi quadratiquement
        lie au nombre de sommets.
    distance_max : float
        2 spots qui sont separes d&#39;une distance inferieure a ce parametre se retrouveront
        dans des clusters differents. Cette distance est la distance euclidiene du plan
        gnomonic (en mm).

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; diag = next(iter(laue.Experiment(image, config_file=&#34;laue/examples/ge_blanc.det&#34;)))
    &gt;&gt;&gt; type(diag.find_subsets())
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; len(diag.find_subsets()) # nbr de clusters
    1
    &gt;&gt;&gt; type(diag.find_subsets().pop())
    &lt;class &#39;set&#39;&gt;
    &gt;&gt;&gt; len(diag.find_subsets().pop()) # nbr de spot dans le premier cluster
    3
    &gt;&gt;&gt; type(diag.find_subsets().pop().pop())
    &lt;class &#39;laue.spot.Spot&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(angle_max, float), \
        f&#34;&#39;angle_max&#39; has to be a float, not a {type(angle_max).__name__}.&#34;
    assert isinstance(spots_max, int), \
        f&#34;&#39;spots_max&#39; has to be an integer, not a {type(spots_max).__name__}.&#34;
    assert isinstance(distance_max, float), \
        f&#34;&#39;distance_max&#39; has to be of type float, not {type(distance_max).__name__}.&#34;
    assert 0 &lt; angle_max &lt;= math.pi/4, (&#34;L&#39;angle doit etre exprime en radian. &#34;
        f&#34;Il doit etre dans l&#39;intervalle ]0, pi/4]. Or il vaut {angle_max}.&#34;)
    assert 2 &lt;= spots_max, \
        f&#34;Il faut au moins considerer 2 spots, {spots_max} c&#39;est pas possible.&#34;
    assert 0 &lt; distance_max &lt; .3, (&#34;La distance de sepration des grains est exprimee &#34;
        &#34;en mm dans le plan gnomonic. Elle doit etre comprise entre ]0, .3]. &#34;
        f&#34;Or elle vaut {distance_max}, ce qui sort de cet intervalle.&#34;)

    args = _get_spots_axes(self)
    config = dict(angle_max=angle_max,
                  spots_max=spots_max,
                  distance_max=distance_max)
    if _get_args: # Si il faut seulement preparer le travail.
        return args, config

    if _atomic_subsets_res is None: # Si il faut faire les calculs.
        _atomic_subsets_res = atomic_find_subsets(*args, **config)
    
    subsets = [{self[spot_id] for spot_id in subset} for subset in _atomic_subsets_res]
    return subsets</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#permet-de-separer-les-differents-grains-dun-diagramme">Permet de separer les differents grains d'un diagramme.</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laue.core" href="index.html">laue.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laue.core.subsets.atomic_find_subsets" href="#laue.core.subsets.atomic_find_subsets">atomic_find_subsets</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laue.core.subsets.Splitable" href="#laue.core.subsets.Splitable">Splitable</a></code></h4>
<ul class="">
<li><code><a title="laue.core.subsets.Splitable.find_subsets" href="#laue.core.subsets.Splitable.find_subsets">find_subsets</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>