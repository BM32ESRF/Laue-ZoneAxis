<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>laue.core API documentation</title>
<meta name="description" content="** Calculs de base de la separation de grains. **
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laue.core</code></h1>
</header>
<section id="section-intro">
<h2 id="calculs-de-base-de-la-separation-de-grains"><strong> Calculs de base de la separation de grains. </strong></h2>
<p>C'est ici que sont effectuees les gros calculs. La mise en forme
et le contexte n'est pas gere ici.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
** Calculs de base de la separation de grains. **
-------------------------------------------------

C&#39;est ici que sont effectuees les gros calculs. La mise en forme
et le contexte n&#39;est pas gere ici.
&#34;&#34;&#34;

import inspect

from .geometry import (cam_to_gnomonic, cam_to_thetachi,
    dist_cosine, dist_euclidian, dist_line, gnomonic_to_cam,
    gnomonic_to_thetachi, hough, hough_reduce, inter_lines,
    Transformer, comb2ind, ind2comb,
    thetachi_to_cam, thetachi_to_gnomonic)
from .pic_search import atomic_pic_search
from .subsets import atomic_find_subsets
from .zone_axes import atomic_find_zone_axes

__all__ = [
    # geometry
    &#34;cam_to_gnomonic&#34;, &#34;cam_to_thetachi&#34;, &#34;dist_cosine&#34;, &#34;dist_euclidian&#34;,
    &#34;dist_line&#34;, &#34;gnomonic_to_cam&#34;, &#34;gnomonic_to_thetachi&#34;, &#34;hough&#34;,
    &#34;hough_reduce&#34;, &#34;inter_lines&#34;, &#34;thetachi_to_cam&#34;, &#34;thetachi_to_gnomonic&#34;,
    &#34;Transformer&#34;, &#34;comb2ind&#34;, &#34;ind2comb&#34;,

    # pic_search
    &#34;atomic_pic_search&#34;,

    # subsets
    &#34;atomic_find_subsets&#34;,

    # zone_axes
    &#34;atomic_find_zone_axes&#34;]

__pdoc__ = {obj: (&#34;Alias vers ``laue.&#34;
                  f&#34;{inspect.getsourcefile(globals()[obj]).split(&#39;laue/&#39;)[-1][:-3].replace(&#39;/&#39;, &#39;.&#39;).replace(&#39;.__init__&#39;, &#39;&#39;)}&#34;
                  f&#34;.{obj}``&#34;)
            for obj in __all__}
__pdoc__ = {**__pdoc__, **{f&#34;{cl}.{meth}&#34;: False
            for cl in __all__ if globals()[cl].__class__.__name__ == &#34;type&#34;
            for meth in globals()[cl].__dict__ if not meth.startswith(&#34;_&#34;)}}</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="laue.core.geometry" href="geometry/index.html">laue.core.geometry</a></code></dt>
<dd>
<div class="desc"><p><strong> Accesseur vers les methodes de <code><a title="laue.core.geometry.transformer.Transformer" href="geometry/transformer.html#laue.core.geometry.transformer.Transformer">Transformer</a></code>. </strong></p></div>
</dd>
<dt><code class="name"><a title="laue.core.hkl_nn" href="hkl_nn/index.html">laue.core.hkl_nn</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="laue.core.pic_search" href="pic_search.html">laue.core.pic_search</a></code></dt>
<dd>
<div class="desc"><p><strong> C'est la fonction de pic search atomisee. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.core.subsets" href="subsets.html">laue.core.subsets</a></code></dt>
<dd>
<div class="desc"><p><strong> Permet de separer les differents grains d'un diagramme. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.core.zone_axes" href="zone_axes.html">laue.core.zone_axes</a></code></dt>
<dd>
<div class="desc"><p>Recherche les axes de zone sans aucune mise en forme.
C'est vraiment le coeur de la recherche atomisee.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laue.core.atomic_find_subsets"><code class="name flex">
<span>def <span class="ident">atomic_find_subsets</span></span>(<span>spots_dict, axes_dict, angle_max, spots_max, distance_max)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.subsets.atomic_find_subsets" href="subsets.html#laue.core.subsets.atomic_find_subsets">atomic_find_subsets()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_find_subsets(spots_dict, axes_dict, angle_max, spots_max, distance_max):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de separation de grains. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.experiment.base_experiment.Experiment.find_subsets``
    ou encore via ``laue.diagram.LaueDiagram.find_subsets`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.experiment.base_experiment.Experiment.find_subsets`` gere nativement le parallelisme.

    Parameters
    ----------
    spots_dict : dict
        Une representation des spots et des information minimales
        qui y sont raccrochees. Il doit prendre la forme suivante:
        ``{spot_ind: {&#34;gnom&#34;: (x_gnom, y_gnom), &#34;axes&#34;: {1, 3, ...}}, ...}``
    axes_dict : dict
        Une representations des axes de zone. Doit etre de la forme:
        ``{axe_ind: {&#34;polar&#34;: (theta, dist), &#34;quality&#34;: .7, &#34;spots&#34;: {1, 4, 5, 6}}, ...}``
    Pour les autres arguments, se referer a ``laue.core.subsets.Splitable.find_subsets``.

    Returns
    -------
    list
        Chaque element est un ensemble d&#39;indice de spot appartenant au meme grain.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; spots_dict = {0: {&#39;gnom&#39;: (0.3136510725564478, -0.44091934214920697), &#39;axes&#39;: set()},
    ...               1: {&#39;gnom&#39;: (0.3092269223801162, -0.3703963974694111), &#39;axes&#39;: {0}},
    ...               2: {&#39;gnom&#39;: (0.29464954430652696, 0.39670741889986955), &#39;axes&#39;: {1}},
    ...               3: {&#39;gnom&#39;: (0.30191318963902786, 0.011759364157261544), &#39;axes&#39;: {2}},
    ...               4: {&#39;gnom&#39;: (0.2656586060012433, -0.29892567761860783), &#39;axes&#39;: {0}},
    ...               5: {&#39;gnom&#39;: (0.2537441830952802, 0.32256757073867776), &#39;axes&#39;: {1}},
    ...               6: {&#39;gnom&#39;: (0.259687191990358, 0.011094867051531301), &#39;axes&#39;: {2}},
    ...               7: {&#39;gnom&#39;: (0.21447480004378858, -0.2150686716681864), &#39;axes&#39;: {0}},
    ...               8: {&#39;gnom&#39;: (0.2057015738443993, 0.2356420984106664), &#39;axes&#39;: {1}},
    ...               9: {&#39;gnom&#39;: (0.09095514707222462, -0.5356714822419564), &#39;axes&#39;: {3, 4}},
    ...               10: {&#39;gnom&#39;: (0.06846289051965272, 0.5548594993575858), &#39;axes&#39;: {3, 5}},
    ...               11: {&#39;gnom&#39;: (0.16685972592987006, -0.1362785647833782), &#39;axes&#39;: {0}},
    ...               12: {&#39;gnom&#39;: (0.16092652407854113, 0.15424696872260854), &#39;axes&#39;: {1}},
    ...               13: {&#39;gnom&#39;: (0.0880179013812851, -0.40043047804756454), &#39;axes&#39;: {3}},
    ...               14: {&#39;gnom&#39;: (0.07130573600458438, 0.4174843621463065), &#39;axes&#39;: {3}},
    ...               15: {&#39;gnom&#39;: (0.08639048300887514, -0.31911672107326594), &#39;axes&#39;: {3}},
    ...               16: {&#39;gnom&#39;: (0.07308383568548608, 0.3351760458933546), &#39;axes&#39;: {3}},
    ...               17: {&#39;gnom&#39;: (-0.016567440130016563, -0.5541568143935384), &#39;axes&#39;: {6}},
    ...               18: {&#39;gnom&#39;: (-0.04084781468303007, 0.5689448068249144), &#39;axes&#39;: {7}},
    ...               19: {&#39;gnom&#39;: (0.0011982188252073992, -0.45016007120047424), &#39;axes&#39;: set()},
    ...               20: {&#39;gnom&#39;: (-0.018154025485441625, 0.46402526754308027), &#39;axes&#39;: set()},
    ...               21: {&#39;gnom&#39;: (-0.07286049562681773, -0.5640133440412382), &#39;axes&#39;: set()},
    ...               22: {&#39;gnom&#39;: (0.0798366324753105, 0.007023938379407561), &#39;axes&#39;: {0, 1, 2, 3}},
    ...               23: {&#39;gnom&#39;: (-0.0026903259324252246, 0.3921879524265071), &#39;axes&#39;: {5}},
    ...               24: {&#39;gnom&#39;: (-0.09784778756977644, 0.5766271192972883), &#39;axes&#39;: set()},
    ...               25: {&#39;gnom&#39;: (0.008002458469782677, -0.12293574282766238), &#39;axes&#39;: {1}},
    ...               26: {&#39;gnom&#39;: (0.0027460490484708115, 0.13394781189060836), &#39;axes&#39;: {0}},
    ...               27: {&#39;gnom&#39;: (-0.00523750349077013, -0.1470394198008183), &#39;axes&#39;: {1}},
    ...               28: {&#39;gnom&#39;: (-0.011614516626281228, 0.15777148638160254), &#39;axes&#39;: {0}},
    ...               29: {&#39;gnom&#39;: (-0.02477598980567221, -0.1823836791494654), &#39;axes&#39;: {1}},
    ...               30: {&#39;gnom&#39;: (-0.03264505249777272, 0.19229497060446735), &#39;axes&#39;: {0}},
    ...               31: {&#39;gnom&#39;: (-0.05554717740227801, -0.23832176191125093), &#39;axes&#39;: {1, 4}},
    ...               32: {&#39;gnom&#39;: (-0.06606796372263056, 0.24757266647939288), &#39;axes&#39;: {0, 5}},
    ...               33: {&#39;gnom&#39;: (-0.07907768658950604, -0.28096918114364355), &#39;axes&#39;: {1}},
    ...               34: {&#39;gnom&#39;: (-0.09156428823859053, 0.2893970244445073), &#39;axes&#39;: {0}},
    ...               35: {&#39;gnom&#39;: (-0.1126289846318788, -0.3416241560303849), &#39;axes&#39;: {1, 6}},
    ...               36: {&#39;gnom&#39;: (-0.060637577826655534, 0.0040391083212410655), &#39;axes&#39;: {2}},
    ...               37: {&#39;gnom&#39;: (-0.12787900102974828, 0.3491863530719953), &#39;axes&#39;: {0, 7}},
    ...               38: {&#39;gnom&#39;: (-0.1638208798822865, -0.4347286698438957), &#39;axes&#39;: {1}},
    ...               39: {&#39;gnom&#39;: (-0.18763951100210385, -0.4776573606384503), &#39;axes&#39;: {1}},
    ...               40: {&#39;gnom&#39;: (-0.1835787305562983, 0.4411739247300923), &#39;axes&#39;: {0}},
    ...               41: {&#39;gnom&#39;: (-0.08524649743749545, 0.003436523504335945), &#39;axes&#39;: {2}},
    ...               42: {&#39;gnom&#39;: (-0.2523542667003644, -0.5949096601292776), &#39;axes&#39;: {8, 1}},
    ...               43: {&#39;gnom&#39;: (-0.20958039716029048, 0.4837711867805186), &#39;axes&#39;: {0}},
    ...               44: {&#39;gnom&#39;: (-0.11758167206566646, -0.1123768702642382), &#39;axes&#39;: {4}},
    ...               45: {&#39;gnom&#39;: (-0.12266805447587614, 0.11817207059217111), &#39;axes&#39;: {5}},
    ...               46: {&#39;gnom&#39;: (-0.17376685735949005, 0.0016472083664571353), &#39;axes&#39;: {2, 4, 5}},
    ...               47: {&#39;gnom&#39;: (-0.20724297206742168, -0.25150647771157364), &#39;axes&#39;: set()},
    ...               48: {&#39;gnom&#39;: (-0.19501092265693473, -0.15910834995174863), &#39;axes&#39;: {6}},
    ...               49: {&#39;gnom&#39;: (-0.21870028043714163, 0.25404867230414246), &#39;axes&#39;: set()},
    ...               50: {&#39;gnom&#39;: (-0.2022799134764107, 0.16163477331619278), &#39;axes&#39;: {7}},
    ...               51: {&#39;gnom&#39;: (-0.2581018757728966, -0.3579924435989167), &#39;axes&#39;: {8}},
    ...               52: {&#39;gnom&#39;: (-0.2748170617964089, 0.3596407013965223), &#39;axes&#39;: {8}},
    ...               53: {&#39;gnom&#39;: (-0.21290266125204668, 0.0008346770568725252), &#39;axes&#39;: {2}},
    ...               54: {&#39;gnom&#39;: (-0.21986841578944072, -0.10369811043407293), &#39;axes&#39;: {5, 6}},
    ...               55: {&#39;gnom&#39;: (-0.224622744015843, 0.10503684334781563), &#39;axes&#39;: {4, 7}},
    ...               56: {&#39;gnom&#39;: (-0.25955409478645797, -0.29848728294016463), &#39;axes&#39;: {8}},
    ...               57: {&#39;gnom&#39;: (-0.27338619051240226, 0.299389601118816), &#39;axes&#39;: {8}},
    ...               58: {&#39;gnom&#39;: (-0.3156632165624574, -0.4202358686963255), &#39;axes&#39;: set()},
    ...               59: {&#39;gnom&#39;: (-0.2618304221414466, -0.19929059589121062), &#39;axes&#39;: {8, 5}},
    ...               60: {&#39;gnom&#39;: (-0.2711073666720387, 0.1994839074523256), &#39;axes&#39;: {8, 4}},
    ...               61: {&#39;gnom&#39;: (-0.2637120677768278, -0.11984479170021081), &#39;axes&#39;: {8}},
    ...               62: {&#39;gnom&#39;: (-0.26934469418071083, 0.11943958616023759), &#39;axes&#39;: {8}},
    ...               63: {&#39;gnom&#39;: (-0.26653796331705015, -0.00040349411462381246), &#39;axes&#39;: {8, 2, 6, 7}},
    ...               64: {&#39;gnom&#39;: (-0.3351088299984176, -0.36661822106768144), &#39;axes&#39;: {5}},
    ...               65: {&#39;gnom&#39;: (-0.30919293226499917, -0.22782988778598667), &#39;axes&#39;: set()},
    ...               66: {&#39;gnom&#39;: (-0.3524825023650732, 0.3647641920521141), &#39;axes&#39;: {4}},
    ...               67: {&#39;gnom&#39;: (-0.31990969642322137, 0.22611752961083748), &#39;axes&#39;: set()},
    ...               68: {&#39;gnom&#39;: (-0.3144023520521512, -0.0013698968940222644), &#39;axes&#39;: {2}},
    ...               69: {&#39;gnom&#39;: (-0.3223772542169661, -0.14153279317889217), &#39;axes&#39;: {7}},
    ...               70: {&#39;gnom&#39;: (-0.3290872223583307, 0.13867490378055763), &#39;axes&#39;: {6}},
    ...               71: {&#39;gnom&#39;: (-0.34380505280556134, -0.0019232844125064402), &#39;axes&#39;: {2}},
    ...               72: {&#39;gnom&#39;: (-0.3716527272451695, -0.2655541496297943), &#39;axes&#39;: {7}},
    ...               73: {&#39;gnom&#39;: (-0.384382394518522, 0.26137948985364423), &#39;axes&#39;: {6}},
    ...               74: {&#39;gnom&#39;: (-0.4150393355485816, -0.37556396956837046), &#39;axes&#39;: {7}},
    ...               75: {&#39;gnom&#39;: (-0.4213116259525938, -0.1277995546595711), &#39;axes&#39;: set()},
    ...               76: {&#39;gnom&#39;: (-0.42743697409652126, 0.12091462467337603), &#39;axes&#39;: set()},
    ...               77: {&#39;gnom&#39;: (-0.4305672928685682, -0.10207732996277492), &#39;axes&#39;: set()}}
    &gt;&gt;&gt; axes_dict = {0: {&#39;polar&#39;: (0.5456325, 0.07189146), &#39;quality&#39;: 0.7786729549943984, &#39;spots&#39;: {32, 1, 34, 4, 37, 7, 40, 11, 43, 22, 26, 28, 30}},
    ...              1: {&#39;polar&#39;: (-0.50404394, 0.066435024), &#39;quality&#39;: 0.8495679649229442, &#39;spots&#39;: {33, 2, 35, 5, 38, 39, 8, 42, 12, 22, 25, 27, 29, 31}},
    ...              2: {&#39;polar&#39;: (1.5920126, 0.0053436677), &#39;quality&#39;: 0.5048333500772214, &#39;spots&#39;: {3, 36, 68, 6, 71, 41, 46, 53, 22, 63}},
    ...              3: {&#39;polar&#39;: (0.020630987, 0.07989738), &#39;quality&#39;: 0.32446216058045907, &#39;spots&#39;: {9, 10, 13, 14, 15, 16, 22}},
    ...              4: {&#39;polar&#39;: (-2.6840417, 0.15513226), &#39;quality&#39;: 0.32470155528405464, &#39;spots&#39;: {66, 9, 44, 46, 55, 60, 31}},
    ...              5: {&#39;polar&#39;: (2.7287471, 0.15980783), &#39;quality&#39;: 0.36693478788694234, &#39;spots&#39;: {32, 64, 10, 45, 46, 54, 23, 59}},
    ...              6: {&#39;polar&#39;: (-2.7180853, 0.24310948), &#39;quality&#39;: 0.324204821510315, &#39;spots&#39;: {35, 70, 73, 48, 17, 54, 63}},
    ...              7: {&#39;polar&#39;: (2.7643242, 0.24759501), &#39;quality&#39;: 0.3668147624332471, &#39;spots&#39;: {69, 37, 72, 74, 18, 50, 55, 63}},
    ...              8: {&#39;polar&#39;: (-3.118213, 0.26645306), &#39;quality&#39;: 0.5046664108258551, &#39;spots&#39;: {42, 51, 52, 56, 57, 59, 60, 61, 62, 63}}}
    &gt;&gt;&gt; kwargs = {&#39;angle_max&#39;: 0.1308996938995747, &#39;spots_max&#39;: 20, &#39;distance_max&#39;: 0.08}
    &gt;&gt;&gt; laue.atomic_find_subsets(spots_dict, axes_dict, **kwargs)
    [{9, 10, 22}]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.zone_axis import distance as distance_axis
    from laue.spot import distance as distance_pic
    import networkx

    def count_variant_axis(spot_id):
        &#34;&#34;&#34;
        Compte le nombre d&#39;axes de zone qui different beaucoup.
        (ie considere 2 axes proche comme un seul axe)
        &#34;&#34;&#34;
        axes_id = spots_dict[spot_id][&#34;axes&#34;]
        if len(axes_id) &lt;= 1:
            return len(axes_id)
        axes = [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes_id]
        nbr_near = (distance_axis(axes, axes, weight=1) &lt; angle_max).sum()
        nbr = len(axes) - (nbr_near-len(axes))//2
        return nbr

    def simul_remove_axis(graph, axis, excluded):
        &#34;&#34;&#34;
        Retire les aretes liees a cet axe, puis regarde ce que ca donne.
        &#34;&#34;&#34;
        graph_bis = graph.copy()
        for spot1, spot2, axis_found in graph.edges.data(&#34;axis&#34;):
            if axis_found is axis:
                graph_bis.remove_edge(spot1, spot2)
        excluded_bis = [edge for edge in excluded if networkx.algorithms.has_path(graph_bis, *edge)]
        return excluded_bis, graph_bis

    # Extraction des spots.
    spots_at_cross = sorted(spots_dict, key=count_variant_axis, reverse=True)[:spots_max]
    max_cross = count_variant_axis(spots_at_cross[0])
    limit = math.sqrt(max(2**2, max_cross)) # Permet d&#39;eviter &#39;ValueError: math domain error&#39;
    spots_at_cross = [spot_id for spot_id in spots_at_cross if count_variant_axis(spot_id) &gt;= limit]

    # Creation des noeuds du graphe.
    graph = networkx.Graph()
    graph.add_nodes_from(spots_at_cross)

    # Ajout grossier de certaine aretes.
    excluded = [] # La liste des noeuds appartenant a des grains differents.
    candidate_axes = set() # L&#39;ensemble des axes de zone consideres.
    for i, spot1 in enumerate(spots_at_cross[:-1]): # On faite toutes les combinaisons
        for spot2 in spots_at_cross[i+1:]: # de 2 sommets possibles.

            ## Exclusion des spots trop proches.
            if distance_pic(
                    spots_dict[spot1][&#34;gnom&#34;],
                    spots_dict[spot2][&#34;gnom&#34;],
                    space=&#34;gnomonic&#34;
                    ) &lt; distance_max:
                excluded.append((spot1, spot2))
                continue

            ## On ne relie pas les spots qui n&#39;ont pas d&#39;axe commun.
            common_axes = spots_dict[spot1][&#34;axes&#34;] &amp; spots_dict[spot2][&#34;axes&#34;]
            if not common_axes:
                continue

            ## Exclusion des spots ayant 2 axes de zone paralleles.
            axes1, axes2 = spots_dict[spot1][&#34;axes&#34;]-common_axes, spots_dict[spot2][&#34;axes&#34;]-common_axes
            if axes1 and axes2 and distance_axis(
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes1],
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes2],
                    weight=1).min() &lt; angle_max: # tolerance angulaire de pi/32
                excluded.append((spot1, spot2))
                continue

            ## Ajout dans le graphe.
            best_axis = sorted(common_axes, key=lambda axis_id: axes_dict[axis_id][&#34;quality&#34;])[-1]
            candidate_axes.add(best_axis)
            graph.add_edge(spot1, spot2, quality=axes_dict[best_axis][&#34;quality&#34;], axis=best_axis)

    # Suppression des aretes en trop afin de discosier les grains.
    excluded = [edge for edge in excluded if networkx.algorithms.has_path(graph, *edge)]
    while excluded:
        predictions = [(*simul_remove_axis(graph, axis_id, excluded), axis_id) for axis_id in candidate_axes]
        best_len = min(len(excluded_bis) for excluded_bis, _, _ in predictions)
        predictions = [p for p in predictions if len(p[0]) == best_len]
        costs = [axes_dict[axis_id][&#34;quality&#34;] for _, _, axis_id in predictions]
        min_quality = min(costs)
        predictions = [p for p in predictions if axes_dict[p[2]][&#34;quality&#34;] == min_quality]
        excluded, graph, axis_id = predictions.pop()
        candidate_axes.remove(axis_id)

    # Creation des clusters.
    subsets = list(networkx.algorithms.connected_components(graph))
    subsets = sorted(subsets, key=lambda con: len(con), reverse=True)
    subsets = [con for con in subsets if len(con) &gt;= 2]
    return subsets</code></pre>
</details>
</dd>
<dt id="laue.core.atomic_find_zone_axes"><code class="name flex">
<span>def <span class="ident">atomic_find_zone_axes</span></span>(<span>transformer, gnomonics, dmax, nbr, tol)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.zone_axes.atomic_find_zone_axes" href="zone_axes.html#laue.core.zone_axes.atomic_find_zone_axes">atomic_find_zone_axes()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_find_zone_axes(transformer, gnomonics, dmax, nbr, tol):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de recherche d&#39;axes de zonnes. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.experiment.base_experiment.Experiment.find_zone_axes``
    ou encore via ``laue.diagram.LaueDiagram.find_zone_axes`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.experiment.base_experiment.Experiment.find_zone_axes`` gere nativement le parallelisme.
    * La seule raison d&#39;utiliser cette fonction, c&#39;est si le pic_search
    utilise n&#39;est pas celui de ``laue.experiment.base_experiment.Experiment``. Sinon, l&#39;utilisation
    de cette fonction ne fera qu&#39;alourdir et ralentir votre code.

    Parameters
    ----------
    transformer : laue.core.geometry.transformer.Transformer
        Instance d&#39;un objet capable de gerer formellement
        la transformee de hough. (Cet argument n&#39;est pas present
        si on utilise les methodes ci dessus car il fait partie
        d&#39;une ``laue.experiment.base_experiment.Experiment``.)
    gnomonics : np.ndarray
        Les positions des spots en coordonnees gnomonic.
        Il faut que ``x_gnomonic = gnomonic[0]``
        et que ``y_gnomonic = gnomonic[1]``.
    dmax
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre n&#39;est pas factultatif.
    nbr
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre n&#39;est pas factultatif.
    tol
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre doit etre fixe par vous et ne peut
        pas prendre tous seulle une valeur optimale.

    Returns
    -------
    angles : iterable
        Vecteur des angles des droites. C&#39;est la premiere partie
        de la representation polaire des droites. (C&#39;est l&#39;angle
        algebrique entre l&#39;axe x et un vecteur normal a la droite.)
    dists : iterable
        Vecteur des distances des droites. C&#39;est la seconde partie
        de la representation polaire des droites. (C&#39;est la plus courte
        distance entre l&#39;origine et tous les points constituant la droite.)
    axes_spots_ind : list
        Vecteur des ensembles de spots lies a chaque droites.
        On a ``len(axes_spots_ind) == nbr_d_axe_de_zones``.
    spots_axes_ind : list
        Vecteur des indices des droites passant par chaque spot.
        On a ``len(spots_axes_ind) == nbr_de_spots``.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; gnomonics = np.array(
    ... [[ 3.13651353e-01,  3.09226930e-01,  2.94649661e-01,  3.01913261e-01,
    ...    2.65658647e-01,  2.53744185e-01,  2.59687364e-01,  2.14474797e-01,
    ...    2.05701679e-01,  9.09550861e-02,  6.84629381e-02,  1.66859716e-01,
    ...    1.60926506e-01,  8.80179554e-02,  7.13057593e-02,  8.63905624e-02,
    ...    7.30837137e-02, -1.65674724e-02, -4.08478454e-02,  1.19812461e-03,
    ...   -1.81540363e-02, -7.28605017e-02,  7.98366740e-02, -2.69038416e-03,
    ...   -9.78478342e-02,  8.00240133e-03,  2.74614431e-03, -5.23754954e-03,
    ...   -1.16145127e-02, -2.47761104e-02, -3.26450653e-02, -5.55472001e-02,
    ...   -6.60679415e-02, -7.90777430e-02, -9.15642828e-02, -1.12629071e-01,
    ...   -6.06376082e-02, -1.27878949e-01, -1.63820893e-01, -1.87639564e-01,
    ...   -1.83578789e-01, -8.52464810e-02, -2.52354264e-01, -2.09580392e-01,
    ...   -1.17581628e-01, -1.22668095e-01, -1.73766926e-01, -2.07243070e-01,
    ...   -1.95010900e-01, -2.18700320e-01, -2.02279896e-01, -2.58101851e-01,
    ...   -2.74817050e-01, -2.12902710e-01, -2.19868407e-01, -2.24622726e-01,
    ...   -2.59554148e-01, -2.73386180e-01, -3.15663189e-01, -2.61830509e-01,
    ...   -2.71107376e-01, -2.63712078e-01, -2.69344717e-01, -2.66537964e-01,
    ...   -3.35108876e-01, -3.09192955e-01, -3.52482527e-01, -3.19909692e-01,
    ...   -3.14402401e-01, -3.22377235e-01, -3.29087257e-01, -3.43805134e-01,
    ...   -3.71652663e-01, -3.84382367e-01, -4.15039361e-01, -4.21311647e-01,
    ...   -4.27436978e-01, -4.30567324e-01],
    ...  [-4.40919399e-01, -3.70396405e-01,  3.96707416e-01,  1.17593547e-02,
    ...   -2.98925638e-01,  3.22567523e-01,  1.10948607e-02, -2.15068594e-01,
    ...    2.35642120e-01, -5.35671413e-01,  5.54859519e-01, -1.36278614e-01,
    ...    1.54246926e-01, -4.00430471e-01,  4.17484373e-01, -3.19116771e-01,
    ...    3.35176021e-01, -5.54156780e-01,  5.68944812e-01, -4.50160027e-01,
    ...    4.64025259e-01, -5.64013302e-01,  7.02395430e-03,  3.92187923e-01,
    ...    5.76627076e-01, -1.22935735e-01,  1.33947819e-01, -1.47039399e-01,
    ...    1.57771528e-01, -1.82383612e-01,  1.92295000e-01, -2.38321751e-01,
    ...    2.47572735e-01, -2.80969173e-01,  2.89397061e-01, -3.41624111e-01,
    ...    4.03913576e-03,  3.49186361e-01, -4.34728622e-01, -4.77657378e-01,
    ...    4.41173941e-01,  3.43652675e-03, -5.94909608e-01,  4.83771175e-01,
    ...   -1.12376906e-01,  1.18172102e-01,  1.64722977e-03, -2.51506448e-01,
    ...   -1.59108326e-01,  2.54048705e-01,  1.61634743e-01, -3.57992381e-01,
    ...    3.59640747e-01,  8.34673643e-04, -1.03698038e-01,  1.05036855e-01,
    ...   -2.98487246e-01,  2.99389601e-01, -4.20235783e-01, -1.99290574e-01,
    ...    1.99483901e-01, -1.19844824e-01,  1.19439557e-01, -4.03501937e-04,
    ...   -3.66618216e-01, -2.27829859e-01,  3.64764214e-01,  2.26117536e-01,
    ...   -1.36989250e-03, -1.41532809e-01,  1.38674900e-01, -1.92326447e-03,
    ...   -2.65554100e-01,  2.61379480e-01, -3.75563949e-01, -1.27799526e-01,
    ...    1.20914638e-01, -1.02077320e-01]])
    &gt;&gt;&gt; dmax = 0.01086181640625
    &gt;&gt;&gt; nbr = 7
    &gt;&gt;&gt; tol = 0.01758723266
    &gt;&gt;&gt; angles, dists, axes_spots_ind, spots_axes_ind = laue.atomic_find_zone_axes(
    ...     transformer, gnomonics, dmax, nbr, tol)
    &gt;&gt;&gt; len(angles), len(dists)
    (9, 9)
    &gt;&gt;&gt; for spots in axes_spots_ind:
    ...     print(sorted(spots))
    ...
    [1, 4, 7, 11, 22, 26, 28, 30, 32, 34, 37, 40, 43]
    [2, 5, 8, 12, 22, 25, 27, 29, 31, 33, 35, 38, 39, 42]
    [3, 6, 22, 36, 41, 46, 53, 63, 68, 71]
    [9, 10, 13, 14, 15, 16, 22]
    [9, 31, 44, 46, 55, 60, 66]
    [10, 23, 32, 45, 46, 54, 59, 64]
    [17, 35, 48, 54, 63, 70, 73]
    [18, 37, 50, 55, 63, 69, 72, 74]
    [42, 51, 52, 56, 57, 59, 60, 61, 62, 63]
    &gt;&gt;&gt; spots_axes_ind[0]
    set()
    &gt;&gt;&gt; sorted(spots_axes_ind[22])
    [0, 1, 2, 3]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.core.geometry.transformer import ind2comb

    # Recherches des axes de zone.
    angles, dists = transformer.hough_reduce(
        *transformer.hough(*gnomonics),
        nbr=nbr, tol=tol) # Recuperation des axes.
    if len(angles) &lt;= 1: # Si on a pas trouve suffisement de choses.
        return (), (), (), ((),)*gnomonics.shape[-1]

    # Attribution des points aux droites.
    axes_spots_ind = [set() for _ in range(len(angles))] # A chaque droite, c&#39;est les spots qu&#39;elle possede.
    spots_axes_ind = [set() for _ in range(gnomonics.shape[-1])]
    x_inters, y_inters = transformer.inter_lines(angles, dists)
    xg_spots, yg_spots = gnomonics

    ## Recuperation des points aux intersections.
    
    ### Calcul des points les plus proche pour chaque intersections.
    used_memory = len(x_inters)*len(xg_spots)*8 # Taille de la matrice de distance en octet.
    if psutil is not None and psutil.virtual_memory().available &gt; 2*used_memory:
        xg_spots_mesh, x_inters_mesh = np.meshgrid(xg_spots, x_inters, copy=False)
        yg_spots_mesh, y_inters_mesh = np.meshgrid(yg_spots, y_inters, copy=False)
        if numexpr is not None: # d[inter, gnomo]
            distances = numexpr.evaluate(
                &#34;sqrt((xg_spots_mesh-x_inters_mesh)**2 + (yg_spots_mesh-y_inters_mesh)**2)&#34;)
        else:
            distances = np.sqrt((xg_spots_mesh-x_inters_mesh)**2 + (yg_spots_mesh-y_inters_mesh)**2)
        nearest_spots = np.argmin(distances, axis=1) # Pour chaque intersections, son spot le plus proche.
        del distances, xg_spots_mesh, x_inters_mesh, yg_spots_mesh, y_inters_mesh
    else: # Si il n&#39;y a pas suffisement de RAM.
        nearest_spots = np.array([ # attention &#39;numexpr&#39; est 7 fois plus lent.
            np.argmin(np.sqrt((xg_spots-x_inter)**2 + (yg_spots-y_inter)**2))
            for x_inter, y_inter in zip(x_inters, y_inters)], dtype=int)

    ### Selection des bons candidats.
    spots_left = [] # Les spots non references.
    for spot_ind, (xg_pic, yg_pic) in enumerate(zip(xg_spots, yg_spots)):
        inters_cand = np.argwhere(nearest_spots == spot_ind)
        adds_inter = inters_cand[
            (x_inters[inters_cand]-xg_pic)**2
          + (y_inters[inters_cand]-yg_pic)**2
          &lt; dmax**2]
        if adds_inter.any():
            _adds_axes_1, _adds_axes_2 = ind2comb(adds_inter, n=len(angles))
            adds_axes = set(_adds_axes_1) | set(_adds_axes_2)
            for add_axis in adds_axes:
                axes_spots_ind[add_axis].add(spot_ind)
            spots_axes_ind[spot_ind].update(adds_axes) # f&#34;le spot num {spot_ind} est l&#39;intersections des axes {adds_axes}.&#34;
        else:
            spots_left.append(spot_ind)

    ## Recuperation des points colles a un seul axe.
    spots_left = np.array(spots_left, dtype=int) # Les indices des spots restants.

    used_memory = len(spots_left)*len(angles)*8 # Taille memoire de la matrice de distances.
    if psutil is not None and psutil.virtual_memory().available &gt; 2*used_memory:
        distances = transformer.dist_line( # d[line, point]
            angles, dists, xg_spots[spots_left], yg_spots[spots_left])
        axis_ind = np.argmin(distances, axis=0) # A chaque points, indice de la droite la plus proche.
        close_spots = distances.min(axis=0) &lt; dmax # La matrice des points suffisement proches.
        del distances
        for axis_ind, spot_left in zip(axis_ind[close_spots], spots_left[close_spots]):
            axes_spots_ind[axis_ind].add(spot_left)
            spots_axes_ind[spot_left].add(axis_ind)   
    else: # Si il n&#39;y a pas suffisement de RAM.
        for spot_left, xg_pic, yg_pic in zip(spots_left, xg_spots[spots_left], yg_spots[spots_left]):
            xg_pic, yg_pic = np.array([xg_pic], dtype=np.float32), np.array([yg_pic], dtype=np.float32)
            distances = transformer.dist_line(angles, dists, xg_pic, yg_pic) # d[line, point]
            axis_ind = np.argmin(distances[:, 0])
            if distances[axis_ind] &lt; dmax:
                axes_spots_ind[axis_ind].add(spot_left)
                spots_axes_ind[spot_left].add(axis_ind)

    # Suppression des axes qui contiennent pas suffisement de points.
    mask_axes_to_keep = np.array([len(spots_ind) for spots_ind in axes_spots_ind]) &gt;= nbr
    ind_axes_to_keep = set(np.argwhere(mask_axes_to_keep)[:, 0])
    spots_axes_ind = [axes_ind &amp; ind_axes_to_keep for axes_ind in spots_axes_ind]
    axes_spots_ind = [spots_ind for axis_ind, spots_ind
                     in enumerate(axes_spots_ind)
                     if axis_ind in ind_axes_to_keep]
    angles, dists = angles[mask_axes_to_keep], dists[mask_axes_to_keep]

    # Changement des anciens par les nouveaux indices de droites.
    old_to_new = {
        old_axis_ind: new_axis_ind
        for new_axis_ind, old_axis_ind
        in enumerate(sorted(set.union(*spots_axes_ind)))}
    spots_axes_ind = [
        {old_to_new[old_axis_ind] for old_axis_ind in old_axes_ind}
        for old_axes_ind in spots_axes_ind]

    return angles, dists, axes_spots_ind, spots_axes_ind</code></pre>
</details>
</dd>
<dt id="laue.core.atomic_pic_search"><code class="name flex">
<span>def <span class="ident">atomic_pic_search</span></span>(<span>image, kernel_font, kernel_dilate, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.pic_search.atomic_pic_search" href="pic_search.html#laue.core.pic_search.atomic_pic_search">atomic_pic_search()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_pic_search(image, kernel_font, kernel_dilate, threshold):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau de pic search atomic serialisable. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers
    ``laue.experiment.base_experiment.Experiment.get_diagrams``
    ou encore via ``laue.experiment.base_experiment.Experiment.__iter__``
    car le context est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre les methodes
    de ``laue.experiment.base_experiment.Experiment`` gerent nativement le parallelisme.
    * L&#39;utilisation de cette fonction ne fera qu&#39;alourdir et ralentir votre code.

    Parameters
    ----------
    image : np.ndarray
        Image 2d en niveau de gris codee en np.uint16.
        C&#39;est l&#39;image brute, sans pre-traitement et avec le fond diffus.
    kernel_font : np.ndarray
        Le masque de l&#39;element structurant pour l&#39;estimation
        du fond par ouverture morphologique.
    kernel_dilate : np.ndarray
        Le masque de l&#39;element structurant pour la dilatation morphologique
        sur l&#39;image binarisee afin d&#39;aglomerer les grains proches.
    threshold : float
        Le niveau de seuillage relatif a la variance de l&#39;image.

    Returns
    -------
    list
        Une liste qui contient autant d&#39;elements de de pic trouves.
        Les element sont des dictionaires

    Examples
    --------
    &gt;&gt;&gt; import cv2
    &gt;&gt;&gt; from laue import atomic_pic_search
    &gt;&gt;&gt; from laue.utilities.image import read_image
    &gt;&gt;&gt; image_path = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt;
    &gt;&gt;&gt; image = read_image(image_path)
    &gt;&gt;&gt; kernel_font = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (21, 21))
    &gt;&gt;&gt; kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    &gt;&gt;&gt; threshold = 5.1
    &gt;&gt;&gt;
    &gt;&gt;&gt; res = atomic_pic_search(image, kernel_font, kernel_dilate, threshold)
    &gt;&gt;&gt; type(res)
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; len(res)
    78
    &gt;&gt;&gt; res[0][&#34;bbox&#34;]
    (1368, 1873, 6, 5)
    &gt;&gt;&gt; res[0][&#34;distortion&#34;]
    0.8471580534997302
    &gt;&gt;&gt; res[0][&#34;spot_im&#34;]
    array([[  8,  10,  16,  16,   8,   5],
           [ 11,  17,  67,  76,  13,   9],
           [  7,  19, 184, 229,  14,   6],
           [  9,   6,  12,  19,   8,   4],
           [  5,   3,   3,   9,  14,   7]], dtype=uint16)
    &gt;&gt;&gt; 
    &#34;&#34;&#34;
    # Binarisation de l&#39;image.
    bg_image = cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel_font, iterations=1)
    fg_image = image - bg_image
    thresh_image = (fg_image &gt; threshold*fg_image.std()).astype(np.uint8)
    dilated_image = cv2.dilate(thresh_image, kernel_dilate, iterations=1)

    # Detection des contours grossiers.
    outlines, _ = cv2.findContours(dilated_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    bbox = [cv2.boundingRect(outl) for outl in outlines]

    # Calcul des distortions.
    distortions_open = (2*np.sqrt(np.pi)) / np.array([
        cv2.arcLength(outl, True)/np.sqrt(cv2.contourArea(outl))
        for outl in outlines])

    # Preparation des arguments des spots.
    spots_args = [
        {
            &#34;bbox&#34;: (x, y, w, h),
            &#34;spot_im&#34;: fg_image[y:y+h, x:x+w],
            &#34;distortion&#34;: dis,
        }
        for dis, (x, y, w, h) in zip(distortions_open, bbox)]

    return spots_args</code></pre>
</details>
</dd>
<dt id="laue.core.cam_to_gnomonic"><code class="name flex">
<span>def <span class="ident">cam_to_gnomonic</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.cam_to_gnomonic" href="geometry/index.html#laue.core.geometry.cam_to_gnomonic">cam_to_gnomonic()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cam_to_gnomonic(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.cam_to_gnomonic``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;cam_to_gnomonic&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.cam_to_thetachi"><code class="name flex">
<span>def <span class="ident">cam_to_thetachi</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.cam_to_thetachi" href="geometry/index.html#laue.core.geometry.cam_to_thetachi">cam_to_thetachi()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cam_to_thetachi(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.cam_to_thetachi``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;cam_to_thetachi&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.comb2ind"><code class="name flex">
<span>def <span class="ident">comb2ind</span></span>(<span>ind1, ind2, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.transformer.comb2ind" href="geometry/transformer.html#laue.core.geometry.transformer.comb2ind">comb2ind()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comb2ind(ind1, ind2, n):
    &#34;&#34;&#34;
    ** Transforme 2 indices en un seul. **

    Note
    ----
    * Bijection de ``ind2comb``.
    * Peut etre utile pour les methodes ``laue.core.geometry.transformer.Transformer.hough``
    et ``laue.core.geometry.transformer.Transformer.inter_lines``.

    Parameters
    ----------
    ind1 : int ou np.ndarray(dtype=int)
        L&#39;indice du premier element: ``0 &lt;= ind1``.
    ind2 : int ou np.ndarray(dtype=int)
        L&#39;indice du second element: ``ind1 &lt; ind2``.
    n : int
        Le nombre de symboles : ``2 &lt;= n and ind2 &lt; n``.

    Returns
    -------
    int, np.ndarray(dtype=int)
        Le nombre de mots contenant exactement 2 symboles dans un
        alphabet de cardinal ``n``. Sachant que le deuxieme symbole
        est stricement superieur au premier, et que les mots sont
        generes avec le comptage naturel (representation des nombres
        en base n).

    Examples
    -------
    &gt;&gt;&gt; from laue.core.geometry.transformer import comb2ind
    &gt;&gt;&gt; comb2ind(0, 1, n=6)
    0
    &gt;&gt;&gt; comb2ind(0, 2, n=6)
    1
    &gt;&gt;&gt; comb2ind(0, 5, n=6)
    4
    &gt;&gt;&gt; comb2ind(1, 2, n=6)
    5
    &gt;&gt;&gt; comb2ind(4, 5, n=6)
    14
    &#34;&#34;&#34;
    assert isinstance(ind1, (int, np.ndarray)), \
        f&#34;&#39;ind1&#39; can not being of type {type(ind1).__name__}.&#34;
    assert isinstance(ind2, (int, np.ndarray)), \
        f&#34;&#39;ind2&#39; can not being of type {type(ind2).__name__}.&#34;
    assert isinstance(n, int), f&#34;&#39;n&#39; has to ba an integer, not a {type(n).__name__}.&#34;
    if isinstance(ind1, np.ndarray):
        assert ind1.dtype == int or issubclass(ind2.dtype.type, np.integer), \
            f&#34;&#39;ind1&#39; must be integer, not {str(ind1.dtype)}.&#34;
        assert (ind1 &gt;= 0).all(), &#34;Tous les indices doivent etres positifs.&#34;
    else:
        assert ind1 &gt;= 0, &#34;Les indices doivent etre positifs.&#34;
    if isinstance(ind2, np.ndarray):
        assert ind2.dtype == int or issubclass(ind2.dtype.type, np.integer), \
            f&#34;&#39;ind2&#39; must be integer, not {str(ind2.dtype)}.&#34;
        assert ind1.shape == ind2.shape, (&#34;Si les indices sont des arrays, elles doivent &#34;
            f&#34;toutes 2 avoir les memes dimensions. {ind1.shape} vs {ind2.shape}.&#34;)
        assert (ind2 &gt; ind1).all(), (&#34;Les 2ieme indices doivent &#34;
            &#34;etres strictement superieur aux premiers.&#34;)
        assert (ind2 &lt; n).all(), &#34;Vous aimez un peu trop les &#39;index out of range&#39;.&#34;
    else:
        assert ind2 &gt; ind1, (&#34;Le 2ieme indice doit etre strictement superieur au premier. &#34;
            f&#34;{ind1} vs {ind2}.&#34;)
        assert ind2 &lt; n, &#34;Vous aimez un peu trop les &#39;index out of range&#39;.&#34;

    return n*ind1 - (ind1**2 + 3*ind1)//2 + ind2 - 1</code></pre>
</details>
</dd>
<dt id="laue.core.dist_cosine"><code class="name flex">
<span>def <span class="ident">dist_cosine</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.dist_cosine" href="geometry/index.html#laue.core.geometry.dist_cosine">dist_cosine()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist_cosine(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.dist_cosine``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;dist_cosine&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.dist_euclidian"><code class="name flex">
<span>def <span class="ident">dist_euclidian</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.dist_euclidian" href="geometry/index.html#laue.core.geometry.dist_euclidian">dist_euclidian()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist_euclidian(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.dist_euclidian``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;dist_euclidian&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.dist_line"><code class="name flex">
<span>def <span class="ident">dist_line</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.dist_line" href="geometry/index.html#laue.core.geometry.dist_line">dist_line()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist_line(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.dist_line``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;dist_line&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.gnomonic_to_cam"><code class="name flex">
<span>def <span class="ident">gnomonic_to_cam</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.gnomonic_to_cam" href="geometry/index.html#laue.core.geometry.gnomonic_to_cam">gnomonic_to_cam()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gnomonic_to_cam(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.gnomonic_to_cam``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;gnomonic_to_cam&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.gnomonic_to_thetachi"><code class="name flex">
<span>def <span class="ident">gnomonic_to_thetachi</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.gnomonic_to_thetachi" href="geometry/index.html#laue.core.geometry.gnomonic_to_thetachi">gnomonic_to_thetachi()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gnomonic_to_thetachi(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.gnomonic_to_thetachi``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;gnomonic_to_thetachi&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.hough"><code class="name flex">
<span>def <span class="ident">hough</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.hough" href="geometry/index.html#laue.core.geometry.hough">hough()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hough(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.hough``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;hough&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.hough_reduce"><code class="name flex">
<span>def <span class="ident">hough_reduce</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.hough_reduce" href="geometry/index.html#laue.core.geometry.hough_reduce">hough_reduce()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hough_reduce(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.hough_reduce``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;hough_reduce&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.ind2comb"><code class="name flex">
<span>def <span class="ident">ind2comb</span></span>(<span>comb, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.transformer.ind2comb" href="geometry/transformer.html#laue.core.geometry.transformer.ind2comb">ind2comb()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ind2comb(comb, n):
    &#34;&#34;&#34;
    ** Eclate un rang en 2 indices **

    Notes
    -----
    * Bijection de ``comb2ind``.
    * Peut etre utile pour les methodes ``laue.core.geometry.transformer.Transformer.hough``
    et ``laue.core.geometry.transformer.Transformer.inter_lines``.
    * Risque de donner de faux resultats pour n trop grand.

    Parameters
    ----------
    comb : int ou np.ndarray(dtype=int)
        L&#39;indice, ie le (comb)ieme mot constitue 2 de symbols
        ajence comme decrit dans ``comb2ind``.
    n : int
        Le nombre de symboles.

    Returns
    -------
    int ou np.ndarray(dtype=int)
        Le premier des 2 indicices (``ind1``).
    int ou np.ndarray(dtype=int)
        Le second des 2 indicices (``ind2``). De sorte que ``comb2ind(ind1, ind2) == comb``.

    Examples
    --------
    &gt;&gt;&gt; from laue.core.geometry.transformer import ind2comb
    &gt;&gt;&gt; ind2comb(0, n=6)
    (0, 1)
    &gt;&gt;&gt; ind2comb(1, n=6)
    (0, 2)
    &gt;&gt;&gt; ind2comb(4, n=6)
    (0, 5)
    &gt;&gt;&gt; ind2comb(5, n=6)
    (1, 2)
    &gt;&gt;&gt; ind2comb(14, n=6)
    (4, 5)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(comb, (int, np.ndarray)), \
        f&#34;&#39;comb&#39; can not being of type {type(comb).__name__}.&#34;
    assert isinstance(n, int), f&#34;&#39;n&#39; has to ba an integer, not a {type(n).__name__}.&#34;
    if isinstance(comb, np.ndarray):
        assert comb.dtype == int or issubclass(comb.dtype.type, np.integer), f&#34;&#39;comb&#39; must be integer, not {str(comb.dtype)}.&#34;
        assert (comb &gt;= 0).all(), &#34;Tous les indices doivent etres positifs.&#34;
        assert (comb &lt; n*(n-1)/2).all(), (f&#34;Dans un alphabet a {n} symboles, il ne peut y a voir &#34;
            f&#34;que {n*(n-1)/2} mots. Le mot d&#39;indice {comb.max()} n&#39;existe donc pas!&#34;)
    else:
        assert comb &gt;= 0, &#34;Les indices doivent etre positifs.&#34;
        assert comb &lt; n*(n-1)/2, (f&#34;Dans un alphabet a {n} symboles, il ne peut y a voir &#34;
            f&#34;que {n*(n-1)/2} mots. Le mot d&#39;indice {comb} n&#39;existe donc pas!&#34;)

    homogeneous_int = lambda x: x.astype(int) if isinstance(x, np.ndarray) else int(x)
    ind1 = homogeneous_int(np.ceil(n - np.sqrt(-8*comb + 4*n**2 - 4*n - 7)/2 - 3/2))
    ind2 = comb + (ind1**2 + 3*ind1)//2 - ind1*n + 1
    return ind1, ind2</code></pre>
</details>
</dd>
<dt id="laue.core.inter_lines"><code class="name flex">
<span>def <span class="ident">inter_lines</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.inter_lines" href="geometry/index.html#laue.core.geometry.inter_lines">inter_lines()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inter_lines(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.inter_lines``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;inter_lines&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.thetachi_to_cam"><code class="name flex">
<span>def <span class="ident">thetachi_to_cam</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.thetachi_to_cam" href="geometry/index.html#laue.core.geometry.thetachi_to_cam">thetachi_to_cam()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thetachi_to_cam(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.thetachi_to_cam``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;thetachi_to_cam&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.core.thetachi_to_gnomonic"><code class="name flex">
<span>def <span class="ident">thetachi_to_gnomonic</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.thetachi_to_gnomonic" href="geometry/index.html#laue.core.geometry.thetachi_to_gnomonic">thetachi_to_gnomonic()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thetachi_to_gnomonic(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.thetachi_to_gnomonic``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;thetachi_to_gnomonic&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laue.core.Transformer"><code class="flex name class">
<span>class <span class="ident">Transformer</span></span>
<span>(</span><span>verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.transformer.Transformer" href="geometry/transformer.html#laue.core.geometry.transformer.Transformer">Transformer</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transformer(TransformerPickleable, Compilator):
    &#34;&#34;&#34;
    Permet d&#39;effectuer des transformations geometrique comme jongler
    entre l&#39;espace de la camera et l&#39;espace gnomonique ou encore
    s&#39;ammuser avec la transformee de Hough.
    &#34;&#34;&#34;
    def __init__(self, verbose=False):
        Compilator.__init__(self, verbose=verbose) # Globalisation des expressions.
        self.verbose = verbose

        # Les memoires tampon.
        self._fcts_cam_to_gnomonic = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(x_cam, y_cam), les parametres sont deja remplaces.
        self._fcts_gnomonic_to_cam = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(x_gnom, y_gnom), les parametres sont deja remplaces.
        self._fcts_cam_to_thetachi = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(x_cam, y_cam), les parametres sont deja remplaces.
        self._fcts_thetachi_to_cam = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(theta, chi), les parametres sont deja remplaces.
        self._parameters_memory = {} # Permet d&#39;eviter de relire le dictionaire des parametres a chaque fois.

    def compile(self, parameters=None, *, transform=None):
        &#34;&#34;&#34;
        ** Precalcul toutes les equations. **

        Parameters
        ----------
        parameters : dict, optional
            Les parametres donnes par la fonction ``laue.utilities.parsing.extract_parameters``.
            Si ils sont fourni, l&#39;expression est encore un peu
            plus optimisee.
        transform : str
            La fonction qu&#39;il faut particulierement optimiser. Si ce parametre n&#39;est
            pas fournis, toutes les fonctions sont optimisees.
            Peut prendre les valeurs: ``&#34;cam_to_gnomonic&#34;``, ``&#34;gnomonic_to_cam&#34;``,
            ``&#34;cam_to_thetachi&#34;`` ou ``&#34;thetachi_to_cam&#34;``.
        &#34;&#34;&#34;
        if parameters is not None:
            assert isinstance(parameters, dict), (&#34;Les parametres doivent founis &#34;
                f&#34;dans un dictionaire, pas dans un {type(parameters).__name__}&#34;)
            assert set(parameters) == {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;pixelsize&#34;}, \
                (&#34;Les clefs doivent etres &#39;dd&#39;, &#39;xbet&#39;, &#39;xgam&#39;, &#39;xcen&#39;, &#39;ycen&#39; et &#39;pixelsize&#39;. &#34;
                f&#34;Or les clefs sont {set(parameters)}.&#34;)
            assert all(isinstance(v, numbers.Number) for v in parameters.values()), \
                &#34;La valeurs des parametres doivent toutes etre des nombres.&#34;

            if transform is not None:
                assert isinstance(transform, str), f&#34;Doit etre str, pas {type(transform).__name__}.&#34;
                assert transform in {&#34;cam_to_gnomonic&#34;, &#34;gnomonic_to_cam&#34;,
                    &#34;cam_to_thetachi&#34;, &#34;thetachi_to_cam&#34;}, f&#34;Ne doit pas etre {transform}.&#34;

            hash_param = self._hash_parameters(parameters)
            constants = {self.dd: parameters[&#34;dd&#34;], # C&#39;est qu&#39;il est tant de faire de l&#39;optimisation.
                         self.xcen: parameters[&#34;xcen&#34;],
                         self.ycen: parameters[&#34;ycen&#34;],
                         self.xbet: parameters[&#34;xbet&#34;],
                         self.xgam: parameters[&#34;xgam&#34;],
                         self.pixelsize: parameters[&#34;pixelsize&#34;]}
            # Dans le cas ou l&#39;expression est deserialise, les pointeurs ne sont plus les memes.
            constants = {str(var): value for var, value in constants.items()}
            for trans, args in {
                    &#34;cam_to_gnomonic&#34;: (self.x_cam, self.y_cam),
                    &#34;gnomonic_to_cam&#34;: (self.x_gnom, self.y_gnom),
                    &#34;cam_to_thetachi&#34;: (self.x_cam, self.y_cam),
                    &#34;thetachi_to_cam&#34;: (self.theta, self.chi)
                    }.items():
                if transform is not None and trans != transform:
                    continue
                formal_expr = getattr(self, f&#34;get_fct_{trans}&#34;)()()
                subs = {symbol: constants[str(symbol)]
                    for symbol in set.union(*(e.free_symbols for e in formal_expr))
                    if str(symbol) in constants}
                getattr(self, f&#34;_fcts_{trans}&#34;)[hash_param] = lambdify.Lambdify(
                    args=args,
                    expr=lambdify.subs(formal_expr, subs))

    def cam_to_gnomonic(self, pxl_x, pxl_y, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points de la camera dans un plan gnomonic. **

        Parameters
        ----------
        pxl_x : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe x dans le repere de la camera. (en pxl)
        pxl_y : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe y dans le repere de la camera. (en pxl)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic exprimee.s en mm.
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.cam_to_gnomonic(x_cam, y_cam, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters, dtype=np.float64), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.cam_to_gnomonic(0.0, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
        ...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.cam_to_gnomonic(x_cam, y_cam, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;cam_to_gnomonic&#34;, pxl_x, pxl_y,
            parameters=parameters, dtype=dtype)

    def cam_to_thetachi(self, pxl_x, pxl_y, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points de la camera vers la representation theta et chi. **

        Parameters
        ----------
        pxl_x : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe x dans le repere de la camera. (en pxl)
        pxl_y : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe y dans le repere de la camera. (en pxl)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s theta puis chi du.des point.s. (en deg)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
        array([[ 64.,  60.,  51.,  39.,  30.,  26.],
               [ 49.,  35.,  13., -13., -35., -49.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters, dtype=np.float64))
        array([[ 64.,  60.,  51.,  39.,  30.,  26.],
               [ 49.,  35.,  13., -13., -35., -49.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.cam_to_thetachi(0.0, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
        ...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.cam_to_thetachi(x_cam, y_cam, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;cam_to_thetachi&#34;, pxl_x, pxl_y,
            parameters=parameters, dtype=dtype)

    def dist_cosine(self, theta_1, chi_1, theta_2, chi_2, *, dtype=np.float64):
        r&#34;&#34;&#34;
        ** Calcul les cosine-distances entre les familles de spot 1 et 2. **

        La distance entre 2 vecteurs est definie de la facon suivante:
        \[ \arccos{\left(\frac{\vec{u_1}.\vec{u_1}}{\left\|\vec{u_1}\right\|.\left\|\vec{u_2}\right\|}\right)} \]

        Parameters
        ----------
        theta_1 : np.ndarray
            Les angles theta des spots de la premiere famille. (en degre)
            shape = ``(*shape_fam_1)``
        chi_1 : np.ndarray
            Les angles chi des spots de la premiere famille. (en degre)
            shape = ``(*shape_fam_1)``
        theta_2 : np.ndarray
            Les angles theta des spots de la second famille. (en degre)
            shape = ``(*shape_fam_2)``
        chi_2 : np.ndarray
            Les angles chi des spots de la seconde famille. (en degre)
            shape = ``(*shape_fam_2)``
        dtype : type, optional
            La representation machine des nombres.
            Attention pour les calculs en float32, les arrondis
            risquent d&#39;etre importants.

        Returns
        -------
        np.ndarray
            Les cosine-distances entre les 2 familles de vecteurs. (en degre)
            shape = ``(*shape_fam_1, *shape_fam_2)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt;
        &gt;&gt;&gt; theta, chi = np.array([[ 63.605,  59.91 ,  51.367,  38.546,  30.05 ],
        ...                        [ 49.403,  34.97 ,  13.062, -13.248, -35.102]])
        &gt;&gt;&gt; np.round(transformer.dist_cosine(theta, chi, theta, chi), 5)
        array([[ 0.     ,  7.74103, 22.58762, 44.11754, 60.96129],
               [ 7.74103,  0.     , 14.91692, 36.82838, 54.46589],
               [22.58762, 14.91692,  0.     , 22.40912, 41.26854],
               [44.11754, 36.82838, 22.40912,  0.     , 19.88537],
               [60.96129, 54.46589, 41.26854, 19.88537,  0.     ]])
        &gt;&gt;&gt; transformer.dist_cosine(theta, chi, theta, chi, dtype=np.float16).dtype
        dtype(&#39;float16&#39;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; theta_1, chi_1 = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
        ...                   np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
        &gt;&gt;&gt; theta_2, chi_2 = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(3, 4, 5)),
        ...                   np.random.uniform(-np.pi/4, np.pi/4, size=(3, 4, 5)))
        &gt;&gt;&gt; transformer.dist_cosine(theta_1, chi_1, theta_2, chi_2).shape
        (1, 2, 3, 3, 4, 5)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(theta_1, np.ndarray), \
            f&#34;&#39;theta_1&#39; has to be of type np.ndarray, not {type(theta_1).__name__}.&#34;
        assert isinstance(chi_1, np.ndarray), \
            f&#34;&#39;chi_1&#39; has to be of type np.ndarray, not {type(chi_1).__name__}.&#34;
        assert theta_1.shape == chi_1.shape, \
            f&#34;Les 2 parametres de droite doivent avoir la meme taille: {theta_1.shape} vs {chi_1.shape}.&#34;
        assert isinstance(theta_2, np.ndarray), \
            f&#34;&#39;theta_2&#39; has to be of type np.ndarray, not {type(theta_2).__name__}.&#34;
        assert isinstance(chi_2, np.ndarray), \
            f&#34;&#39;chi_2&#39; has to be of type np.ndarray, not {type(chi_2).__name__}.&#34;
        assert theta_2.shape == chi_2.shape, \
            f&#34;Les 2 coordonnees des points doivent avoir la meme shape: {theta_2.shape} vs {chi_2.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        shape1, shape2 = theta_1.shape, theta_2.shape
        theta_1, theta_2 = np.meshgrid(theta_1.astype(dtype, copy=False), theta_2.astype(dtype, copy=False), indexing=&#34;ij&#34;, copy=False)
        chi_1, chi_2 = np.meshgrid(chi_1.astype(dtype, copy=False), chi_2.astype(dtype, copy=False), indexing=&#34;ij&#34;, copy=False)
        theta_1, chi_1 = theta_1.reshape((*shape1, *shape2)), chi_1.reshape((*shape1, *shape2))
        theta_2, chi_2 = theta_2.reshape((*shape1, *shape2)), chi_2.reshape((*shape1, *shape2))

        func = self.get_fct_dist_cosine()
        return np.nan_to_num(func(theta_1, chi_1, theta_2, chi_2), copy=False, nan=0.0)

    def dist_euclidian(self, x1, y1, x2, y2, *, dtype=np.float32):
        r&#34;&#34;&#34;
        ** Calcul les distances euclidiennes entre les familles de vecteur 1 et 2. **

        La distance entre 2 vecteurs est definie de la facon suivante:
        \[ \left\|\vec{u_1} - \vec{u_2}\right\| \]

        Parameters
        ----------
        x1 : np.ndarray
            Les coordonnees x des vecteurs de la premiere famille.
            shape = ``(*shape_fam_1)``
        y1 : np.ndarray
            Les coordonnees y des vecteurs de la premiere famille.
            shape = ``(*shape_fam_1)``
        x2 : np.ndarray
            Les coordonnees x des vecteurs de la seconde famille.
            shape = ``(*shape_fam_2)``
        y2 : np.ndarray
            Les coordonnees y des vecteurs de la seconde famille.
            shape = ``(*shape_fam_2)``
        dtype : type, optional
            La representation machine des nombres. Comme le calcul
            est simple et n&#39;engendre pas de gros arrondi, faire
            les calculs en float32 n&#39;est pas delirant.

        Returns
        -------
        np.ndarray
            Les distances entre les 2 familles de vecteurs.
            shape = ``(*shape_fam_1, *shape_fam_2)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt;
        &gt;&gt;&gt; x, y = np.linspace(-1, 1, 5), np.linspace(-1, 1, 5)
        &gt;&gt;&gt; transformer.dist_euclidian(x, y, x, y)
        array([[0.        , 0.70710677, 1.4142135 , 2.1213202 , 2.828427  ],
               [0.70710677, 0.        , 0.70710677, 1.4142135 , 2.1213202 ],
               [1.4142135 , 0.70710677, 0.        , 0.70710677, 1.4142135 ],
               [2.1213202 , 1.4142135 , 0.70710677, 0.        , 0.70710677],
               [2.828427  , 2.1213202 , 1.4142135 , 0.70710677, 0.        ]],
              dtype=float32)
        &gt;&gt;&gt; transformer.dist_euclidian(x, y, x, y, dtype=np.float16)
        array([[0.   , 0.707, 1.414, 2.121, 2.828],
               [0.707, 0.   , 0.707, 1.414, 2.121],
               [1.414, 0.707, 0.   , 0.707, 1.414],
               [2.121, 1.414, 0.707, 0.   , 0.707],
               [2.828, 2.121, 1.414, 0.707, 0.   ]], dtype=float16)
        &gt;&gt;&gt;
        &gt;&gt;&gt; x1, y1 = np.random.normal(size=(1, 2, 3)), np.random.normal(size=(1, 2, 3))
        &gt;&gt;&gt; x2, y2 = np.random.normal(size=(3, 4, 5)), np.random.normal(size=(3, 4, 5))
        &gt;&gt;&gt; transformer.dist_euclidian(x1, y1, x2, y2).shape
        (1, 2, 3, 3, 4, 5)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(x1, np.ndarray), \
            f&#34;&#39;x1&#39; has to be of type np.ndarray, not {type(x1).__name__}.&#34;
        assert isinstance(y1, np.ndarray), \
            f&#34;&#39;y1&#39; has to be of type np.ndarray, not {type(y1).__name__}.&#34;
        assert x1.shape == y1.shape, \
            f&#34;Les 2 parametres de droite doivent avoir la meme taille: {x1.shape} vs {y1.shape}.&#34;
        assert isinstance(x2, np.ndarray), \
            f&#34;&#39;x2&#39; has to be of type np.ndarray, not {type(x2).__name__}.&#34;
        assert isinstance(y2, np.ndarray), \
            f&#34;&#39;y2&#39; has to be of type np.ndarray, not {type(y2).__name__}.&#34;
        assert x2.shape == y2.shape, \
            f&#34;Les 2 coordonnees des points doivent avoir la meme shape: {x2.shape} vs {y2.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        shape1, shape2 = x1.shape, x2.shape
        x1, x2 = np.meshgrid(x1.astype(dtype, copy=False), x2.astype(dtype, copy=False), indexing=&#34;ij&#34;, copy=False)
        y1, y2 = np.meshgrid(y1.astype(dtype, copy=False), y2.astype(dtype, copy=False), indexing=&#34;ij&#34;, copy=False)
        x1, y1 = x1.reshape((*shape1, *shape2)), y1.reshape((*shape1, *shape2))
        x2, y2 = x2.reshape((*shape1, *shape2)), y2.reshape((*shape1, *shape2))

        func = self.get_fct_dist_euclidian()
        return func(x1, y1, x2, y2)

    def dist_line(self, phi_vect, mu_vect, x_vect, y_vect, *, dtype=np.float64):
        &#34;&#34;&#34;
        ** Calcul les distances projetees des points sur une droite. **

        Parameters
        ----------
        phi_vect : np.ndarray
            Les angles des droites normales aux droites principales.
            shape = ``(*nbr_droites)``
        mu_vect : np.ndarray
            Les distances entre les droites et l&#39;origine.
            shape = ``(*nbr_droites)``
        x_vect : np.ndarray
            L&#39;ensemble des coordonnees x des points.
            shape = ``(*nbr_points)``
        y_vect : np.ndarray
            L&#39;ensemble des coordonnees y des points.
            shape = ``(*nbr_points)``
        dtype : type, optional
            La representation machine des nombres.
            Attention pour les calculs en float32 et moins
            risque d&#39;y avoir des arrondis qui engendrent:
            ``RuntimeWarning: invalid value encountered in sqrt``.

        Returns
        -------
        np.ndarray
            Les distances des projetees des points sur chacunes des droites.
            shape = ``(*nbr_droites, *nbr_points)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt;
        &gt;&gt;&gt; lines = (np.array([0, np.pi/2]), np.array([1, 1])) # Horizontale et verticale passant par (1, 1)
        &gt;&gt;&gt; points = (np.array([0, 1, 3, 0]), np.array([0, 1, 3, 1])) # Le points (0, 1), ...
        &gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points))
        array([[1., 0., 2., 1.],
               [1., 0., 2., 0.]])
        &gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points, dtype=np.float32))
        array([[1., 0., 2., 1.],
               [1., 0., 2., 0.]], dtype=float32)
        &gt;&gt;&gt;
        &gt;&gt;&gt; phi_vect, mu_vect = np.random.normal(size=(1, 2)), np.random.normal(size=(1, 2))
        &gt;&gt;&gt; x_vect, y_vect = np.random.normal(size=(3, 4, 5)), np.random.normal(size=(3, 4, 5))
        &gt;&gt;&gt; transformer.dist_line(phi_vect, mu_vect, x_vect, y_vect).shape
        (1, 2, 3, 4, 5)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(phi_vect, np.ndarray), \
            f&#34;&#39;phi_vect&#39; has to be of type np.ndarray, not {type(phi_vect).__name__}.&#34;
        assert isinstance(mu_vect, np.ndarray), \
            f&#34;&#39;mu_vect&#39; has to be of type np.ndarray, not {type(mu_vect).__name__}.&#34;
        assert phi_vect.shape == mu_vect.shape, \
            f&#34;Les 2 parametres de droite doivent avoir la meme taille: {phi_vect.shape} vs {mu_vect.shape}.&#34;
        assert isinstance(x_vect, np.ndarray), \
            f&#34;&#39;x_vect&#39; has to be of type np.ndarray, not {type(x_vect).__name__}.&#34;
        assert isinstance(y_vect, np.ndarray), \
            f&#34;&#39;y_vect&#39; has to be of type np.ndarray, not {type(y_vect).__name__}.&#34;
        assert x_vect.shape == y_vect.shape, \
            f&#34;Les 2 coordonnees des points doivent avoir la meme shape: {x_vect.shape} vs {y_vect.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        phi_vect, mu_vect = phi_vect.astype(dtype, copy=False), mu_vect.astype(dtype, copy=False)
        x_vect, y_vect = x_vect.astype(dtype, copy=False), y_vect.astype(dtype, copy=False)

        nbr_droites = phi_vect.shape
        nbr_points = x_vect.shape

        # Ca ne vaut pas le coup de paralleliser car c&#39;est tres rapide.
        func = self.get_fct_dist_line()
        result = np.array([func(phi, mu, x_vect, y_vect)
                           for phi, mu
                           in zip(phi_vect.ravel(), mu_vect.ravel())
                          ], dtype=dtype).reshape((*nbr_droites, *nbr_points))
        return np.nan_to_num(result, copy=False, nan=0.0)

    def gnomonic_to_cam(self, gnom_x, gnom_y, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points du plan gnomonic vers la camera. **

        Parameters
        ----------
        gnom_x : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe x du repere du plan gnomonic. (en mm)
        gnom_y : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe y du repere du plan gnomonic. (en mm)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        coords : np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
        ...                              0.09978235,  0.17156848,  0.13417314 ],
        ...                            [ 0.40283853,  0.31846303,  0.14362221, 
        ...                             -0.18308422, -0.58226374, -0.93854752 ]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters, dtype=np.float64))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.gnomonic_to_cam(0.0, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
        ...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.gnomonic_to_cam(x_cam, y_cam, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;gnomonic_to_cam&#34;, gnom_x, gnom_y,
            parameters=parameters, dtype=dtype)

    def gnomonic_to_thetachi(self, gnom_x, gnom_y, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points du plan gnomonic vers theta et chi. **

        Parameters
        ----------
        gnom_x : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe x du repere du plan gnomonic. (en mm)
        gnom_y : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe y du repere du plan gnomonic. (en mm)
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s theta puis chi du.des point.s. (en deg)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
        ...                              0.09978235,  0.17156848,  0.13417314 ],
        ...                            [ 0.40283853,  0.31846303,  0.14362221, 
        ...                             -0.18308422, -0.58226374, -0.93854752 ]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
        array([[ 64.,  60.,  51.,  39.,  30.,  26.],
               [ 49.,  35.,  13., -13., -35., -49.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom, dtype=np.float64))
        array([[ 64.,  60.,  51.,  39.,  30.,  26.],
               [ 49.,  35.,  13., -13., -35., -49.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.gnomonic_to_thetachi(0.0, 0.0).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
        ...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.gnomonic_to_thetachi(x_cam, y_cam).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;gnomonic_to_thetachi&#34;, gnom_x, gnom_y,
            parameters=None, dtype=dtype)

    def hough(self, x_vect, y_vect, *, dtype=np.float64):
        r&#34;&#34;&#34;
        ** Transformee de hough avec des droites. **

        Note
        ----
        * Pour des raisons de performances, les calculs se font sur des float32.
        * Les indices sont agences selon l&#39;ordre defini par la fonction ``comb2ind``.

        Parameters
        ----------
        x_vect : np.ndarray
            L&#39;ensemble des coordonnees x des points de shape: (*over_dims, nbr_points)
        y_vect : np.ndarray
            L&#39;ensemble des coordonnees y des points de shape: (*over_dims, nbr_points)
        dtype : type, optional
            La representation machine des nombres.
            Attention pour les calculs en float32 et moins
            risque d&#39;y avoir des arrondis qui engendrent:
            ``RuntimeWarning: invalid value encountered in sqrt``.

        Returns
        -------
        np.ndarray
            * phi : np.ndarray
                * Les angles au sens trigomometrique des vecteurs reliant l&#39;origine
                ``O`` (0, 0) au point ``P`` appartenant a la droite tel que ``||OP||``
                soit la plus petite possible.
                * phi € ]-pi, pi]
                * shape = ``(*over_dims, n*(n-1)/2)``
            * lamb : np.ndarray
                * Ce sont les normes des vecteur ``OP``.
                * lamb € [0, +oo].
                * shape = ``(*over_dims, n*(n-1)/2)``
            * Ces 2 grandeurs sont concatenees dans une seule array de
        shape = ``(2, *over_dims, n*(n-1)/2)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry import transformer
        &gt;&gt;&gt; transformer = transformer.Transformer()
        &gt;&gt;&gt; x, y = np.random.normal(size=(2, 6))
        &gt;&gt;&gt; transformer.hough(x, y).shape
        (2, 15)
        &gt;&gt;&gt;
        &gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
        &gt;&gt;&gt; transformer.hough(x, y).shape
        (2, 4, 5, 15)
        &gt;&gt;&gt; 
        &#34;&#34;&#34;
        assert isinstance(x_vect, np.ndarray), \
            f&#34;&#39;x_vect&#39; has to be of type np.ndarray, not {type(x_vect).__name__}.&#34;
        assert isinstance(y_vect, np.ndarray), \
            f&#34;&#39;y_vect&#39; has to be of type np.ndarray, not {type(y_vect).__name__}.&#34;
        assert x_vect.shape == y_vect.shape, \
            f&#34;Les 2 entrees doivent avoir la meme taille: {x_vect.shape} vs {y_vect.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        n = x_vect.shape[-1]
        if n == 1:
            over_dims = x_vect.shape[:-1]
            clusters = np.empty(np.prod(over_dims, dtype=int), dtype=object)
            clusters[:] = [[] for _ in range(clusters.size)]
            clusters = clusters.reshape(over_dims)
            return clusters
        
        x_vect, y_vect = x_vect.astype(dtype, copy=False), y_vect.astype(dtype, copy=False)

        xa = np.concatenate([np.repeat(x_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        ya = np.concatenate([np.repeat(y_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        xb = np.concatenate([x_vect[..., i+1:] for i in range(n-1)], axis=-1)
        yb = np.concatenate([y_vect[..., i+1:] for i in range(n-1)], axis=-1)

        return np.nan_to_num(
            np.stack(self.get_fct_hough()(xa, ya, xb, yb)),
            copy=False,
            nan=0.0)

    def hough_reduce(self, phi_vect, mu_vect, *, nbr=4, tol=0.018, dtype=np.float32):
        &#34;&#34;&#34;
        ** Regroupe des droites ressemblantes. **

        Notes
        -----
        * Cette methode est concue pour traiter les donnees issues de ``laue.core.geometry.transformer.Transformer.hough``.
        * La metrique utilise est la distance euclidiene sur un cylindre ferme sur phi.
        * En raison de performance et de memoire, les calculs se font sur des float32.

        Parameters
        ----------
        phi_vect : np.ndarray
            * Vecteur des angles compris entre [-pi, pi].
            * shape = ``(*over_dims, nbr_inter)``
        mu_vect : np.ndarray
            * Vecteur des distances des droites a l&#39;origine comprises [0, +oo].
            * shape = ``(*over_dims, nbr_inter)``
        tol : float
            La distance maximal separant 2 points dans l&#39;espace de hough reduit,
            (ie la difference entre 2 droites dans l&#39;espace spacial) tel que les points
            se retrouvent dans le meme cluster. Plus ce nombre est petit, plus les points
            doivent etre bien alignes. C&#39;est une sorte de tolerance sur l&#39;alignement.
        nbr : int
            C&#39;est le nombre minimum de points presque alignes pour que
            l&#39;on puisse considerer la droite qui passe par ces points.
            Par defaut, les droites qui ne passent que par 4 points et plus sont retenues.
        dtype : type, optional
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64``.
            ``np.float128`` est interdit car c&#39;est un peu over-kill pour cette methode!

        Returns
        -------
        np.ndarray(dtype=float), np.ndarray(dtype=object)
            * Ce sont les centres des clusters pour chaque &#39;nuages de points&#39;. Cela correspond
            aux angles et aux distances qui caracterisent chaque droites.
            * Si les parametres d&#39;entres sont des vecteurs 1d, le resultat sera une array
            numpy contenant les **angles** puis les **distances**. Donc de shape = ``(2, nbr_clusters)``
            * Si les parametres d&#39;entres sont en plusieur dimensions, (representes plusieur
            nuages de points indepandant), alors le resultat sera une array d&#39;objet de
            shape = ``(*over_dims)``. Chaque objet est lui meme un array, resultat recursif
            de l&#39;appel de cette fonction sur le nuage de points unique correspondant.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry import transformer
        &gt;&gt;&gt; transformer = transformer.Transformer()

        Type de retour ``float`` vs ``object``.
        &gt;&gt;&gt; x, y = (np.array([ 1.,  2.,  3.,  0., -1.]),
        ...         np.array([ 0.,  1.,  1., -1.,  1.]))
        &gt;&gt;&gt; phi, mu = transformer.hough(x, y)
        &gt;&gt;&gt; np.round(transformer.hough_reduce(phi, mu, nbr=3), 2)
        array([[-0.79,  1.57],
               [ 0.71,  1.  ]], dtype=float32)
        &gt;&gt;&gt; res = transformer.hough_reduce(phi.reshape((1, -1)), mu.reshape((1, -1)), nbr=3)
        &gt;&gt;&gt; res.dtype
        dtype(&#39;O&#39;)
        &gt;&gt;&gt; res.shape
        (1,)
        &gt;&gt;&gt; np.round(res[0], 2)
        array([[-0.79,  1.57],
               [ 0.71,  1.  ]], dtype=float32)
        &gt;&gt;&gt;

        Les dimensions de retour.
        &gt;&gt;&gt; x, y = (np.random.normal(size=(6, 5, 4)),
        ...         np.random.normal(size=(6, 5, 4)))
        &gt;&gt;&gt; phi, mu = transformer.hough(x, y)
        &gt;&gt;&gt; transformer.hough_reduce(phi, mu).shape
        (6, 5)
        &gt;&gt;&gt; 
        &#34;&#34;&#34;
        assert isinstance(phi_vect, np.ndarray), \
            f&#34;&#39;phi_vect&#39; has to be of type np.ndarray, not {type(phi_vect).__name__}.&#34;
        assert isinstance(mu_vect, np.ndarray), \
            f&#34;&#39;mu_vect&#39; has to be of type np.ndarray, not {type(mu_vect).__name__}.&#34;
        assert phi_vect.shape == mu_vect.shape, \
            f&#34;Les 2 entrees doivent avoir la meme taille: {phi_vect.shape} vs {mu_vect.shape}.&#34;
        assert phi_vect.ndim &gt;= 1, &#34;La matrice ne doit pas etre vide.&#34;
        assert isinstance(tol, float), f&#34;&#39;tol&#39; has to be a float, not a {type(tol).__name__}.&#34;
        assert 0.0 &lt; tol &lt;= 0.5, (&#34;Les valeurs coherentes de &#39;tol&#39; se trouvent entre &#34;
            f&#34;]0, 1/2], or tol vaut {tol}, ce qui sort de cet intervalle.&#34;)
        assert isinstance(nbr, int), f&#34;&#39;nbr&#39; has to be an integer, not a {type(nbr).__name__}.&#34;
        assert 2 &lt; nbr, f&#34;2 points sont toujours alignes! Vous ne pouvez pas choisir nbr={nbr}.&#34;
        assert dtype in {np.float16, np.float32, np.float64}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64. Pas {dtype}.&#34;

        # On fait la conversion des le debut pour un gain de temps.
        phi_vect, mu_vect = phi_vect.astype(dtype, copy=False), mu_vect.astype(dtype, copy=False)

        *over_dims, nbr_inter = phi_vect.shape # Recuperation des dimensions.
        nbr = (nbr*(nbr-1))/2 # On converti le nombre de points alignes en nbr de segments.

        # On commence par travailler avec les donnees reduites.
        phi_theo_std = math.pi / math.sqrt(3) # Variance theorique = (math.pi - -math.pi)**2 / 12
        mu_std = np.nanstd(mu_vect, axis=-1) # Ecart type non biaise (sum(*over_dims)/N), shape: (*over_dims)
        mu_vect = (mu_vect * phi_theo_std
            / np.repeat(mu_std[..., np.newaxis], nbr_inter, axis=-1)) # Les distances quasi reduites.
        
        # Extraction des clusters.
        if not len(over_dims): # Cas des tableaux 1d.
            return self._clustering_1d(phi_vect, mu_vect, mu_std, tol, nbr)

        clusters = np.empty(np.prod(over_dims, dtype=int), dtype=object) # On doit d&#39;abord creer un tableau d&#39;objet 1d.
        if multiprocessing.current_process().name == &#34;MainProcess&#34; and np.prod(over_dims) &gt;= os.cpu_count(): # Si ca vaut le coup de parraleliser:
            ser_self = cloudpickle.dumps(self) # Strategie car &#39;pickle&#39; ne sais pas faire ca.
            from laue.utilities.multi_core import pickleable_method
            with multiprocessing.Pool() as pool:
                clusters[:] = pool.map(
                    pickleable_method, # Car si il y a autant de cluster dans chaque image,
                    (                   # numpy aurait envi de faire un tableau 2d plutot qu&#39;un vecteur de listes.
                        (
                            Transformer._clustering_1d,
                            ser_self,
                            {&#34;phi_vect_1d&#34;:phi, &#34;mu_vect_1d&#34;:mu, &#34;std&#34;:std, &#34;tol&#34;:tol, &#34;nbr&#34;:nbr}
                        )
                        for phi, mu, std
                        in zip(
                            phi_vect.reshape((-1, nbr_inter)),
                            mu_vect.reshape((-1, nbr_inter)),
                            np.nditer(mu_std)
                        )
                    )
                )
        else:
            clusters[:] = [self._clustering_1d(chi, mu, std, tol, nbr)
                           for chi, mu, std in zip(
                                    phi_vect.reshape((-1, nbr_inter)),
                                    mu_vect.reshape((-1, nbr_inter)),
                                    np.nditer(mu_std))] 
        clusters = clusters.reshape(over_dims) # On redimensione a la fin de sorte a garentir les dimensions.

        return clusters

    def inter_lines(self, phi_vect, mu_vect, *, dtype=np.float32):
        r&#34;&#34;&#34;
        ** Calcul les points d&#39;intersection entre les droites. **

        Notes
        -----
        * Cette methode est concue pour traiter les donnees issues de ``laue.core.geometry.transformer.Transformer.hough``.
        * En raison de performance et de memoire, les calculs se font sur des float32.
        * Les indices sont agences selon l&#39;ordre defini par la fonction ``comb2ind``.

        Parameters
        ----------
        phi_vect : np.ndarray
            * Vecteur des angles compris entre [-pi, pi].
            * shape = (*over_dims, nbr_droites)
        mu_vect : np.ndarray
            * Vecteur des distances des droites a l&#39;origine comprises [0, +oo].
            * shape = (*over_dims, nbr_droites)
        dtype : type, optional
            La representation machine des nombres. Par defaut
            ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser
            ``np.float64`` ou ``(getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)``.

        Returns
        -------
        np.ndarray
            * Dans le dommaine spatial et non pas le domaine de hough, cherche
            les intersections des droites. Il y a ``n*(n-1)/2`` intersections, n etant
            le nombre de droites. donc la complexite de cette methode est en ``o(n**2)``.
            * Si les vecteurs d&#39;entre sont des vecteurs 1d (ie ``*over_dims == ()``), 
            Seront retournes le vecteur d&#39;intersection selon l&#39;axe x et le vecteur
            des intersections selon l&#39;axe y. Ces 2 vecteurs de meme taille sont concatenes
            sous la forme d&#39;une matrice de shape = ``(2, n*(n-1)/2)``.
            * Si les vecteurs d&#39;entre sont en plusieurs dimensions, seul les droites de la
            derniere dimensions se retrouvent dans la meme famille. Tous comme pour les
            vecteurs 1d, on trouve d&#39;abord les intersections selon x puis en suite selon y.
            La shape du tenseur final est donc: ** shape = ``(2, *over_dims, n*(n-1)/2)`` **.

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; np.random.seed(0)
        &gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
        &gt;&gt;&gt; phi, mu = transformer.hough(x, y)
        &gt;&gt;&gt; phi.shape
        (4, 5, 15)
        &gt;&gt;&gt; transformer.inter_lines(phi, mu).shape
        (2, 4, 5, 105)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(phi_vect, np.ndarray), \
            f&#34;&#39;phi_vect&#39; has to be of type np.ndarray, not {type(phi_vect).__name__}.&#34;
        assert isinstance(mu_vect, np.ndarray), \
            f&#34;&#39;mu_vect&#39; has to be of type np.ndarray, not {type(mu_vect).__name__}.&#34;
        assert phi_vect.shape == mu_vect.shape, \
            f&#34;Les 2 entrees doivent avoir la meme taille: {phi_vect.shape} vs {mu_vect.shape}.&#34;
        assert phi_vect.ndim &gt;= 1, &#34;La matrice ne doit pas etre vide.&#34;
        assert phi_vect.shape[-1] &gt;= 2, \
            f&#34;Il doit y avoir au moins 2 droites par famille, pas {phi_vect.shape[-1]}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        phi_vect, mu_vect = phi_vect.astype(dtype, copy=False), mu_vect.astype(dtype, copy=False)
        n = phi_vect.shape[-1]

        phi_1 = np.concatenate([np.repeat(phi_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        mu_1 = np.concatenate([np.repeat(mu_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        phi_2 = np.concatenate([phi_vect[..., i+1:] for i in range(n-1)], axis=-1)
        mu_2 = np.concatenate([mu_vect[..., i+1:] for i in range(n-1)], axis=-1)

        return np.stack(self.get_fct_inter_line()(phi_1, mu_1, phi_2, mu_2))

    def thetachi_to_cam(self, theta, chi, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe de la representation theta et chi vers la camera. **

        Parameters
        ----------
        theta : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de y. (en deg)
        chi : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de x. (en deg)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        coords : np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; theta, chi = np.array([[ 63.605,  59.91 ,  51.367,  38.546,  30.05 ,  26.378],
        ...                        [ 49.403,  34.97 ,  13.062, -13.248, -35.102, -49.486]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.thetachi_to_cam(theta, chi, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters, dtype=np.float64))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.thetachi_to_cam(np.pi/4, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
        ...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.thetachi_to_cam(theta, chi, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;thetachi_to_cam&#34;, theta, chi,
            parameters=parameters, dtype=dtype)

    def thetachi_to_gnomonic(self, theta, chi, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe de la representation theta et chi vers une projection gnomonique. **

        Parameters
        ----------
        theta : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de y. (en deg)
        chi : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de x. (en deg)
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic exprimee.s en mm.
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; theta, chi = np.array([[ 63.605,  59.91 ,  51.367,  38.546,  30.05 ,  26.378],
        ...                        [ 49.403,  34.97 ,  13.062, -13.248, -35.102, -49.486]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.thetachi_to_gnomonic(theta, chi))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi, dtype=np.float64), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.thetachi_to_gnomonic(np.pi/4, 0.0).shape
        (2,)
        &gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
        ...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.thetachi_to_gnomonic(theta, chi).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;thetachi_to_gnomonic&#34;, theta, chi,
            parameters=None, dtype=dtype)

    def _clustering_1d(self, phi_vect_1d, mu_vect_1d, std, tol, nbr):
        &#34;&#34;&#34;
        ** Help for hough_reduce. **

        * Permet de trouver les clusters d&#39;un nuage de points.
        * La projection 3d, bien que moins realiste, est 20% plus rapide que la distance reele.
        &#34;&#34;&#34;
        from sklearn.cluster import DBSCAN

        dtype_catser = phi_vect_1d.dtype.type
        PHI_STD = dtype_catser(math.pi / math.sqrt(3))
        WEIGHT = 0.65 # 0 =&gt; tres souple sur les angles, 1=&gt; tres souple sur les distances.

        # On retire les droites aberantes.
        mask_to_keep = np.isfinite(phi_vect_1d) &amp; np.isfinite(mu_vect_1d)
        if not mask_to_keep.any(): # Si il ne reste plus rien.
            return np.array([], dtype=dtype_catser)
        phi_vect_1d, mu_vect_1d = phi_vect_1d[mask_to_keep], mu_vect_1d[mask_to_keep]

        # On passe dans un autre repere de facon a ce que -pi et pi se retrouvent a cote.
        if numexpr is not None:
            phi_x = numexpr.evaluate(&#34;2*WEIGHT*cos(phi_vect_1d)&#34;)
            phi_y = numexpr.evaluate(&#34;2*WEIGHT*sin(phi_vect_1d)&#34;)
        else:
            phi_x, phi_y = 2*WEIGHT*np.cos(phi_vect_1d), 2*WEIGHT*np.sin(phi_vect_1d)

        # Recherche des clusters.
        n_jobs = -1 if multiprocessing.current_process().name == &#34;MainProcess&#34; else 1
        db_res = DBSCAN(eps=tol, min_samples=nbr, n_jobs=n_jobs).fit(
            np.vstack((phi_x, phi_y, 2*(1-WEIGHT)*mu_vect_1d)).transpose())

        # Mise en forme des clusters.
        clusters_dict = collections.defaultdict(lambda: [])
        keep = db_res.labels_ != -1 # Les indices des clusters a garder.
        for x_cyl, y_cyl, mu, group in zip(
                phi_x[keep], phi_y[keep], mu_vect_1d[keep], db_res.labels_[keep]):
            clusters_dict[group].append((x_cyl, y_cyl, mu))

        phi = np.array([np.arccos(cluster[:, 0].mean()/(2*WEIGHT))*np.sign(cluster[:, 1].sum())
                    for cluster in map(np.array, clusters_dict.values())],
                    dtype=dtype_catser)
        mu = np.array([cluster[:, 2].mean()
                        for cluster in map(np.array, clusters_dict.values())],
                    dtype=dtype_catser) * std / PHI_STD
        return np.array([phi, mu], dtype=dtype_catser)

    def _generic_transformation(self, transform, data1, data2, *, parameters, dtype):
        &#34;&#34;&#34;
        ** Passe d&#39;un espace de representation a un autre. **

        Help for ``Transformer.truc_to_machin``.

        Notes
        -----
        Fait les verifications.
        &#34;&#34;&#34;
        assert isinstance(data1, (float, int, np.ndarray)), \
            f&#34;&#39;data1&#39; can not be of type {type(data1).__name__}.&#34;
        assert isinstance(data2, (float, int, np.ndarray)), \
            f&#34;&#39;data2&#39; can not be of type {type(data2).__name__}.&#34;
        assert type(data1) == type(data2), \
            f&#34;Les 2 types sont differents: {type(data1).__name__} vs {type(data2).__name__}.&#34;
        if isinstance(data1, np.ndarray):
            assert data1.shape == data2.shape, \
                f&#34;Ils n&#39;ont pas le meme taille: {data1.shape} vs {data2.shape}.&#34;
        if parameters is not None:
            assert isinstance(parameters, dict), (&#34;Les parametres doivent founis &#34;
                f&#34;dans un dictionaire, pas dans un {type(parameters).__name__}&#34;)
            assert set(parameters) == {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;pixelsize&#34;}, \
                (&#34;Les clefs doivent etres &#39;dd&#39;, &#39;xbet&#39;, &#39;xgam&#39;, &#39;xcen&#39;, &#39;ycen&#39; et &#39;pixelsize&#39;. &#34;
                f&#34;Or les clefs sont {set(parameters)}.&#34;)
            assert all(isinstance(v, numbers.Number) for v in parameters.values()), \
                &#34;La valeurs des parametres doivent toutes etre des nombres.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        if isinstance(data1, np.ndarray):
            data1, data2 = data1.astype(dtype, copy=False), data2.astype(dtype, copy=False)
        else:
            data1, data2 = dtype(data1), dtype(data2)
        
        if parameters is not None:
            parameters = {k: dtype(v) for k, v in parameters.items()} # Pour eviter par la suite de mauvais casts.
            hash_param = self._hash_parameters(parameters) # Recuperation de la &#39;signature&#39; des parametres.
            optimized_func = getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param] # On regarde si il y a une fonction deja optimisee.

            if isinstance(optimized_func, int): # Si il n&#39;y a pas de fonction optimisee.
                nbr_access = optimized_func # Ce qui est enregistre et le nombre de fois que l&#39;on a chercher a y acceder.
                getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param] += 1 # Comme on cherche a y acceder actuelement, on peut incrementer le compteur.
                if nbr_access + 1 == 4: # Si c&#39;est la 4 eme fois qu&#39;on accede a la fonction.
                    self.compile(parameters, transform=transform) # On optimise la fonction.
                else: # Si ce n&#39;est pas encore le moment de perdre du temps a optimiser.
                    return np.stack(getattr(self, f&#34;get_fct_{transform}&#34;)()(
                        data1, data2,
                        parameters[&#34;dd&#34;], parameters[&#34;xcen&#34;], parameters[&#34;ycen&#34;],
                        parameters[&#34;xbet&#34;], parameters[&#34;xgam&#34;], parameters[&#34;pixelsize&#34;]))

            return np.stack(getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param](data1, data2))

        return np.stack(getattr(self, f&#34;get_fct_{transform}&#34;)()(data1, data2))

    def _hash_parameters(self, parameters):
        &#34;&#34;&#34;
        ** Hache le dictionaire des parametres. **

        * Il n&#39;y a pas de verification pour des histoires de performances.

        Parameters
        ----------
        parameters : dict
            Dictionaire des parametres issues de ``laue.utilities.parsing.extract_parameters``.

        Returns
        -------
        int
            Un identifiant tq 2 dictionaires identiques renvoient le meme id.
        &#34;&#34;&#34;
        return hash(( # Il faut imperativement garantir l&#39;ordre.
            parameters[&#34;dd&#34;],
            parameters[&#34;xcen&#34;],
            parameters[&#34;ycen&#34;],
            parameters[&#34;xbet&#34;],
            parameters[&#34;xgam&#34;],
            parameters[&#34;pixelsize&#34;]))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="laue.utilities.serialization.TransformerPickleable" href="../utilities/serialization.html#laue.utilities.serialization.TransformerPickleable">TransformerPickleable</a></li>
<li><a title="laue.core.geometry.symbolic.Compilator" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator">Compilator</a></li>
<li><a title="laue.core.geometry.symbolic.Equations" href="geometry/symbolic.html#laue.core.geometry.symbolic.Equations">Equations</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="laue.utilities.serialization.TransformerPickleable" href="../utilities/serialization.html#laue.utilities.serialization.TransformerPickleable">TransformerPickleable</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.utilities.serialization.TransformerPickleable.__getstate__" href="../utilities/serialization.html#laue.utilities.serialization.TransformerPickleable.__getstate__">__getstate__</a></code></li>
<li><code><a title="laue.utilities.serialization.TransformerPickleable.__setstate__" href="../utilities/serialization.html#laue.utilities.serialization.TransformerPickleable.__setstate__">__setstate__</a></code></li>
</ul>
</li>
<li><code><b><a title="laue.core.geometry.symbolic.Compilator" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator">Compilator</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_cam_to_uf" href="geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_cam_to_uf">get_expr_cam_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_gnomonic_to_uq" href="geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_gnomonic_to_uq">get_expr_gnomonic_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_thetachi_to_uf" href="geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_thetachi_to_uf">get_expr_thetachi_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uf_to_cam" href="geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uf_to_cam">get_expr_uf_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uf_to_thetachi" href="geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uf_to_thetachi">get_expr_uf_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uf_to_uq" href="geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uf_to_uq">get_expr_uf_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uq_to_gnomonic" href="geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uq_to_gnomonic">get_expr_uq_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uq_to_uf" href="geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uq_to_uf">get_expr_uq_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_gnomonic" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_cam_to_gnomonic">get_fct_cam_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_thetachi" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_cam_to_thetachi">get_fct_cam_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_dist_cosine" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_dist_cosine">get_fct_dist_cosine</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_dist_euclidian" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_dist_euclidian">get_fct_dist_euclidian</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_dist_line" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_dist_line">get_fct_dist_line</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_cam" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_cam">get_fct_gnomonic_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_thetachi" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_thetachi">get_fct_gnomonic_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_hough" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_hough">get_fct_hough</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_inter_line" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_inter_line">get_fct_inter_line</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_cam" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_cam">get_fct_thetachi_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_gnomonic" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_gnomonic">get_fct_thetachi_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.load" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.load">load</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.save" href="geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#calculs-de-base-de-la-separation-de-grains">Calculs de base de la separation de grains.</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laue" href="../index.html">laue</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="laue.core.geometry" href="geometry/index.html">laue.core.geometry</a></code></li>
<li><code><a title="laue.core.hkl_nn" href="hkl_nn/index.html">laue.core.hkl_nn</a></code></li>
<li><code><a title="laue.core.pic_search" href="pic_search.html">laue.core.pic_search</a></code></li>
<li><code><a title="laue.core.subsets" href="subsets.html">laue.core.subsets</a></code></li>
<li><code><a title="laue.core.zone_axes" href="zone_axes.html">laue.core.zone_axes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laue.core.atomic_find_subsets" href="#laue.core.atomic_find_subsets">atomic_find_subsets</a></code></li>
<li><code><a title="laue.core.atomic_find_zone_axes" href="#laue.core.atomic_find_zone_axes">atomic_find_zone_axes</a></code></li>
<li><code><a title="laue.core.atomic_pic_search" href="#laue.core.atomic_pic_search">atomic_pic_search</a></code></li>
<li><code><a title="laue.core.cam_to_gnomonic" href="#laue.core.cam_to_gnomonic">cam_to_gnomonic</a></code></li>
<li><code><a title="laue.core.cam_to_thetachi" href="#laue.core.cam_to_thetachi">cam_to_thetachi</a></code></li>
<li><code><a title="laue.core.comb2ind" href="#laue.core.comb2ind">comb2ind</a></code></li>
<li><code><a title="laue.core.dist_cosine" href="#laue.core.dist_cosine">dist_cosine</a></code></li>
<li><code><a title="laue.core.dist_euclidian" href="#laue.core.dist_euclidian">dist_euclidian</a></code></li>
<li><code><a title="laue.core.dist_line" href="#laue.core.dist_line">dist_line</a></code></li>
<li><code><a title="laue.core.gnomonic_to_cam" href="#laue.core.gnomonic_to_cam">gnomonic_to_cam</a></code></li>
<li><code><a title="laue.core.gnomonic_to_thetachi" href="#laue.core.gnomonic_to_thetachi">gnomonic_to_thetachi</a></code></li>
<li><code><a title="laue.core.hough" href="#laue.core.hough">hough</a></code></li>
<li><code><a title="laue.core.hough_reduce" href="#laue.core.hough_reduce">hough_reduce</a></code></li>
<li><code><a title="laue.core.ind2comb" href="#laue.core.ind2comb">ind2comb</a></code></li>
<li><code><a title="laue.core.inter_lines" href="#laue.core.inter_lines">inter_lines</a></code></li>
<li><code><a title="laue.core.thetachi_to_cam" href="#laue.core.thetachi_to_cam">thetachi_to_cam</a></code></li>
<li><code><a title="laue.core.thetachi_to_gnomonic" href="#laue.core.thetachi_to_gnomonic">thetachi_to_gnomonic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laue.core.Transformer" href="#laue.core.Transformer">Transformer</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>