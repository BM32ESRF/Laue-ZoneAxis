<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>laue.utilities.lambdify API documentation</title>
<meta name="description" content="** Permet de faire un pont entre le calcul symbolique et matriciel. **
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laue.utilities.lambdify</code></h1>
</header>
<section id="section-intro">
<h2 id="permet-de-faire-un-pont-entre-le-calcul-symbolique-et-matriciel"><strong> Permet de faire un pont entre le calcul symbolique et matriciel. </strong></h2>
<p>Est capable de metre en forme les expressions symbolique <code>sympy</code> de sorte
a maximiser les performances.</p>
<h2 id="notes">Notes</h2>
<p>Si le module <code>numexpr</code> est installe, certaines optimisations pouront etre faites.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
** Permet de faire un pont entre le calcul symbolique et matriciel. **
----------------------------------------------------------------------

Est capable de metre en forme les expressions symbolique ``sympy`` de sorte
a maximiser les performances.

Notes
-----
Si le module ``numexpr`` est installe, certaines optimisations pouront etre faites.
&#34;&#34;&#34;

import itertools
import multiprocessing
import numbers
import os
import pickle
import timeit

import numpy as np
import sympy

import laue
from laue.utilities.fork_lambdify import lambdify
from laue.utilities.multi_core import NestablePool as Pool


__pdoc__ = {&#34;Lambdify.__getstate__&#34;: True,
            &#34;Lambdify.__setstate__&#34;: True,
            &#34;Lambdify.__call__&#34;: True,
            &#34;Lambdify.__str__&#34;: True,
            &#34;evalf&#34;: False,
            &#34;subs&#34;: False}


def _generalize(f):
    def f_bis(x, *args, **kwargs):
        try:
            return f(x, *args, **kwargs)
        except AttributeError:
            if isinstance(x, (tuple, list, set)):
                return type(x)([f(e, *args, **kwargs) for e in x])
            else:
                return type(x)(*(f(e, *args, **kwargs) for e in x.args))
    return f_bis

@_generalize
def _sub_float_rat(x, all_=False):
    &#34;&#34;&#34;Remplace certain flotants par des rationels.&#34;&#34;&#34;
    repl = {f: int(round(f)) for f in x.atoms(sympy.Float) if round(f) == round(f, 4)}
    x = subs(x, repl)
    if not all_:
        cand_pow = [p for p in x.atoms(sympy.Pow) if isinstance(p.exp, sympy.Float)]
        cand_rat = [sympy.Rational(p.exp).limit_denominator(10) for p in cand_pow]
        repl = {p: sympy.Pow(p.base, r) for p, r in zip(cand_pow, cand_rat) if round(p.exp, 4) == round(r, 4)}
    else:
        repl = {f: sympy.Rational(f).limit_denominator(10) for f in x.atoms(sympy.Float)}
        repl = {f: v for f, v in repl.items() if round(f, 4) == round(v, 4)}
    x = subs(x, repl)
    return x

def _branch_simplify(x, measure):
    &#34;&#34;&#34;Simplifie une simple expression sympy.&#34;&#34;&#34;
    def main_(x, measure):
        if not isinstance(x, sympy.Basic):
            raise AttributeError(&#34;Works only on sympy expr&#34;)

        all_cand = {x} # x.rewrite(sympy.Piecewise),  x.expand(basic=True)
        new_cand = all_cand.copy() # Les expressions qui ne sont pas encore passes dans la moulinette.
        for _ in range(4):
            with Pool() as pool:
                proc = []
                for x_ in new_cand:
                    proc.append(pool.apply_async(sympy.simplify, args=(x_,), kwds={&#34;measure&#34;: measure, &#34;inverse&#34;: True, &#34;rational&#34;: False}))
                    proc.append(pool.apply_async(sympy.trigsimp, args=(x_,), kwds={&#34;method&#34;: &#34;matching&#34;}))
                    proc.append(pool.apply_async(sympy.trigsimp, args=(x_,), kwds={&#34;method&#34;: &#34;fu&#34;}))
                    proc.append(pool.apply_async(sympy.factor, args=(x_,), kwds={&#34;deep&#34;: True, &#34;fraction&#34;: False}))
                    proc.append(pool.apply_async(sympy.radsimp, args=(x_,), kwds={&#34;max_terms&#34;: 10}))
                    proc.append(pool.apply_async(sympy.powsimp, args=(x_,), kwds={&#34;deep&#34;: True, &#34;force&#34;: True, &#34;measure&#34;: measure}))
                    proc.append(pool.apply_async(sympy.cancel, args=(x_,)))
                    proc.append(pool.apply_async(sympy.sqrtdenest, args=(x_,), kwds={&#34;max_iter&#34;: 10}))
                    proc.append(pool.apply_async(sympy.ratsimp, args=(x_,)))
                    proc.append(pool.apply_async(sympy.logcombine, args=(x_,), kwds={&#34;force&#34;: True}))
                moul_cand = set() # Les expressions fraichement sorties de la moulinette.
                for p in proc:
                    try:
                        moul_cand.add(p.get(timeout=30))
                    except multiprocessing.TimeoutError:
                        pass
                    except (TypeError, AttributeError, sympy.CoercionFailed, sympy.PolynomialError):
                        pass

            new_cand = moul_cand - all_cand # On isole les expressions nouvelles.
            if not new_cand:
                break
            if len(new_cand) &gt; 10:
                new_cand = _select(*new_cand, measure=measure, n=10)
            all_cand |= moul_cand
        return _select(*all_cand, measure=measure)

    return _select(_generalize(main_)(x, measure), x, measure=measure)

def _select(*xs, measure, n=1):
    &#34;&#34;&#34;Selectione la meilleur expression.&#34;&#34;&#34;
    if multiprocessing.current_process().name == &#34;MainProcess&#34;:
        with Pool() as pool:
            costs = pool.map(measure, xs)
    else:
        costs = [measure(e) for e in xs]
    if n == 1:
        return xs[np.argmin(costs)]
    return {xs[r] for r in np.argsort(costs)[:n]}

def _cse_simp(x, measure):
    &#34;&#34;&#34;Simplifie independament chaque patern issue de cse.&#34;&#34;&#34;
    def build(defs, rvs):
        for var, e in defs[::-1]:
            rvs = subs(rvs, {var: e})
        return rvs

    changed = True
    while changed:
        changed = False
        defs, rvs = cse_homogeneous(x)

        with Pool() as pool:
            proc = []
            for _, e in defs:
                proc.append(pool.apply_async(_branch_simplify, args=(e,), kwds={&#34;measure&#34;: measure}))
            proc.append(pool.apply_async(_branch_simplify, args=(rvs,), kwds={&#34;measure&#34;: measure}))

            for i, (var, e) in enumerate(defs.copy()):
                try:
                    e_ = proc[i].get()
                except multiprocessing.TimeoutError:
                    continue
                else:
                    if measure(e_) &lt; measure(e):
                        changed = True
                        defs[i] = (var, e_)
            try:
                rvs_ = proc[-1].get()
            except multiprocessing.TimeoutError:
                continue
            else:
                if measure(rvs_) &lt; measure(rvs):
                    changed = True
                    rvs = rvs_

        if changed:
            x = build(defs, rvs)
    return x


def cse_minimize_memory(r, e):
    &#34;&#34;&#34;
    Return tuples giving ``(a, b)`` where ``a`` is a symbol and ``b`` is
    either an expression or None. The value of None is used when a
    symbol is no longer needed for subsequent expressions.

    Use of such output can reduce the memory footprint of lambdified
    expressions that contain large, repeated subexpressions.

    Examples
    --------
    &gt;&gt;&gt; from sympy import cse
    &gt;&gt;&gt; from laue.utilities.lambdify import cse_minimize_memory
    &gt;&gt;&gt; from sympy.abc import x, y
    &gt;&gt;&gt; eqs = [(x + y - 1)**2, x, x + y, (x + y)/(2*x + 1) + (x + y - 1)**2, (2*x + 1)**(x + y)]
    &gt;&gt;&gt; defs, rvs = cse_minimize_memory(*cse(eqs))
    &gt;&gt;&gt; for i in defs:
    ...     print(i)
    ...
    (x0, x + y)
    (x1, (x0 - 1)**2)
    (x2, 2*x + 1)
    (_3, x0/x2 + x1)
    (_4, x2**x0)
    (x2, None)
    (_0, x1)
    (x1, None)
    (_2, x0)
    (x0, None)
    (_1, x)
    &gt;&gt;&gt; print(rvs)
    (_0, _1, _2, _3, _4)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if not r:
        return r, e

    from sympy import symbols

    s, p = zip(*r)
    esyms = symbols(&#39;_:%d&#39; % len(e))
    syms = list(esyms)
    s = list(s)
    in_use = set(s)
    p = list(p)
    # sort e so those with most sub-expressions appear first
    e = [(e[i], syms[i]) for i in range(len(e))]
    e, syms = zip(*sorted(e,
        key=lambda x: -sum([p[s.index(i)].count_ops()
        for i in x[0].free_symbols &amp; in_use])))
    syms = list(syms)
    p += e
    rv = []
    i = len(p) - 1
    while i &gt;= 0:
        _p = p.pop()
        c = in_use &amp; _p.free_symbols
        if c: # sorting for canonical results
            rv.extend([(s, None) for s in sorted(c, key=str)])
        if i &gt;= len(r):
            rv.append((syms.pop(), _p))
        else:
            rv.append((s[i], _p))
        in_use -= c
        i -= 1
    rv.reverse()
    return rv, esyms

def cse_homogeneous(exprs, **kwargs):
    &#34;&#34;&#34;
    Same as ``cse`` but the ``reduced_exprs`` are returned
    with the same type as ``exprs`` or a sympified version of the same.

    Parameters
    ----------
    exprs : an Expr, iterable of Expr or dictionary with Expr values
        the expressions in which repeated subexpressions will be identified
    kwargs : additional arguments for the ``cse`` function

    Returns
    -------
    replacements : list of (Symbol, expression) pairs
        All of the common subexpressions that were replaced. Subexpressions
        earlier in this list might show up in subexpressions later in this
        list.
    reduced_exprs : list of sympy expressions
        The reduced expressions with all of the replacements above.

    Examples
    --------
    &gt;&gt;&gt; from sympy.simplify.cse_main import cse
    &gt;&gt;&gt; from sympy import cos, Tuple, Matrix
    &gt;&gt;&gt; from sympy.abc import x
    &gt;&gt;&gt; from laue.utilities.lambdify import cse_homogeneous
    &gt;&gt;&gt; output = lambda x: type(cse_homogeneous(x)[1])
    &gt;&gt;&gt; output(1)
    &lt;class &#39;sympy.core.numbers.One&#39;&gt;
    &gt;&gt;&gt; output(&#39;cos(x)&#39;)
    &lt;class &#39;str&#39;&gt;
    &gt;&gt;&gt; output(cos(x))
    cos
    &gt;&gt;&gt; output(Tuple(1, x))
    &lt;class &#39;sympy.core.containers.Tuple&#39;&gt;
    &gt;&gt;&gt; output(Matrix([[1,0], [0,1]]))
    &lt;class &#39;sympy.matrices.dense.MutableDenseMatrix&#39;&gt;
    &gt;&gt;&gt; output([1, x])
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; output((1, x))
    &lt;class &#39;tuple&#39;&gt;
    &gt;&gt;&gt; output({1, x})
    &lt;class &#39;set&#39;&gt;
    &#34;&#34;&#34;
    from sympy import cse
    if isinstance(exprs, str):
        from sympy import sympify
        replacements, reduced_exprs = cse_homogeneous(
            sympify(exprs), **kwargs)
        return replacements, repr(reduced_exprs)
    if isinstance(exprs, (list, tuple, set)):
        replacements, reduced_exprs = cse(exprs, **kwargs)
        return replacements, type(exprs)(reduced_exprs)
    if isinstance(exprs, dict):
        keys = list(exprs.keys()) # In order to guarantee the order of the elements.
        replacements, values = cse([exprs[k] for k in keys], **kwargs)
        reduced_exprs = dict(zip(keys, values))
        return replacements, reduced_exprs

    try:
        replacements, (reduced_exprs,) = cse(exprs, **kwargs)
    except TypeError: # For example &#39;mpf&#39; objects
        return [], exprs
    else:
        return replacements, reduced_exprs

def evalf(x, n=15):
    &#34;&#34;&#34;
    ** Alias vers ``sympy.N``. **

    Gere recursivement les objets qui n&#39;ont pas
    de methodes ``evalf``.
    &#34;&#34;&#34;
    def basic_evalf(x, n):
        &#34;&#34;&#34;Alias recursif ver evalf natif de sympy. int -&gt; float&#34;&#34;&#34;
        if isinstance(x, (sympy.Atom, numbers.Number)):
            if str(x) == &#34;pi&#34;:
                return sympy.pi.evalf(n=n)
            if str(x) == &#34;E&#34;:
                return sympy.E.evalf(n=n)
            return x
        try:
            x = type(x)(*(basic_evalf(e, n=n) for e in x.args))
        except AttributeError:
            pass
        try:
            return sympy.N(x, n=n)
        except AttributeError:
            return x

    if isinstance(x, (tuple, list, set)):
        return type(x)([evalf(e, n=n) for e in x])
    return _sub_float_rat(basic_evalf(x, n=n))

def simplify(x, measure, verbose=False):
    &#34;&#34;&#34;
    ** Triture l&#39;expression pour minimiser le temps de calcul. **
    &#34;&#34;&#34;
    return x # A changer... C&#39;est car la suite est pas hyper robuste

    if verbose:
        print(f&#34;simplify: {cse_homogeneous(x)}...&#34;)
        print(f&#34;    begin cost: {measure(x)}&#34;)

    x = _sub_float_rat(x, all_=True)
    if verbose &gt;= 2:
        print(f&#34;    after float to rational: {measure(x)}&#34;)
    x = _cse_simp(x, measure=measure)
    if verbose &gt;= 2:
        print(f&#34;    after cse_simp: {measure(x)}&#34;)
    x = _branch_simplify(x, measure=measure)
    if verbose &gt;= 2:
        print(f&#34;    after global simp: {measure(x)}&#34;)
    x = _sub_float_rat(evalf(x, n=35), all_=True)
    if verbose &gt;= 2:
        print(f&#34;    after evalf: {measure(x)}&#34;)
    x = _cse_simp(x, measure=measure)
    if verbose &gt;= 2:
        print(f&#34;    after cse_simp: {measure(x)}&#34;)
    x = _sub_float_rat(x)

    if verbose:
        print(f&#34;    final cost: {measure(x)}&#34;)
        print(f&#34;    final expr: {cse_homogeneous(x)}...&#34;)

    return x

@_generalize
def subs(x, replacements):
    &#34;&#34;&#34;
    ** Alias vers ``sympy.subs``. **

    Gere recursivement les objets qui n&#39;ont pas de methode ``.subs``.
    &#34;&#34;&#34;
    return x.subs(replacements)


class TimeCost:
    &#34;&#34;&#34;
    ** Estime le cout d&#39;une expression. **
    &#34;&#34;&#34;
    def __init__(self):
        self.costs = {}

        self._zero = np.zeros(shape=(1000, 1000))
        self._one = np.ones(shape=(1000, 1000))
        self._false = self._zero.astype(bool)
        self._true = self._one.astype(bool)
        self._negone = -self._one
        self._two = 2.0*self._one
        self._bat = .32267452*self._one
        self._comp = (1.0 + 1.0j)*self._one

        self._tests = {
            &#34;Abs&#34;: (lambda: np.abs(self._negone)),
            &#34;Add&#34;: (lambda: self._bat + self._bat),
            &#34;And&#34;: (lambda: self._true &amp; self._true),
            &#34;BooleanTrue&#34;: (lambda: self._one.astype(bool)),
            &#34;Equality&#34;: (lambda: self._bat == self._bat),
            &#34;GreaterThan&#34;: (lambda: self._one &gt;= self._one),
            &#34;LessThan&#34;: (lambda: self._one &lt;= self._one),
            &#34;MatAdd&#34;: (lambda: self._bat + self._bat),
            &#34;MatMul&#34;: (lambda: self._bat @ self._bat),
            &#34;MatPow&#34;: (lambda: self._bat ** self._bat),
            &#34;Max&#34;: (lambda: np.max(self._one)),
            &#34;Min&#34;: (lambda: np.min(self._one)),
            &#34;Mod&#34;: (lambda: self._one % self._bat),
            &#34;Mul&#34;: (lambda: self._bat * self._bat),
            &#34;Nand&#34;: (lambda: not np.all(self._true)),
            &#34;Nor&#34;: (lambda: not np.any(self._false)),
            &#34;Not&#34;: (lambda: ~ self._true),
            &#34;Or&#34;: (lambda: self._false | self._false),
            &#34;Piecewise&#34;: (lambda: ... if True else ...),
            &#34;Pow&#34;: (lambda: self._two ** self._bat),
            &#34;StrictGreaterThan&#34;: (lambda: self._one &gt; self._one),
            &#34;StrictLessThan&#34;: (lambda: self._one &lt; self._one),
            &#34;Transpose&#34;: (lambda: np.transpose(self._zero)),
            &#34;Unequality&#34;: (lambda: self._bat != self._bat),
            &#34;Xor&#34;: (lambda: (self._false|self._true) &amp; ~(self._false&amp;self._true)),
            &#34;acos&#34;: (lambda: np.arccos(self._bat)),
            &#34;acosh&#34;: (lambda: np.arccosh(self._two)),
            &#34;arg&#34;: (lambda: np.angle(self._comp)),
            &#34;asin&#34;: (lambda: np.arcsin(self._bat)),
            &#34;asinh&#34;: (lambda: np.arcsinh(self._bat)),
            &#34;atan&#34;: (lambda: np.arctan(self._bat)),
            &#34;atan2&#34;: (lambda: np.arctan2(self._bat, self._one)),
            &#34;atanh&#34;: (lambda: np.arctanh(self._bat)),
            &#34;conjugate&#34;: (lambda: np.conjugate(self._comp)),
            &#34;cos&#34;: (lambda: np.cos(self._bat)),
            &#34;cosh&#34;: (lambda: np.cosh(self._bat)),
            &#34;exp&#34;: (lambda: np.exp(self._bat)),
            &#34;im&#34;: (lambda: np.imag(self._comp)),
            &#34;log&#34;: (lambda: np.log(self._bat)),
            &#34;re&#34;: (lambda: np.real(self._comp)),
            &#34;sign&#34;: (lambda: np.sign(self._bat)),
            &#34;sin&#34;: (lambda: np.sin(self._bat)),
            &#34;sinc&#34;: (lambda: np.sinc(self._bat)),
            &#34;sinh&#34;: (lambda: np.sinh(self._bat)),
            &#34;sqrt&#34;: (lambda: np.sqrt(self._bat)),
            &#34;tan&#34;: (lambda: np.tan(self._bat)),
            &#34;tanh&#34;: (lambda: np.tanh(self._bat)),
            &#34;eval&#34;: (lambda: np.float64(&#34;0.123456789e+01&#34;)),
            &#34;aloc&#34;: (lambda: np.zeros(shape=(1000, 1000))),
            &#34;div&#34;: (lambda: 1/self._bat),
            &#34;**2&#34;: (lambda: self._bat**2),
        }

        self.load_save()

    def load_save(self):
        &#34;&#34;&#34;
        Charge le fichier qui contient les resultats.
        &#34;&#34;&#34;
        dirname = os.path.join(os.path.dirname(os.path.abspath(laue.__file__)), &#34;data&#34;)
        file = os.path.join(dirname, &#34;timecost.pickle&#34;)
        if os.path.exists(file):
            with open(file, &#34;rb&#34;) as f:
                self.__setstate__(pickle.load(f))
        else:
            with open(file, &#34;wb&#34;) as f:
                pickle.dump(self.__getstate__(), f)

    def atom_cost(self, key):
        &#34;&#34;&#34;
        Retourne le cout de l&#39;opperateur.
        &#34;&#34;&#34;
        if key in self.costs:
            return self.costs[key]
        if hasattr(self, &#34;_tests&#34;):
            if key in self._tests:
                self.costs[key] = timeit.timeit(self._tests[key], number=100)
                return self.costs[key]
        raise ValueError(f&#34;L&#39;opperation {key} est inconnue.&#34;)

    def branch_cost(self, branch):
        &#34;&#34;&#34;
        Le cout brut de l&#39;expression sympy sans cse.
        &#34;&#34;&#34;
        if isinstance(branch, (sympy.Atom, numbers.Number)):
            return self.atom_cost(&#34;eval&#34;)

        if isinstance(branch, (sympy.Add, sympy.And, sympy.MatAdd, sympy.MatMul,
                sympy.MatPow, sympy.Mul, sympy.Nand, sympy.Nor, sympy.Or, sympy.Xor)):
            op_cost = self.atom_cost(type(branch).__name__) * (len(branch.args)-1)
            return sum((self.branch_cost(e) for e in branch.args)) + op_cost

        if isinstance(branch, sympy.Pow):
            if isinstance(branch.exp, sympy.Number):
                if branch.exp == 2:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;**2&#34;)
                if branch.exp == sympy.S.Half:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;sqrt&#34;)
                if branch.exp == -sympy.S.Half:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;sqrt&#34;)
                if branch.exp == -sympy.S.One:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;)
                if branch.exp == -2:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;**2&#34;)
            return self.branch_cost(branch.base) + self.branch_cost(branch.exp) + self.atom_cost(&#34;Pow&#34;)

        if isinstance(branch, sympy.Piecewise):
            op_cost = self.atom_cost(&#34;Piecewise&#34;) * (len(branch.args)-1)
            return sum(
                self.branch_cost(val) + sum(self.branch_cost(a) for a in cond.args)
                for val, cond in branch.args) + op_cost

        return sum((self.branch_cost(e) for e in branch.args)) + self.atom_cost(type(branch).__name__)

    def __call__(self, expr):
        &#34;&#34;&#34;
        Le cout de l&#39;expression avec cse.
        &#34;&#34;&#34;
        defs, rvs = sympy.cse(expr)
        return (sum(self.branch_cost(e) for var, e in defs)
              + sum(self.branch_cost(e) for e in rvs)
              + len(defs)*self.atom_cost(&#34;aloc&#34;))

    def __getstate__(self):
        if hasattr(self, &#34;_tests&#34;):
            for key in self._tests:
                self.atom_cost(key)
        return self.costs

    def __setstate__(self, state):
        self.costs = state

class Lambdify:
    &#34;&#34;&#34;
    ** Permet de manipuler plus simplement une fonction. **
    &#34;&#34;&#34;
    def __init__(self, args, expr, *, verbose=False, _simp_expr=None):
        &#34;&#34;&#34;
        ** Prepare la fonction. **

        Parameters
        ----------
        args : iterable
            Les parametres d&#39;entre de la fonction.
        expr : sympy.core
            L&#39;expresion sympy a vectoriser.
        &#34;&#34;&#34;
        # Preparation symbolique.
        self.args = [arg for arg in sympy.sympify(args)]
        self.args_name = [str(arg) for arg in self.args]
        self.args_position = {arg: i for i, arg in enumerate(self.args_name)}
        self.expr = expr
        self.verbose = verbose

        # Preparation vectoriele.
        self._simp_expr = _simp_expr
        if self._simp_expr is None:
            self._simp_expr = simplify(self.expr, measure=TimeCost(), verbose=verbose)
        self.fct = lambdify(self.args, self._simp_expr, cse=True, modules=&#34;numpy&#34;)
        try:
            self.fct_numexpr = lambdify(self.args, evalf(self._simp_expr, n=15), cse=True, modules=&#34;numexpr&#34;)
        except (ImportError, TypeError, RuntimeError):
            self.fct_numexpr = None

    def __str__(self, *, name=&#34;lambdifygenerated&#34;, bloc=&#34;numpy&#34;):
        &#39;&#39;&#39;
        ** Offre une representation explicite de la fonction. **

        Parameters
        ----------
        name : str
            Le nom a donner a la fonction.
        bloc : str
            La partie du code a impromer. Permet de selectionner la fonction.

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos, pi
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; print(Lambdify([x, y], pi*cos(x + y) + x + y), end=&#34;&#34;)
        def _lambdifygenerated_numpy(x, y):
            &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;
            x0 = x + y
            _0 = x0 + 3.14159265358979*cos(x0)
            return _0
        &gt;&gt;&gt;
        &#39;&#39;&#39;
        assert isinstance(name, str), f&#34;&#39;name&#39; has to be str, not {type(name).__name__}.&#34;
        assert bloc in {&#34;main&#34;, &#34;numpy&#34;, &#34;numpy128&#34;, &#34;numexpr&#34;, &#34;sympy&#34;}
        import re

        # Code numexpr.
        if bloc == &#34;numexpr&#34;:
            if self.fct_numexpr is not None:
                code = self.fct_numexpr.__doc__.split(&#34;\n&#34;)
                code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numexpr&#34;)
                code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float64 using the numexpr module.&#34;&#34;&#34;&#39;)
            else:
                code = []

        # Code &lt; float 64
        elif bloc == &#34;numpy&#34;:
            code = lambdify(self.args, evalf(self._simp_expr),
                cse=True, modules=&#34;numpy&#34;).__doc__.split(&#34;\n&#34;)
            code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy&#34;)
            code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;&#39;)

        # Code float 128
        elif bloc == &#34;numpy128&#34;:
            f_mod = re.compile(r&#34;&#34;&#34;(?:[+-]*
                (?:
                  \. [0-9]+ (?:_[0-9]+)*
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)* \. (?: [0-9]+ (?:_[0-9]+)* )?
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)*
                  e [+-]? [0-9]+ (?:_[0-9]+)*
                ))&#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE) # Model d&#39;un flottant.
            code_str = self.fct.__doc__
            code_str = re.sub(f_mod,
                lambda m: (f&#34;float128({repr(m.group())})&#34; if len(m.group()) &gt;= 15 else m.group()),
                code_str)
            code = code_str.split(&#34;\n&#34;)
            code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy128&#34;)
            code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float128 using the numpy module.&#34;&#34;&#34;&#39;)

        # Expression formelle
        elif bloc == &#34;sympy&#34;:
            defs, rvs = cse_homogeneous(self.expr)
            code = []
            code.append(f&#34;def _{name}_sympy():&#34;)
            code.append( &#39;    &#34;&#34;&#34;Returns the tree of the sympy expression.&#34;&#34;&#34;&#39;)
            code.append(f&#34;    {&#39;, &#39;.join(self.args_name)} = symbols(&#39;{&#39; &#39;.join(self.args_name)}&#39;)&#34;)
            for var, expr in defs:
                code.append(f&#34;    {var} = {expr}&#34;)
            code.append(f&#34;    return {rvs}&#34;)
            code.append( &#34;&#34;)

        # Fonction principale Equivalent as self.__call__.
        elif bloc == &#34;main&#34;:
            code = []
            code.append(f&#34;def {name}(*args, **kwargs):&#34;)
            code.append( &#39;    &#34;&#34;&#34;&#39;)
            code.append( &#34;    ** Choose the most suitable function according to&#34;)
            code.append( &#34;    the type and size of the input data. **&#34;)
            code.append( &#34;&#34;)
            code.append( &#34;    Parameters&#34;)
            code.append( &#34;    ----------&#34;)
            code.append( &#34;    *args&#34;)
            code.append( &#34;        Les parametres ordonnes de la fonction.&#34;)
            code.append( &#34;    **kwargs&#34;)
            code.append( &#34;        Les parametres nomes de la fonction. Ils&#34;)
            code.append( &#34;        ont le dessus sur les args en cas d&#39;ambiguite.&#34;)
            code.append( &#39;    &#34;&#34;&#34;&#39;)

            code.append( &#34;    assert len(args) &lt;= %d, f&#39;The function cannot take {len(args)} arguments.&#39;&#34;
                                                % len(self.args))
            code.append( &#34;    assert not set(kwargs) - {%s}, f&#39;You cannot provide {kwargs}.&#39;&#34;
                                                      % &#34;, &#34;.join(repr(a) for a in self.args_name))
            code.append( &#34;    if not args and not kwargs:&#34;)
            code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
            code.append(f&#34;        return _{name}_sympy()&#34;)

            code.append( &#34;    args = list(args)&#34;)
            code.append(f&#34;    if len(args) &lt; {len(self.args)}:&#34;)
            code.append(f&#34;        args += sympy.symbols(&#39; &#39;.join({self.args_name}[len(args):]))&#34;)
            code.append( &#34;    if kwargs:&#34;)
            code.append( &#34;        for arg, value in kwargs.items():&#34;)
            code.append(f&#34;            args[{self.args_position}[arg]] = value&#34;)

            code.append( &#34;    if any(isinstance(a, sympy.Basic) for a in args):&#34;)
            code.append( &#34;        sub = {arg: value for arg, value in zip(%s, args)}&#34; % self.args_name)
            code.append( &#34;        from laue.utilities.lambdify import subs&#34;)
            code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
            code.append(f&#34;        return subs(_{name}_sympy(), sub)&#34;)

            if hasattr(np, &#34;float128&#34;):
                code.append( &#34;    if any(a.dtype == np.float128 for a in args if isinstance(a, np.ndarray)):&#34;)
                code.append(f&#34;        from laue.data.numpy128_lambdify import _{name}_numpy128&#34;)
                code.append(f&#34;        return _{name}_numpy128(*args)&#34;)
            if self.fct_numexpr is not None:
                code.append( &#34;    if (&#34;)
                code.append( &#34;            (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)&#34;)
                code.append( &#34;            and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))&#34;)
                code.append( &#34;        ):&#34;)
                code.append(f&#34;        from laue.data.numexpr_lambdify import _{name}_numexpr&#34;)
                code.append(f&#34;        return _{name}_numexpr(*args)&#34;)
            code.append(f&#34;    from laue.data.numpy_lambdify import _{name}_numpy&#34;)
            code.append(f&#34;    return _{name}_numpy(*args)&#34;)
            code.append( &#34;&#34;)

        else:
            raise KeyError

        return &#34;\n&#34;.join(code)

    def __repr__(self):
        &#34;&#34;&#34;
        ** Offre une representation evaluable de l&#39;objet. **

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return f&#34;Lambdify([{&#39;, &#39;.join(self.args_name)}], {self.expr})&#34;

    def __call__(self, *args, **kwargs):
        &#34;&#34;&#34;
        ** Evalue la fonction. **

        Parameters
        ----------
        *args
            Les parametres ordonnes de la fonction.
        **kwargs
            Les parametres nomes de la fonction. Ils
            ont le dessus sur les args en cas d&#39;ambiguite.

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt; l = Lambdify([x, y], x + y + cos(x + y))

        Les cas symboliques.
        &gt;&gt;&gt; l() # Retourne l&#39;expression sympy.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(x) # Complete la suite en rajoutant &#39;y&#39;.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(y) # Complete aussi en rajoutant &#39;y&#39;.
        2*y + cos(2*y)
        &gt;&gt;&gt; l(x, y) # Retourne une copie de l&#39;expression sympy.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(1, y=2*y) # Il est possible de faire un melange symbolique / numerique.
        2*y + cos(2*y + 1) + 1
        &gt;&gt;&gt;

        Les cas purement numeriques.
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; l(-1, 1)
        1.0
        &gt;&gt;&gt; l(x=-1, y=1)
        1.0
        &gt;&gt;&gt; np.round(l(0, np.linspace(-1, 1, 5)), 2)
        array([-0.46,  0.38,  1.  ,  1.38,  1.54])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # Cas patologiques.
        if not args and not kwargs:
            return self.expr
        if len(args) &gt; len(self.args):
            raise IndexError(f&#34;La fonction ne prend que {len(self.args)} arguments. &#34;
                f&#34;Or vous en avez fournis {len(args)}.&#34;)
        
        # Recuperation des arguments complets.
        args = list(args)
        args += self.args[len(args):]
        if kwargs:
            if set(kwargs) - set(self.args_position):
                raise NameError(f&#34;Les parametres {set(kwargs) - set(self.args_position)} &#34;
                    f&#34;ne sont pas admissible, seul {set(self.args_position)} sont admissibles.&#34;)
            for arg, value in kwargs.items():
                args[self.args_position[arg]] = value

        # Cas symbolique.
        if any(isinstance(a, sympy.Basic) for a in args):
            sub = {arg: value for arg, value in zip(self.args, args)}
            return subs(self.expr, sub)

        # Cas numerique.
        if (
                (self.fct_numexpr is not None)
                and (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)
                and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))
            ):
            return self.fct_numexpr(*args)
        return self.fct(*args)

    def __getstate__(self):
        &#34;&#34;&#34;
        ** Extrait l&#39;information serialisable. **

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; l = Lambdify([x, y], cos(x + y) + x + y)
        &gt;&gt;&gt; l.__getstate__()
        ([x, y], x + y + cos(x + y), False)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.expr == self._simp_expr:
            return (self.args, self.expr, self.verbose)
        return (self.args, self.expr, self.verbose, self._simp_expr)

    def __setstate__(self, state):
        &#34;&#34;&#34;
        ** Instancie l&#39;objet a partir de l&#39;etat. **

        Examples
        --------
        &gt;&gt;&gt; import pickle
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt; pickle.loads(pickle.dumps(_))
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if len(state) == 4:
            self.__init__(state[0], state[1], verbose=state[2], _simp_expr=state[3])
        else:
            self.__init__(state[0], state[1], verbose=state[2])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laue.utilities.lambdify.cse_homogeneous"><code class="name flex">
<span>def <span class="ident">cse_homogeneous</span></span>(<span>exprs, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Same as <code>cse</code> but the <code>reduced_exprs</code> are returned
with the same type as <code>exprs</code> or a sympified version of the same.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>exprs</code></strong> :&ensp;<code>an Expr, iterable</code> of <code>Expr</code> or <code>dictionary with Expr values</code></dt>
<dd>the expressions in which repeated subexpressions will be identified</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>additional arguments for the <code>cse</code> function</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>replacements</code></strong> :&ensp;<code>list</code> of <code>(Symbol, expression) pairs</code></dt>
<dd>All of the common subexpressions that were replaced. Subexpressions
earlier in this list might show up in subexpressions later in this
list.</dd>
<dt><strong><code>reduced_exprs</code></strong> :&ensp;<code>list</code> of <code>sympy expressions</code></dt>
<dd>The reduced expressions with all of the replacements above.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy.simplify.cse_main import cse
&gt;&gt;&gt; from sympy import cos, Tuple, Matrix
&gt;&gt;&gt; from sympy.abc import x
&gt;&gt;&gt; from laue.utilities.lambdify import cse_homogeneous
&gt;&gt;&gt; output = lambda x: type(cse_homogeneous(x)[1])
&gt;&gt;&gt; output(1)
&lt;class 'sympy.core.numbers.One'&gt;
&gt;&gt;&gt; output('cos(x)')
&lt;class 'str'&gt;
&gt;&gt;&gt; output(cos(x))
cos
&gt;&gt;&gt; output(Tuple(1, x))
&lt;class 'sympy.core.containers.Tuple'&gt;
&gt;&gt;&gt; output(Matrix([[1,0], [0,1]]))
&lt;class 'sympy.matrices.dense.MutableDenseMatrix'&gt;
&gt;&gt;&gt; output([1, x])
&lt;class 'list'&gt;
&gt;&gt;&gt; output((1, x))
&lt;class 'tuple'&gt;
&gt;&gt;&gt; output({1, x})
&lt;class 'set'&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cse_homogeneous(exprs, **kwargs):
    &#34;&#34;&#34;
    Same as ``cse`` but the ``reduced_exprs`` are returned
    with the same type as ``exprs`` or a sympified version of the same.

    Parameters
    ----------
    exprs : an Expr, iterable of Expr or dictionary with Expr values
        the expressions in which repeated subexpressions will be identified
    kwargs : additional arguments for the ``cse`` function

    Returns
    -------
    replacements : list of (Symbol, expression) pairs
        All of the common subexpressions that were replaced. Subexpressions
        earlier in this list might show up in subexpressions later in this
        list.
    reduced_exprs : list of sympy expressions
        The reduced expressions with all of the replacements above.

    Examples
    --------
    &gt;&gt;&gt; from sympy.simplify.cse_main import cse
    &gt;&gt;&gt; from sympy import cos, Tuple, Matrix
    &gt;&gt;&gt; from sympy.abc import x
    &gt;&gt;&gt; from laue.utilities.lambdify import cse_homogeneous
    &gt;&gt;&gt; output = lambda x: type(cse_homogeneous(x)[1])
    &gt;&gt;&gt; output(1)
    &lt;class &#39;sympy.core.numbers.One&#39;&gt;
    &gt;&gt;&gt; output(&#39;cos(x)&#39;)
    &lt;class &#39;str&#39;&gt;
    &gt;&gt;&gt; output(cos(x))
    cos
    &gt;&gt;&gt; output(Tuple(1, x))
    &lt;class &#39;sympy.core.containers.Tuple&#39;&gt;
    &gt;&gt;&gt; output(Matrix([[1,0], [0,1]]))
    &lt;class &#39;sympy.matrices.dense.MutableDenseMatrix&#39;&gt;
    &gt;&gt;&gt; output([1, x])
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; output((1, x))
    &lt;class &#39;tuple&#39;&gt;
    &gt;&gt;&gt; output({1, x})
    &lt;class &#39;set&#39;&gt;
    &#34;&#34;&#34;
    from sympy import cse
    if isinstance(exprs, str):
        from sympy import sympify
        replacements, reduced_exprs = cse_homogeneous(
            sympify(exprs), **kwargs)
        return replacements, repr(reduced_exprs)
    if isinstance(exprs, (list, tuple, set)):
        replacements, reduced_exprs = cse(exprs, **kwargs)
        return replacements, type(exprs)(reduced_exprs)
    if isinstance(exprs, dict):
        keys = list(exprs.keys()) # In order to guarantee the order of the elements.
        replacements, values = cse([exprs[k] for k in keys], **kwargs)
        reduced_exprs = dict(zip(keys, values))
        return replacements, reduced_exprs

    try:
        replacements, (reduced_exprs,) = cse(exprs, **kwargs)
    except TypeError: # For example &#39;mpf&#39; objects
        return [], exprs
    else:
        return replacements, reduced_exprs</code></pre>
</details>
</dd>
<dt id="laue.utilities.lambdify.cse_minimize_memory"><code class="name flex">
<span>def <span class="ident">cse_minimize_memory</span></span>(<span>r, e)</span>
</code></dt>
<dd>
<div class="desc"><p>Return tuples giving <code>(a, b)</code> where <code>a</code> is a symbol and <code>b</code> is
either an expression or None. The value of None is used when a
symbol is no longer needed for subsequent expressions.</p>
<p>Use of such output can reduce the memory footprint of lambdified
expressions that contain large, repeated subexpressions.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy import cse
&gt;&gt;&gt; from laue.utilities.lambdify import cse_minimize_memory
&gt;&gt;&gt; from sympy.abc import x, y
&gt;&gt;&gt; eqs = [(x + y - 1)**2, x, x + y, (x + y)/(2*x + 1) + (x + y - 1)**2, (2*x + 1)**(x + y)]
&gt;&gt;&gt; defs, rvs = cse_minimize_memory(*cse(eqs))
&gt;&gt;&gt; for i in defs:
...     print(i)
...
(x0, x + y)
(x1, (x0 - 1)**2)
(x2, 2*x + 1)
(_3, x0/x2 + x1)
(_4, x2**x0)
(x2, None)
(_0, x1)
(x1, None)
(_2, x0)
(x0, None)
(_1, x)
&gt;&gt;&gt; print(rvs)
(_0, _1, _2, _3, _4)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cse_minimize_memory(r, e):
    &#34;&#34;&#34;
    Return tuples giving ``(a, b)`` where ``a`` is a symbol and ``b`` is
    either an expression or None. The value of None is used when a
    symbol is no longer needed for subsequent expressions.

    Use of such output can reduce the memory footprint of lambdified
    expressions that contain large, repeated subexpressions.

    Examples
    --------
    &gt;&gt;&gt; from sympy import cse
    &gt;&gt;&gt; from laue.utilities.lambdify import cse_minimize_memory
    &gt;&gt;&gt; from sympy.abc import x, y
    &gt;&gt;&gt; eqs = [(x + y - 1)**2, x, x + y, (x + y)/(2*x + 1) + (x + y - 1)**2, (2*x + 1)**(x + y)]
    &gt;&gt;&gt; defs, rvs = cse_minimize_memory(*cse(eqs))
    &gt;&gt;&gt; for i in defs:
    ...     print(i)
    ...
    (x0, x + y)
    (x1, (x0 - 1)**2)
    (x2, 2*x + 1)
    (_3, x0/x2 + x1)
    (_4, x2**x0)
    (x2, None)
    (_0, x1)
    (x1, None)
    (_2, x0)
    (x0, None)
    (_1, x)
    &gt;&gt;&gt; print(rvs)
    (_0, _1, _2, _3, _4)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if not r:
        return r, e

    from sympy import symbols

    s, p = zip(*r)
    esyms = symbols(&#39;_:%d&#39; % len(e))
    syms = list(esyms)
    s = list(s)
    in_use = set(s)
    p = list(p)
    # sort e so those with most sub-expressions appear first
    e = [(e[i], syms[i]) for i in range(len(e))]
    e, syms = zip(*sorted(e,
        key=lambda x: -sum([p[s.index(i)].count_ops()
        for i in x[0].free_symbols &amp; in_use])))
    syms = list(syms)
    p += e
    rv = []
    i = len(p) - 1
    while i &gt;= 0:
        _p = p.pop()
        c = in_use &amp; _p.free_symbols
        if c: # sorting for canonical results
            rv.extend([(s, None) for s in sorted(c, key=str)])
        if i &gt;= len(r):
            rv.append((syms.pop(), _p))
        else:
            rv.append((s[i], _p))
        in_use -= c
        i -= 1
    rv.reverse()
    return rv, esyms</code></pre>
</details>
</dd>
<dt id="laue.utilities.lambdify.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>x, measure, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Triture l'expression pour minimiser le temps de calcul. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(x, measure, verbose=False):
    &#34;&#34;&#34;
    ** Triture l&#39;expression pour minimiser le temps de calcul. **
    &#34;&#34;&#34;
    return x # A changer... C&#39;est car la suite est pas hyper robuste

    if verbose:
        print(f&#34;simplify: {cse_homogeneous(x)}...&#34;)
        print(f&#34;    begin cost: {measure(x)}&#34;)

    x = _sub_float_rat(x, all_=True)
    if verbose &gt;= 2:
        print(f&#34;    after float to rational: {measure(x)}&#34;)
    x = _cse_simp(x, measure=measure)
    if verbose &gt;= 2:
        print(f&#34;    after cse_simp: {measure(x)}&#34;)
    x = _branch_simplify(x, measure=measure)
    if verbose &gt;= 2:
        print(f&#34;    after global simp: {measure(x)}&#34;)
    x = _sub_float_rat(evalf(x, n=35), all_=True)
    if verbose &gt;= 2:
        print(f&#34;    after evalf: {measure(x)}&#34;)
    x = _cse_simp(x, measure=measure)
    if verbose &gt;= 2:
        print(f&#34;    after cse_simp: {measure(x)}&#34;)
    x = _sub_float_rat(x)

    if verbose:
        print(f&#34;    final cost: {measure(x)}&#34;)
        print(f&#34;    final expr: {cse_homogeneous(x)}...&#34;)

    return x</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laue.utilities.lambdify.Lambdify"><code class="flex name class">
<span>class <span class="ident">Lambdify</span></span>
<span>(</span><span>args, expr, *, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Permet de manipuler plus simplement une fonction. </strong></p>
<p><strong> Prepare la fonction. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Les parametres d'entre de la fonction.</dd>
<dt><strong><code>expr</code></strong> :&ensp;<code>sympy.core</code></dt>
<dd>L'expresion sympy a vectoriser.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lambdify:
    &#34;&#34;&#34;
    ** Permet de manipuler plus simplement une fonction. **
    &#34;&#34;&#34;
    def __init__(self, args, expr, *, verbose=False, _simp_expr=None):
        &#34;&#34;&#34;
        ** Prepare la fonction. **

        Parameters
        ----------
        args : iterable
            Les parametres d&#39;entre de la fonction.
        expr : sympy.core
            L&#39;expresion sympy a vectoriser.
        &#34;&#34;&#34;
        # Preparation symbolique.
        self.args = [arg for arg in sympy.sympify(args)]
        self.args_name = [str(arg) for arg in self.args]
        self.args_position = {arg: i for i, arg in enumerate(self.args_name)}
        self.expr = expr
        self.verbose = verbose

        # Preparation vectoriele.
        self._simp_expr = _simp_expr
        if self._simp_expr is None:
            self._simp_expr = simplify(self.expr, measure=TimeCost(), verbose=verbose)
        self.fct = lambdify(self.args, self._simp_expr, cse=True, modules=&#34;numpy&#34;)
        try:
            self.fct_numexpr = lambdify(self.args, evalf(self._simp_expr, n=15), cse=True, modules=&#34;numexpr&#34;)
        except (ImportError, TypeError, RuntimeError):
            self.fct_numexpr = None

    def __str__(self, *, name=&#34;lambdifygenerated&#34;, bloc=&#34;numpy&#34;):
        &#39;&#39;&#39;
        ** Offre une representation explicite de la fonction. **

        Parameters
        ----------
        name : str
            Le nom a donner a la fonction.
        bloc : str
            La partie du code a impromer. Permet de selectionner la fonction.

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos, pi
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; print(Lambdify([x, y], pi*cos(x + y) + x + y), end=&#34;&#34;)
        def _lambdifygenerated_numpy(x, y):
            &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;
            x0 = x + y
            _0 = x0 + 3.14159265358979*cos(x0)
            return _0
        &gt;&gt;&gt;
        &#39;&#39;&#39;
        assert isinstance(name, str), f&#34;&#39;name&#39; has to be str, not {type(name).__name__}.&#34;
        assert bloc in {&#34;main&#34;, &#34;numpy&#34;, &#34;numpy128&#34;, &#34;numexpr&#34;, &#34;sympy&#34;}
        import re

        # Code numexpr.
        if bloc == &#34;numexpr&#34;:
            if self.fct_numexpr is not None:
                code = self.fct_numexpr.__doc__.split(&#34;\n&#34;)
                code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numexpr&#34;)
                code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float64 using the numexpr module.&#34;&#34;&#34;&#39;)
            else:
                code = []

        # Code &lt; float 64
        elif bloc == &#34;numpy&#34;:
            code = lambdify(self.args, evalf(self._simp_expr),
                cse=True, modules=&#34;numpy&#34;).__doc__.split(&#34;\n&#34;)
            code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy&#34;)
            code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;&#39;)

        # Code float 128
        elif bloc == &#34;numpy128&#34;:
            f_mod = re.compile(r&#34;&#34;&#34;(?:[+-]*
                (?:
                  \. [0-9]+ (?:_[0-9]+)*
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)* \. (?: [0-9]+ (?:_[0-9]+)* )?
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)*
                  e [+-]? [0-9]+ (?:_[0-9]+)*
                ))&#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE) # Model d&#39;un flottant.
            code_str = self.fct.__doc__
            code_str = re.sub(f_mod,
                lambda m: (f&#34;float128({repr(m.group())})&#34; if len(m.group()) &gt;= 15 else m.group()),
                code_str)
            code = code_str.split(&#34;\n&#34;)
            code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy128&#34;)
            code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float128 using the numpy module.&#34;&#34;&#34;&#39;)

        # Expression formelle
        elif bloc == &#34;sympy&#34;:
            defs, rvs = cse_homogeneous(self.expr)
            code = []
            code.append(f&#34;def _{name}_sympy():&#34;)
            code.append( &#39;    &#34;&#34;&#34;Returns the tree of the sympy expression.&#34;&#34;&#34;&#39;)
            code.append(f&#34;    {&#39;, &#39;.join(self.args_name)} = symbols(&#39;{&#39; &#39;.join(self.args_name)}&#39;)&#34;)
            for var, expr in defs:
                code.append(f&#34;    {var} = {expr}&#34;)
            code.append(f&#34;    return {rvs}&#34;)
            code.append( &#34;&#34;)

        # Fonction principale Equivalent as self.__call__.
        elif bloc == &#34;main&#34;:
            code = []
            code.append(f&#34;def {name}(*args, **kwargs):&#34;)
            code.append( &#39;    &#34;&#34;&#34;&#39;)
            code.append( &#34;    ** Choose the most suitable function according to&#34;)
            code.append( &#34;    the type and size of the input data. **&#34;)
            code.append( &#34;&#34;)
            code.append( &#34;    Parameters&#34;)
            code.append( &#34;    ----------&#34;)
            code.append( &#34;    *args&#34;)
            code.append( &#34;        Les parametres ordonnes de la fonction.&#34;)
            code.append( &#34;    **kwargs&#34;)
            code.append( &#34;        Les parametres nomes de la fonction. Ils&#34;)
            code.append( &#34;        ont le dessus sur les args en cas d&#39;ambiguite.&#34;)
            code.append( &#39;    &#34;&#34;&#34;&#39;)

            code.append( &#34;    assert len(args) &lt;= %d, f&#39;The function cannot take {len(args)} arguments.&#39;&#34;
                                                % len(self.args))
            code.append( &#34;    assert not set(kwargs) - {%s}, f&#39;You cannot provide {kwargs}.&#39;&#34;
                                                      % &#34;, &#34;.join(repr(a) for a in self.args_name))
            code.append( &#34;    if not args and not kwargs:&#34;)
            code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
            code.append(f&#34;        return _{name}_sympy()&#34;)

            code.append( &#34;    args = list(args)&#34;)
            code.append(f&#34;    if len(args) &lt; {len(self.args)}:&#34;)
            code.append(f&#34;        args += sympy.symbols(&#39; &#39;.join({self.args_name}[len(args):]))&#34;)
            code.append( &#34;    if kwargs:&#34;)
            code.append( &#34;        for arg, value in kwargs.items():&#34;)
            code.append(f&#34;            args[{self.args_position}[arg]] = value&#34;)

            code.append( &#34;    if any(isinstance(a, sympy.Basic) for a in args):&#34;)
            code.append( &#34;        sub = {arg: value for arg, value in zip(%s, args)}&#34; % self.args_name)
            code.append( &#34;        from laue.utilities.lambdify import subs&#34;)
            code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
            code.append(f&#34;        return subs(_{name}_sympy(), sub)&#34;)

            if hasattr(np, &#34;float128&#34;):
                code.append( &#34;    if any(a.dtype == np.float128 for a in args if isinstance(a, np.ndarray)):&#34;)
                code.append(f&#34;        from laue.data.numpy128_lambdify import _{name}_numpy128&#34;)
                code.append(f&#34;        return _{name}_numpy128(*args)&#34;)
            if self.fct_numexpr is not None:
                code.append( &#34;    if (&#34;)
                code.append( &#34;            (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)&#34;)
                code.append( &#34;            and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))&#34;)
                code.append( &#34;        ):&#34;)
                code.append(f&#34;        from laue.data.numexpr_lambdify import _{name}_numexpr&#34;)
                code.append(f&#34;        return _{name}_numexpr(*args)&#34;)
            code.append(f&#34;    from laue.data.numpy_lambdify import _{name}_numpy&#34;)
            code.append(f&#34;    return _{name}_numpy(*args)&#34;)
            code.append( &#34;&#34;)

        else:
            raise KeyError

        return &#34;\n&#34;.join(code)

    def __repr__(self):
        &#34;&#34;&#34;
        ** Offre une representation evaluable de l&#39;objet. **

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return f&#34;Lambdify([{&#39;, &#39;.join(self.args_name)}], {self.expr})&#34;

    def __call__(self, *args, **kwargs):
        &#34;&#34;&#34;
        ** Evalue la fonction. **

        Parameters
        ----------
        *args
            Les parametres ordonnes de la fonction.
        **kwargs
            Les parametres nomes de la fonction. Ils
            ont le dessus sur les args en cas d&#39;ambiguite.

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt; l = Lambdify([x, y], x + y + cos(x + y))

        Les cas symboliques.
        &gt;&gt;&gt; l() # Retourne l&#39;expression sympy.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(x) # Complete la suite en rajoutant &#39;y&#39;.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(y) # Complete aussi en rajoutant &#39;y&#39;.
        2*y + cos(2*y)
        &gt;&gt;&gt; l(x, y) # Retourne une copie de l&#39;expression sympy.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(1, y=2*y) # Il est possible de faire un melange symbolique / numerique.
        2*y + cos(2*y + 1) + 1
        &gt;&gt;&gt;

        Les cas purement numeriques.
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; l(-1, 1)
        1.0
        &gt;&gt;&gt; l(x=-1, y=1)
        1.0
        &gt;&gt;&gt; np.round(l(0, np.linspace(-1, 1, 5)), 2)
        array([-0.46,  0.38,  1.  ,  1.38,  1.54])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # Cas patologiques.
        if not args and not kwargs:
            return self.expr
        if len(args) &gt; len(self.args):
            raise IndexError(f&#34;La fonction ne prend que {len(self.args)} arguments. &#34;
                f&#34;Or vous en avez fournis {len(args)}.&#34;)
        
        # Recuperation des arguments complets.
        args = list(args)
        args += self.args[len(args):]
        if kwargs:
            if set(kwargs) - set(self.args_position):
                raise NameError(f&#34;Les parametres {set(kwargs) - set(self.args_position)} &#34;
                    f&#34;ne sont pas admissible, seul {set(self.args_position)} sont admissibles.&#34;)
            for arg, value in kwargs.items():
                args[self.args_position[arg]] = value

        # Cas symbolique.
        if any(isinstance(a, sympy.Basic) for a in args):
            sub = {arg: value for arg, value in zip(self.args, args)}
            return subs(self.expr, sub)

        # Cas numerique.
        if (
                (self.fct_numexpr is not None)
                and (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)
                and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))
            ):
            return self.fct_numexpr(*args)
        return self.fct(*args)

    def __getstate__(self):
        &#34;&#34;&#34;
        ** Extrait l&#39;information serialisable. **

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; l = Lambdify([x, y], cos(x + y) + x + y)
        &gt;&gt;&gt; l.__getstate__()
        ([x, y], x + y + cos(x + y), False)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.expr == self._simp_expr:
            return (self.args, self.expr, self.verbose)
        return (self.args, self.expr, self.verbose, self._simp_expr)

    def __setstate__(self, state):
        &#34;&#34;&#34;
        ** Instancie l&#39;objet a partir de l&#39;etat. **

        Examples
        --------
        &gt;&gt;&gt; import pickle
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt; pickle.loads(pickle.dumps(_))
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if len(state) == 4:
            self.__init__(state[0], state[1], verbose=state[2], _simp_expr=state[3])
        else:
            self.__init__(state[0], state[1], verbose=state[2])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="laue.utilities.lambdify.Lambdify.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Evalue la fonction. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Les parametres ordonnes de la fonction.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Les parametres nomes de la fonction. Ils
ont le dessus sur les args en cas d'ambiguite.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
&gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
&gt;&gt;&gt; l = Lambdify([x, y], x + y + cos(x + y))
</code></pre>
<p>Les cas symboliques.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; l() # Retourne l'expression sympy.
x + y + cos(x + y)
&gt;&gt;&gt; l(x) # Complete la suite en rajoutant 'y'.
x + y + cos(x + y)
&gt;&gt;&gt; l(y) # Complete aussi en rajoutant 'y'.
2*y + cos(2*y)
&gt;&gt;&gt; l(x, y) # Retourne une copie de l'expression sympy.
x + y + cos(x + y)
&gt;&gt;&gt; l(1, y=2*y) # Il est possible de faire un melange symbolique / numerique.
2*y + cos(2*y + 1) + 1
&gt;&gt;&gt;
</code></pre>
<p>Les cas purement numeriques.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; l(-1, 1)
1.0
&gt;&gt;&gt; l(x=-1, y=1)
1.0
&gt;&gt;&gt; np.round(l(0, np.linspace(-1, 1, 5)), 2)
array([-0.46,  0.38,  1.  ,  1.38,  1.54])
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __call__(self, *args, **kwargs):
    &#34;&#34;&#34;
    ** Evalue la fonction. **

    Parameters
    ----------
    *args
        Les parametres ordonnes de la fonction.
    **kwargs
        Les parametres nomes de la fonction. Ils
        ont le dessus sur les args en cas d&#39;ambiguite.

    Examples
    --------
    &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
    &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
    &gt;&gt;&gt; l = Lambdify([x, y], x + y + cos(x + y))

    Les cas symboliques.
    &gt;&gt;&gt; l() # Retourne l&#39;expression sympy.
    x + y + cos(x + y)
    &gt;&gt;&gt; l(x) # Complete la suite en rajoutant &#39;y&#39;.
    x + y + cos(x + y)
    &gt;&gt;&gt; l(y) # Complete aussi en rajoutant &#39;y&#39;.
    2*y + cos(2*y)
    &gt;&gt;&gt; l(x, y) # Retourne une copie de l&#39;expression sympy.
    x + y + cos(x + y)
    &gt;&gt;&gt; l(1, y=2*y) # Il est possible de faire un melange symbolique / numerique.
    2*y + cos(2*y + 1) + 1
    &gt;&gt;&gt;

    Les cas purement numeriques.
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; l(-1, 1)
    1.0
    &gt;&gt;&gt; l(x=-1, y=1)
    1.0
    &gt;&gt;&gt; np.round(l(0, np.linspace(-1, 1, 5)), 2)
    array([-0.46,  0.38,  1.  ,  1.38,  1.54])
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    # Cas patologiques.
    if not args and not kwargs:
        return self.expr
    if len(args) &gt; len(self.args):
        raise IndexError(f&#34;La fonction ne prend que {len(self.args)} arguments. &#34;
            f&#34;Or vous en avez fournis {len(args)}.&#34;)
    
    # Recuperation des arguments complets.
    args = list(args)
    args += self.args[len(args):]
    if kwargs:
        if set(kwargs) - set(self.args_position):
            raise NameError(f&#34;Les parametres {set(kwargs) - set(self.args_position)} &#34;
                f&#34;ne sont pas admissible, seul {set(self.args_position)} sont admissibles.&#34;)
        for arg, value in kwargs.items():
            args[self.args_position[arg]] = value

    # Cas symbolique.
    if any(isinstance(a, sympy.Basic) for a in args):
        sub = {arg: value for arg, value in zip(self.args, args)}
        return subs(self.expr, sub)

    # Cas numerique.
    if (
            (self.fct_numexpr is not None)
            and (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)
            and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))
        ):
        return self.fct_numexpr(*args)
    return self.fct(*args)</code></pre>
</details>
</dd>
<dt id="laue.utilities.lambdify.Lambdify.__getstate__"><code class="name flex">
<span>def <span class="ident">__getstate__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Extrait l'information serialisable. </strong></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
&gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
&gt;&gt;&gt;
&gt;&gt;&gt; l = Lambdify([x, y], cos(x + y) + x + y)
&gt;&gt;&gt; l.__getstate__()
([x, y], x + y + cos(x + y), False)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __getstate__(self):
    &#34;&#34;&#34;
    ** Extrait l&#39;information serialisable. **

    Examples
    --------
    &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
    &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
    &gt;&gt;&gt;
    &gt;&gt;&gt; l = Lambdify([x, y], cos(x + y) + x + y)
    &gt;&gt;&gt; l.__getstate__()
    ([x, y], x + y + cos(x + y), False)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if self.expr == self._simp_expr:
        return (self.args, self.expr, self.verbose)
    return (self.args, self.expr, self.verbose, self._simp_expr)</code></pre>
</details>
</dd>
<dt id="laue.utilities.lambdify.Lambdify.__setstate__"><code class="name flex">
<span>def <span class="ident">__setstate__</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Instancie l'objet a partir de l'etat. </strong></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
&gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
&gt;&gt;&gt;
&gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
Lambdify([x, y], x + y + cos(x + y))
&gt;&gt;&gt; pickle.loads(pickle.dumps(_))
Lambdify([x, y], x + y + cos(x + y))
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __setstate__(self, state):
    &#34;&#34;&#34;
    ** Instancie l&#39;objet a partir de l&#39;etat. **

    Examples
    --------
    &gt;&gt;&gt; import pickle
    &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
    &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
    &gt;&gt;&gt;
    &gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
    Lambdify([x, y], x + y + cos(x + y))
    &gt;&gt;&gt; pickle.loads(pickle.dumps(_))
    Lambdify([x, y], x + y + cos(x + y))
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if len(state) == 4:
        self.__init__(state[0], state[1], verbose=state[2], _simp_expr=state[3])
    else:
        self.__init__(state[0], state[1], verbose=state[2])</code></pre>
</details>
</dd>
<dt id="laue.utilities.lambdify.Lambdify.__str__"><code class="name flex">
<span>def <span class="ident">__str__</span></span>(<span>self, *, name='lambdifygenerated', bloc='numpy')</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Offre une representation explicite de la fonction. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Le nom a donner a la fonction.</dd>
<dt><strong><code>bloc</code></strong> :&ensp;<code>str</code></dt>
<dd>La partie du code a impromer. Permet de selectionner la fonction.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos, pi
&gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
&gt;&gt;&gt;
&gt;&gt;&gt; print(Lambdify([x, y], pi*cos(x + y) + x + y), end=&quot;&quot;)
def _lambdifygenerated_numpy(x, y):
    &quot;&quot;&quot;Perform calculations in small float using the numpy module.&quot;&quot;&quot;
    x0 = x + y
    _0 = x0 + 3.14159265358979*cos(x0)
    return _0
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __str__(self, *, name=&#34;lambdifygenerated&#34;, bloc=&#34;numpy&#34;):
    &#39;&#39;&#39;
    ** Offre une representation explicite de la fonction. **

    Parameters
    ----------
    name : str
        Le nom a donner a la fonction.
    bloc : str
        La partie du code a impromer. Permet de selectionner la fonction.

    Examples
    --------
    &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos, pi
    &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
    &gt;&gt;&gt;
    &gt;&gt;&gt; print(Lambdify([x, y], pi*cos(x + y) + x + y), end=&#34;&#34;)
    def _lambdifygenerated_numpy(x, y):
        &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;
        x0 = x + y
        _0 = x0 + 3.14159265358979*cos(x0)
        return _0
    &gt;&gt;&gt;
    &#39;&#39;&#39;
    assert isinstance(name, str), f&#34;&#39;name&#39; has to be str, not {type(name).__name__}.&#34;
    assert bloc in {&#34;main&#34;, &#34;numpy&#34;, &#34;numpy128&#34;, &#34;numexpr&#34;, &#34;sympy&#34;}
    import re

    # Code numexpr.
    if bloc == &#34;numexpr&#34;:
        if self.fct_numexpr is not None:
            code = self.fct_numexpr.__doc__.split(&#34;\n&#34;)
            code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numexpr&#34;)
            code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float64 using the numexpr module.&#34;&#34;&#34;&#39;)
        else:
            code = []

    # Code &lt; float 64
    elif bloc == &#34;numpy&#34;:
        code = lambdify(self.args, evalf(self._simp_expr),
            cse=True, modules=&#34;numpy&#34;).__doc__.split(&#34;\n&#34;)
        code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy&#34;)
        code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;&#39;)

    # Code float 128
    elif bloc == &#34;numpy128&#34;:
        f_mod = re.compile(r&#34;&#34;&#34;(?:[+-]*
            (?:
              \. [0-9]+ (?:_[0-9]+)*
              (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
            | [0-9]+ (?:_[0-9]+)* \. (?: [0-9]+ (?:_[0-9]+)* )?
              (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
            | [0-9]+ (?:_[0-9]+)*
              e [+-]? [0-9]+ (?:_[0-9]+)*
            ))&#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE) # Model d&#39;un flottant.
        code_str = self.fct.__doc__
        code_str = re.sub(f_mod,
            lambda m: (f&#34;float128({repr(m.group())})&#34; if len(m.group()) &gt;= 15 else m.group()),
            code_str)
        code = code_str.split(&#34;\n&#34;)
        code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy128&#34;)
        code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float128 using the numpy module.&#34;&#34;&#34;&#39;)

    # Expression formelle
    elif bloc == &#34;sympy&#34;:
        defs, rvs = cse_homogeneous(self.expr)
        code = []
        code.append(f&#34;def _{name}_sympy():&#34;)
        code.append( &#39;    &#34;&#34;&#34;Returns the tree of the sympy expression.&#34;&#34;&#34;&#39;)
        code.append(f&#34;    {&#39;, &#39;.join(self.args_name)} = symbols(&#39;{&#39; &#39;.join(self.args_name)}&#39;)&#34;)
        for var, expr in defs:
            code.append(f&#34;    {var} = {expr}&#34;)
        code.append(f&#34;    return {rvs}&#34;)
        code.append( &#34;&#34;)

    # Fonction principale Equivalent as self.__call__.
    elif bloc == &#34;main&#34;:
        code = []
        code.append(f&#34;def {name}(*args, **kwargs):&#34;)
        code.append( &#39;    &#34;&#34;&#34;&#39;)
        code.append( &#34;    ** Choose the most suitable function according to&#34;)
        code.append( &#34;    the type and size of the input data. **&#34;)
        code.append( &#34;&#34;)
        code.append( &#34;    Parameters&#34;)
        code.append( &#34;    ----------&#34;)
        code.append( &#34;    *args&#34;)
        code.append( &#34;        Les parametres ordonnes de la fonction.&#34;)
        code.append( &#34;    **kwargs&#34;)
        code.append( &#34;        Les parametres nomes de la fonction. Ils&#34;)
        code.append( &#34;        ont le dessus sur les args en cas d&#39;ambiguite.&#34;)
        code.append( &#39;    &#34;&#34;&#34;&#39;)

        code.append( &#34;    assert len(args) &lt;= %d, f&#39;The function cannot take {len(args)} arguments.&#39;&#34;
                                            % len(self.args))
        code.append( &#34;    assert not set(kwargs) - {%s}, f&#39;You cannot provide {kwargs}.&#39;&#34;
                                                  % &#34;, &#34;.join(repr(a) for a in self.args_name))
        code.append( &#34;    if not args and not kwargs:&#34;)
        code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
        code.append(f&#34;        return _{name}_sympy()&#34;)

        code.append( &#34;    args = list(args)&#34;)
        code.append(f&#34;    if len(args) &lt; {len(self.args)}:&#34;)
        code.append(f&#34;        args += sympy.symbols(&#39; &#39;.join({self.args_name}[len(args):]))&#34;)
        code.append( &#34;    if kwargs:&#34;)
        code.append( &#34;        for arg, value in kwargs.items():&#34;)
        code.append(f&#34;            args[{self.args_position}[arg]] = value&#34;)

        code.append( &#34;    if any(isinstance(a, sympy.Basic) for a in args):&#34;)
        code.append( &#34;        sub = {arg: value for arg, value in zip(%s, args)}&#34; % self.args_name)
        code.append( &#34;        from laue.utilities.lambdify import subs&#34;)
        code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
        code.append(f&#34;        return subs(_{name}_sympy(), sub)&#34;)

        if hasattr(np, &#34;float128&#34;):
            code.append( &#34;    if any(a.dtype == np.float128 for a in args if isinstance(a, np.ndarray)):&#34;)
            code.append(f&#34;        from laue.data.numpy128_lambdify import _{name}_numpy128&#34;)
            code.append(f&#34;        return _{name}_numpy128(*args)&#34;)
        if self.fct_numexpr is not None:
            code.append( &#34;    if (&#34;)
            code.append( &#34;            (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)&#34;)
            code.append( &#34;            and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))&#34;)
            code.append( &#34;        ):&#34;)
            code.append(f&#34;        from laue.data.numexpr_lambdify import _{name}_numexpr&#34;)
            code.append(f&#34;        return _{name}_numexpr(*args)&#34;)
        code.append(f&#34;    from laue.data.numpy_lambdify import _{name}_numpy&#34;)
        code.append(f&#34;    return _{name}_numpy(*args)&#34;)
        code.append( &#34;&#34;)

    else:
        raise KeyError

    return &#34;\n&#34;.join(code)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="laue.utilities.lambdify.TimeCost"><code class="flex name class">
<span>class <span class="ident">TimeCost</span></span>
</code></dt>
<dd>
<div class="desc"><p><strong> Estime le cout d'une expression. </strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeCost:
    &#34;&#34;&#34;
    ** Estime le cout d&#39;une expression. **
    &#34;&#34;&#34;
    def __init__(self):
        self.costs = {}

        self._zero = np.zeros(shape=(1000, 1000))
        self._one = np.ones(shape=(1000, 1000))
        self._false = self._zero.astype(bool)
        self._true = self._one.astype(bool)
        self._negone = -self._one
        self._two = 2.0*self._one
        self._bat = .32267452*self._one
        self._comp = (1.0 + 1.0j)*self._one

        self._tests = {
            &#34;Abs&#34;: (lambda: np.abs(self._negone)),
            &#34;Add&#34;: (lambda: self._bat + self._bat),
            &#34;And&#34;: (lambda: self._true &amp; self._true),
            &#34;BooleanTrue&#34;: (lambda: self._one.astype(bool)),
            &#34;Equality&#34;: (lambda: self._bat == self._bat),
            &#34;GreaterThan&#34;: (lambda: self._one &gt;= self._one),
            &#34;LessThan&#34;: (lambda: self._one &lt;= self._one),
            &#34;MatAdd&#34;: (lambda: self._bat + self._bat),
            &#34;MatMul&#34;: (lambda: self._bat @ self._bat),
            &#34;MatPow&#34;: (lambda: self._bat ** self._bat),
            &#34;Max&#34;: (lambda: np.max(self._one)),
            &#34;Min&#34;: (lambda: np.min(self._one)),
            &#34;Mod&#34;: (lambda: self._one % self._bat),
            &#34;Mul&#34;: (lambda: self._bat * self._bat),
            &#34;Nand&#34;: (lambda: not np.all(self._true)),
            &#34;Nor&#34;: (lambda: not np.any(self._false)),
            &#34;Not&#34;: (lambda: ~ self._true),
            &#34;Or&#34;: (lambda: self._false | self._false),
            &#34;Piecewise&#34;: (lambda: ... if True else ...),
            &#34;Pow&#34;: (lambda: self._two ** self._bat),
            &#34;StrictGreaterThan&#34;: (lambda: self._one &gt; self._one),
            &#34;StrictLessThan&#34;: (lambda: self._one &lt; self._one),
            &#34;Transpose&#34;: (lambda: np.transpose(self._zero)),
            &#34;Unequality&#34;: (lambda: self._bat != self._bat),
            &#34;Xor&#34;: (lambda: (self._false|self._true) &amp; ~(self._false&amp;self._true)),
            &#34;acos&#34;: (lambda: np.arccos(self._bat)),
            &#34;acosh&#34;: (lambda: np.arccosh(self._two)),
            &#34;arg&#34;: (lambda: np.angle(self._comp)),
            &#34;asin&#34;: (lambda: np.arcsin(self._bat)),
            &#34;asinh&#34;: (lambda: np.arcsinh(self._bat)),
            &#34;atan&#34;: (lambda: np.arctan(self._bat)),
            &#34;atan2&#34;: (lambda: np.arctan2(self._bat, self._one)),
            &#34;atanh&#34;: (lambda: np.arctanh(self._bat)),
            &#34;conjugate&#34;: (lambda: np.conjugate(self._comp)),
            &#34;cos&#34;: (lambda: np.cos(self._bat)),
            &#34;cosh&#34;: (lambda: np.cosh(self._bat)),
            &#34;exp&#34;: (lambda: np.exp(self._bat)),
            &#34;im&#34;: (lambda: np.imag(self._comp)),
            &#34;log&#34;: (lambda: np.log(self._bat)),
            &#34;re&#34;: (lambda: np.real(self._comp)),
            &#34;sign&#34;: (lambda: np.sign(self._bat)),
            &#34;sin&#34;: (lambda: np.sin(self._bat)),
            &#34;sinc&#34;: (lambda: np.sinc(self._bat)),
            &#34;sinh&#34;: (lambda: np.sinh(self._bat)),
            &#34;sqrt&#34;: (lambda: np.sqrt(self._bat)),
            &#34;tan&#34;: (lambda: np.tan(self._bat)),
            &#34;tanh&#34;: (lambda: np.tanh(self._bat)),
            &#34;eval&#34;: (lambda: np.float64(&#34;0.123456789e+01&#34;)),
            &#34;aloc&#34;: (lambda: np.zeros(shape=(1000, 1000))),
            &#34;div&#34;: (lambda: 1/self._bat),
            &#34;**2&#34;: (lambda: self._bat**2),
        }

        self.load_save()

    def load_save(self):
        &#34;&#34;&#34;
        Charge le fichier qui contient les resultats.
        &#34;&#34;&#34;
        dirname = os.path.join(os.path.dirname(os.path.abspath(laue.__file__)), &#34;data&#34;)
        file = os.path.join(dirname, &#34;timecost.pickle&#34;)
        if os.path.exists(file):
            with open(file, &#34;rb&#34;) as f:
                self.__setstate__(pickle.load(f))
        else:
            with open(file, &#34;wb&#34;) as f:
                pickle.dump(self.__getstate__(), f)

    def atom_cost(self, key):
        &#34;&#34;&#34;
        Retourne le cout de l&#39;opperateur.
        &#34;&#34;&#34;
        if key in self.costs:
            return self.costs[key]
        if hasattr(self, &#34;_tests&#34;):
            if key in self._tests:
                self.costs[key] = timeit.timeit(self._tests[key], number=100)
                return self.costs[key]
        raise ValueError(f&#34;L&#39;opperation {key} est inconnue.&#34;)

    def branch_cost(self, branch):
        &#34;&#34;&#34;
        Le cout brut de l&#39;expression sympy sans cse.
        &#34;&#34;&#34;
        if isinstance(branch, (sympy.Atom, numbers.Number)):
            return self.atom_cost(&#34;eval&#34;)

        if isinstance(branch, (sympy.Add, sympy.And, sympy.MatAdd, sympy.MatMul,
                sympy.MatPow, sympy.Mul, sympy.Nand, sympy.Nor, sympy.Or, sympy.Xor)):
            op_cost = self.atom_cost(type(branch).__name__) * (len(branch.args)-1)
            return sum((self.branch_cost(e) for e in branch.args)) + op_cost

        if isinstance(branch, sympy.Pow):
            if isinstance(branch.exp, sympy.Number):
                if branch.exp == 2:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;**2&#34;)
                if branch.exp == sympy.S.Half:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;sqrt&#34;)
                if branch.exp == -sympy.S.Half:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;sqrt&#34;)
                if branch.exp == -sympy.S.One:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;)
                if branch.exp == -2:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;**2&#34;)
            return self.branch_cost(branch.base) + self.branch_cost(branch.exp) + self.atom_cost(&#34;Pow&#34;)

        if isinstance(branch, sympy.Piecewise):
            op_cost = self.atom_cost(&#34;Piecewise&#34;) * (len(branch.args)-1)
            return sum(
                self.branch_cost(val) + sum(self.branch_cost(a) for a in cond.args)
                for val, cond in branch.args) + op_cost

        return sum((self.branch_cost(e) for e in branch.args)) + self.atom_cost(type(branch).__name__)

    def __call__(self, expr):
        &#34;&#34;&#34;
        Le cout de l&#39;expression avec cse.
        &#34;&#34;&#34;
        defs, rvs = sympy.cse(expr)
        return (sum(self.branch_cost(e) for var, e in defs)
              + sum(self.branch_cost(e) for e in rvs)
              + len(defs)*self.atom_cost(&#34;aloc&#34;))

    def __getstate__(self):
        if hasattr(self, &#34;_tests&#34;):
            for key in self._tests:
                self.atom_cost(key)
        return self.costs

    def __setstate__(self, state):
        self.costs = state</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="laue.utilities.lambdify.TimeCost.atom_cost"><code class="name flex">
<span>def <span class="ident">atom_cost</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Retourne le cout de l'opperateur.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atom_cost(self, key):
    &#34;&#34;&#34;
    Retourne le cout de l&#39;opperateur.
    &#34;&#34;&#34;
    if key in self.costs:
        return self.costs[key]
    if hasattr(self, &#34;_tests&#34;):
        if key in self._tests:
            self.costs[key] = timeit.timeit(self._tests[key], number=100)
            return self.costs[key]
    raise ValueError(f&#34;L&#39;opperation {key} est inconnue.&#34;)</code></pre>
</details>
</dd>
<dt id="laue.utilities.lambdify.TimeCost.branch_cost"><code class="name flex">
<span>def <span class="ident">branch_cost</span></span>(<span>self, branch)</span>
</code></dt>
<dd>
<div class="desc"><p>Le cout brut de l'expression sympy sans cse.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def branch_cost(self, branch):
    &#34;&#34;&#34;
    Le cout brut de l&#39;expression sympy sans cse.
    &#34;&#34;&#34;
    if isinstance(branch, (sympy.Atom, numbers.Number)):
        return self.atom_cost(&#34;eval&#34;)

    if isinstance(branch, (sympy.Add, sympy.And, sympy.MatAdd, sympy.MatMul,
            sympy.MatPow, sympy.Mul, sympy.Nand, sympy.Nor, sympy.Or, sympy.Xor)):
        op_cost = self.atom_cost(type(branch).__name__) * (len(branch.args)-1)
        return sum((self.branch_cost(e) for e in branch.args)) + op_cost

    if isinstance(branch, sympy.Pow):
        if isinstance(branch.exp, sympy.Number):
            if branch.exp == 2:
                return self.branch_cost(branch.base) + self.atom_cost(&#34;**2&#34;)
            if branch.exp == sympy.S.Half:
                return self.branch_cost(branch.base) + self.atom_cost(&#34;sqrt&#34;)
            if branch.exp == -sympy.S.Half:
                return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;sqrt&#34;)
            if branch.exp == -sympy.S.One:
                return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;)
            if branch.exp == -2:
                return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;**2&#34;)
        return self.branch_cost(branch.base) + self.branch_cost(branch.exp) + self.atom_cost(&#34;Pow&#34;)

    if isinstance(branch, sympy.Piecewise):
        op_cost = self.atom_cost(&#34;Piecewise&#34;) * (len(branch.args)-1)
        return sum(
            self.branch_cost(val) + sum(self.branch_cost(a) for a in cond.args)
            for val, cond in branch.args) + op_cost

    return sum((self.branch_cost(e) for e in branch.args)) + self.atom_cost(type(branch).__name__)</code></pre>
</details>
</dd>
<dt id="laue.utilities.lambdify.TimeCost.load_save"><code class="name flex">
<span>def <span class="ident">load_save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Charge le fichier qui contient les resultats.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_save(self):
    &#34;&#34;&#34;
    Charge le fichier qui contient les resultats.
    &#34;&#34;&#34;
    dirname = os.path.join(os.path.dirname(os.path.abspath(laue.__file__)), &#34;data&#34;)
    file = os.path.join(dirname, &#34;timecost.pickle&#34;)
    if os.path.exists(file):
        with open(file, &#34;rb&#34;) as f:
            self.__setstate__(pickle.load(f))
    else:
        with open(file, &#34;wb&#34;) as f:
            pickle.dump(self.__getstate__(), f)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#permet-de-faire-un-pont-entre-le-calcul-symbolique-et-matriciel">Permet de faire un pont entre le calcul symbolique et matriciel.</a></li>
<li><a href="#notes">Notes</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laue.utilities" href="index.html">laue.utilities</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laue.utilities.lambdify.cse_homogeneous" href="#laue.utilities.lambdify.cse_homogeneous">cse_homogeneous</a></code></li>
<li><code><a title="laue.utilities.lambdify.cse_minimize_memory" href="#laue.utilities.lambdify.cse_minimize_memory">cse_minimize_memory</a></code></li>
<li><code><a title="laue.utilities.lambdify.simplify" href="#laue.utilities.lambdify.simplify">simplify</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laue.utilities.lambdify.Lambdify" href="#laue.utilities.lambdify.Lambdify">Lambdify</a></code></h4>
<ul class="">
<li><code><a title="laue.utilities.lambdify.Lambdify.__call__" href="#laue.utilities.lambdify.Lambdify.__call__">__call__</a></code></li>
<li><code><a title="laue.utilities.lambdify.Lambdify.__getstate__" href="#laue.utilities.lambdify.Lambdify.__getstate__">__getstate__</a></code></li>
<li><code><a title="laue.utilities.lambdify.Lambdify.__setstate__" href="#laue.utilities.lambdify.Lambdify.__setstate__">__setstate__</a></code></li>
<li><code><a title="laue.utilities.lambdify.Lambdify.__str__" href="#laue.utilities.lambdify.Lambdify.__str__">__str__</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="laue.utilities.lambdify.TimeCost" href="#laue.utilities.lambdify.TimeCost">TimeCost</a></code></h4>
<ul class="">
<li><code><a title="laue.utilities.lambdify.TimeCost.atom_cost" href="#laue.utilities.lambdify.TimeCost.atom_cost">atom_cost</a></code></li>
<li><code><a title="laue.utilities.lambdify.TimeCost.branch_cost" href="#laue.utilities.lambdify.TimeCost.branch_cost">branch_cost</a></code></li>
<li><code><a title="laue.utilities.lambdify.TimeCost.load_save" href="#laue.utilities.lambdify.TimeCost.load_save">load_save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>