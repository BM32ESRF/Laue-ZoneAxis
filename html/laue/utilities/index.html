<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>laue.utilities API documentation</title>
<meta name="description" content="** Outils en tout genre. **
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>laue.utilities</code></h1>
</header>
<section id="section-intro">
<h2 id="outils-en-tout-genre"><strong> Outils en tout genre. </strong></h2>
<p>Toute la gestion du contexte et des fonctionalite
qui ne sont pas des fonctionnalitee de coeur sont
codee ici.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
** Outils en tout genre. **
---------------------------

Toute la gestion du contexte et des fonctionalite
qui ne sont pas des fonctionnalitee de coeur sont
codee ici.
&#34;&#34;&#34;

import inspect

from .data_consistency import Recordable
from .image import read_image, create_image, images_to_iter
from .lambdify import TimeCost, Lambdify
from .multi_core import (limited_imap, pickleable_method,
    prevent_generator_size, reduce_object, NestablePool,
    RecallingIterator)
from .parsing import extract_parameters

__all__ = [
    &#34;Recordable&#34;,
    &#34;read_image&#34;, &#34;create_image&#34;, &#34;images_to_iter&#34;,
    &#34;TimeCost&#34;, &#34;Lambdify&#34;,
    &#34;limited_imap&#34;, &#34;pickleable_method&#34;, &#34;prevent_generator_size&#34;,
    &#34;reduce_object&#34;, &#34;NestablePool&#34;, &#34;RecallingIterator&#34;,
    &#34;extract_parameters&#34;]

__pdoc__ = {obj: (&#34;Alias vers ``laue.&#34;
                  f&#34;{inspect.getsourcefile(globals()[obj]).split(&#39;laue/&#39;)[-1][:-3].replace(&#39;/&#39;, &#39;.&#39;).replace(&#39;.__init__&#39;, &#39;&#39;)}&#34;
                  f&#34;.{obj}``&#34;)
            for obj in __all__}
__pdoc__ = {**__pdoc__, **{f&#34;{cl}.{meth}&#34;: False
            for cl in __all__ if globals()[cl].__class__.__name__ == &#34;type&#34;
            for meth in globals()[cl].__dict__ if not meth.startswith(&#34;_&#34;)}}</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="laue.utilities.data_consistency" href="data_consistency.html">laue.utilities.data_consistency</a></code></dt>
<dd>
<div class="desc"><p><strong> Permet de gerer l'enregistrement des experiences en arriere plan. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.utilities.fork_lambdify" href="fork_lambdify.html">laue.utilities.fork_lambdify</a></code></dt>
<dd>
<div class="desc"><p>This module provides convenient functions to transform sympy expressions to
lambda functions which can be used to calculate numerical values very fast.</p></div>
</dd>
<dt><code class="name"><a title="laue.utilities.image" href="image.html">laue.utilities.image</a></code></dt>
<dd>
<div class="desc"><p><strong> Outil de creation et de lecture d'image. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.utilities.lambdify" href="lambdify.html">laue.utilities.lambdify</a></code></dt>
<dd>
<div class="desc"><p><strong> Permet de faire un pont entre le calcul symbolique et matriciel. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.utilities.multi_core" href="multi_core.html">laue.utilities.multi_core</a></code></dt>
<dd>
<div class="desc"><p><strong> Outils pour le paralelisme. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.utilities.parsing" href="parsing.html">laue.utilities.parsing</a></code></dt>
<dd>
<div class="desc"><p><strong> Extrait l'informations de donnes pas bien rigoureuses. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.utilities.serialization" href="serialization.html">laue.utilities.serialization</a></code></dt>
<dd>
<div class="desc"><p><strong> Interface d'aide a pickle. </strong>
…</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laue.utilities.create_image"><code class="name flex">
<span>def <span class="ident">create_image</span></span>(<span>positions, intensities=None, *, shape=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.image.create_image" href="image.html#laue.utilities.image.create_image">create_image()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_image(positions, intensities=None, *, shape=None):
    &#34;&#34;&#34;
    ** Genere syntetiquement une image de laue. **

    Paremeters
    ----------
    positions : iterable
        Les coordonnes x et y des spots en pxl dans le plan de la camera.
    intensities : iterable, optional
        L&#39;intensite de chaque spot.
    shape : tuple, optional
        Les dimensions x, y de l&#39;image de sortie. Par defaut, les
        valeurs maximales des positions sont utilisees.

    Returns
    -------
    image : np.ndarray
        L&#39;image en niveau de gris codee en uint16.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue.utilities.image import create_image
    &gt;&gt;&gt; np.random.seed(0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; positions = np.random.uniform(0, 2048, size=(2, 600))
    &gt;&gt;&gt; create_image(positions)
    array([[    0,     0,     0, ...,     0,     0,     0],
           [    0,     0,     0, ...,     0,     0,     0],
           [    0,     0,     0, ...,     0,     0,     0],
           ...,
           [    0,     0,     0, ...,  6592,  6592,  6592],
           [    0,     0,     0, ..., 12128, 12128, 12128],
           [    0,     0,     0, ..., 12128, 12128, 12128]], dtype=uint16)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(positions, (np.ndarray, list, tuple)), \
        f&#34;&#39;positions&#39; doit etre un iterable ordonne, pas {positions}.&#34;
    assert intensities is None or isinstance(intensities, (np.ndarray, list, tuple)), \
        f&#34;&#39;intensities&#39; doit etre un iterable ordonne, pas {intensities}.&#34;
    assert shape is None or isinstance(shape, tuple), \
        f&#34;&#39;shape&#39; has to be a tuple, not a {type(shape).__name__}.&#34;
    positions = np.array(positions)
    assert positions.ndim == 2, f&#34;Les positions doivent etre une matrice 2d, pas {positions.ndim}d.&#34;
    if positions.shape[1] == 2 and positions.shape[0] != 2:
        positions = positions.transpose()
    intensities = np.ones(positions.shape[1]) if intensities is None else np.array(intensities)
    assert intensities.shape == (positions.shape[1],), (&#34;Les positions sous-entendent qu&#39;il y a &#34;
        f&#34;{positions.shape[1]} spots. Les intensites doivent donc etre de shape=({positions.shape[1]},) &#34;
        f&#34;et non pas {intensities.shape}.&#34;)
    shape = (int(positions[0].max()+1), int(positions[1].max()+1)) if shape is None else shape
    assert len(shape) == 2, f&#34;L&#39;image et en 2d, pas en {len(shape)}d.&#34;
    assert isinstance(shape[0], int) and isinstance(shape[1], int), \
        f&#34;Les dimensions de l&#39;image sont en pxl et donc doivent etre des entiers.&#34;

    image = np.zeros(shape=shape, dtype=np.uint16)
    intensities *= len(intensities)/intensities.mean()

    for x, y, lum in zip(*positions, intensities):
        l = int(lum) + 1
        x, y = int(round(x)), int(round(y))
        cost = int(100*lum)
        image[x-l:x+l, y-l:y+l] += cost

    return image</code></pre>
</details>
</dd>
<dt id="laue.utilities.extract_parameters"><code class="name flex">
<span>def <span class="ident">extract_parameters</span></span>(<span>ignore_missing=False, **detector_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.parsing.extract_parameters" href="parsing.html#laue.utilities.parsing.extract_parameters">extract_parameters()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_parameters(ignore_missing=False, **detector_parameters):
    &#34;&#34;&#34;
    ** Extrait les parametres de la camera. **

    Notes
    -----
    * Permet une grande souplesse d&#39;utilisation.
    * Tous les parametres ne sont pas forcement a preciser.

    Parameters
    ----------
    ignore_missing : boolean, optional
        * Permet d&#39;imposer ou non, d&#39;avoir un retour exhaustif:
        * True =&gt; Retourne toutes les grandeurs extraites, meme si il en manque.
        * False =&gt; S&#39;assure que tous les parametres ont etes correctement extraits.
    config_file : str
        Chemin du fichier &#39;*.det&#39; qui contient tous ces parametres.

    dd, detect, distance : float, int
        Plus courte distance entre l&#39;origine du cristal et le plan de la camera.
        ||OO&#39;|| en mm
    xcen, x0 : float, int
        Distance entre l&#39;origine de la camera et le point d&#39;incidence normal projetee selon X_camera.
        &lt;O&#39;&#39;O&#39;, Ci&gt; en pxl
    ycen, y0 : float, int
        Distance entre l&#39;origine de la camera et le point d&#39;incidence normal projetee selon Y_camera.
        &lt;O&#39;&#39;O&#39;, Cj&gt; en pxl
    xbet, bet, beta, angle1 : float
        Rotation du repere de la camera autour de l&#39;axe Y_cristal dans le sens.
        axe (Y_cristal ou Ci) en degre
    xgam, gam, gamma, angle2 : float
        Rotation du repere de la camera autour de l&#39;axe Ck qui a deja subit la rotation de ``xbet``.
        axe (OO&#39; ou Ck) en degre
    pixelsize, size, pxlsize : float
        Dimension du cote des pixels carre du capteur.
        (taille capteur x / nbr pixels x == taille capteur y / nbr pixels y) en mm/pxl

    Returns
    -------
    dict
        Le dictionaire qui a chaque nom de parametre, associ ca valeur.
        Les clefs et les valeurs typique sont par example:
        ``{&#34;dd&#34;: 70.0, &#34;xcen&#34;: 1024, &#34;ycen&#34;: 1024, &#34;xbet&#34;: .0, &#34;xgam&#34;: .0, &#34;pixelsize&#34;: .080567}``

    Raises
    ------
    ValueError
        Si il y a des incoherences. (Par example si le meme parametre a 2 valeurs differentes)
    KeyError
        Si il manque des parametres.

    Examples
    --------
    &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
    &gt;&gt;&gt; output = lambda pars: &#34;, &#34;.join(f&#34;{repr(k)}: {round(pars[k], 2)}&#34; for k in sorted(pars))
    &gt;&gt;&gt;
    &gt;&gt;&gt; output(extract_parameters(config_file=&#34;laue/examples/ge_blanc.det&#34;))
    &#34;&#39;dd&#39;: 71.51, &#39;pixelsize&#39;: 0.08, &#39;xbet&#39;: 0.43, &#39;xcen&#39;: 939.83, &#39;xgam&#39;: -0.7, &#39;ycen&#39;: 1076.42&#34;
    &gt;&gt;&gt; output(extract_parameters(dd=70, bet=.0, gam=.0, pixelsize=.08, x0=1024, y0=1024))
    &#34;&#39;dd&#39;: 70, &#39;pixelsize&#39;: 0.08, &#39;xbet&#39;: 0.0, &#39;xcen&#39;: 1024, &#39;xgam&#39;: 0.0, &#39;ycen&#39;: 1024&#34;
    &gt;&gt;&gt; output(extract_parameters(distance=70, angle2=.0, angle1=.0, size=.08, x0=1024, y0=1024))
    &#34;&#39;dd&#39;: 70, &#39;pixelsize&#39;: 0.08, &#39;xbet&#39;: 0.0, &#39;xcen&#39;: 1024, &#39;xgam&#39;: 0.0, &#39;ycen&#39;: 1024&#34;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    # Verification de type et contenu.
    assert isinstance(ignore_missing, bool), \
        f&#34;&#39;ignore_missing&#39; has to be a boolean, not a {type(ignore_missing).__name__}.&#34;
    if &#34;config_file&#34; in detector_parameters:
        assert isinstance(detector_parameters[&#34;config_file&#34;], str), (&#34;&#39;file&#39; doit etre un chemin de &#34;
            f&#34;fichier de type str, pas {type(detector_parameters[&#39;config_file&#39;]).__name__}.&#34;)
        assert os.path.isfile(detector_parameters[&#34;config_file&#34;]), \
            f&#34;{repr(detector_parameters[&#39;config_file&#39;])} n&#39;est pas un fichier qui existe.&#34;
    for dist in (&#34;dd&#34;, &#34;detect&#34;, &#34;distance&#34;):
        if dist in detector_parameters:
            assert isinstance(detector_parameters[dist], numbers.Number), \
                f&#34;&#39;{dist}&#39; doit etre un nombre, pas un {type(detector_parameters[dist]).__name__}.&#34;
            assert detector_parameters[dist] &gt; 0, \
                f&#34;Toute distance doit etre positive, or elle vaut {detector_parameters[dist]}.&#34;
    for pos in (&#34;xcen&#34;, &#34;x0&#34;, &#34;ycen&#34;, &#34;y0&#34;):
        if pos in detector_parameters:
            assert isinstance(detector_parameters[pos], numbers.Number), \
                f&#34;&#39;{pos}&#39; doit etre un nombre, pas un {type(detector_parameters[pos]).__name__}.&#34;
    for angle in (&#34;xbet&#34;, &#34;bet&#34;, &#34;beta&#34;, &#34;angle1&#34;, &#34;xgam&#34;, &#34;gam&#34;, &#34;gamma&#34;, &#34;angle2&#34;):
        if angle in detector_parameters:
            assert isinstance(detector_parameters[angle], float), \
                f&#34;&#39;{angle}&#39; doit etre un flottant, pas un {type(detector_parameters[angle]).__name__}.&#34;
            assert -4.84 &lt; detector_parameters[angle] &lt; 4.84, (&#34;L&#39;angle de correction doit etre petit car &#34;
                &#34;un developement limite permet d&#39;accelerer les calculs. Seulement on autorise une erreur &#34;
                f&#34;de 1e-4 qui correpond a 4.84 degres, pas {detector_parameters[angle]}.&#34;)
    for size in (&#34;pixelsize&#34;, &#34;size&#34;, &#34;pxlsize&#34;):
        if size in detector_parameters:
            assert isinstance(detector_parameters[size], float), \
                f&#34;&#39;{size}&#39; doit etre un flottant, pas un {type(detector_parameters[size]).__name__}.&#34;
            assert detector_parameters[size] &gt; 0, \
                f&#34;La taille d&#39;un pixel doit etre positive, or elle vaut {detector_parameters[size]}.&#34;

    parameters = {} # C&#39;est le dictionaire des parametres extraits.

    # Extraction des informations du fichier.
    if &#34;config_file&#34; in detector_parameters:
        f_mod = re.compile(r&#34;&#34;&#34;(?:[+-]*
                (?:
                  \. [0-9]+ (?:_[0-9]+)*
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)* \. (?: [0-9]+ (?:_[0-9]+)* )?
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)*
                  e [+-]? [0-9]+ (?:_[0-9]+)*
                ))&#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE) # Model d&#39;un flottant.
        i_mod = re.compile(r&#34;&#34;&#34;(?:[+-]*
                    # entier normal
                    [0-9]+ (?:_[0-9]+)*
                | 0 (?:
                    # binary
                    b [01]+ (?:_[01]+)*
                  | # octal
                    o [0-7]+ (?:_[0-7]+)*
                  | # hexadecimal
                    x [0-9a-f]+ (?:_[0-9a-f]+)*
                )
                )&#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE) # Model d&#39;un entier.
        complete_model = re.compile(r&#34;&#34;&#34;^[\[\(]?\s*?(?:
                    (?P&lt;dd&gt;{f_mod}) [\s,]+
                    (?P&lt;xcen&gt;{f_mod}) [\s,]+
                    (?P&lt;ycen&gt;{f_mod}) [\s,]+
                    (?P&lt;xbet&gt;{f_mod}) [\s,]+
                    (?P&lt;xgam&gt;{f_mod})
                    (?: [\s,]+ (?P&lt;pixelsize&gt;{f_mod}))?
                )
                &#34;&#34;&#34;.format(f_mod=f_mod.pattern, i_mod=i_mod.pattern), re.VERBOSE | re.IGNORECASE)
        dd_model = re.compile(rf&#34;(?:dd|detect|distance)[\s:=]+(?P&lt;dd&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        xcen_model = re.compile(rf&#34;(?:xcen|x0)[\s:=]+(?P&lt;xcen&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        ycen_model = re.compile(rf&#34;(?:ycen|y0)[\s:=]+(?P&lt;ycen&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        xbet_model = re.compile(rf&#34;(?:xbet|bet|beta|angle1)[\s:=]+(?P&lt;xbet&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        xgam_model = re.compile(rf&#34;(?:xgam|gam|gamma|angle2)[\s:=]+(?P&lt;xgam&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        pixelsize_model = re.compile(rf&#34;(?:size|pixelsize|pxlsize)[\s:=]+(?P&lt;pixelsize&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        keys = {&#34;dd&#34;: dd_model, &#34;xcen&#34;: xcen_model, &#34;ycen&#34;: ycen_model,
                &#34;xbet&#34;: xbet_model, &#34;xgam&#34;: xgam_model}

        with open(detector_parameters[&#34;config_file&#34;], &#34;r&#34;, encoding=&#34;utf-8&#34;, errors=&#34;ignore&#34;) as file:
            for line in file: # Pour chaque ligne du fichier, on tente d&#39;y recuperer les infos.

                # Recherche de la liste des parametres.
                complete_search = re.search(complete_model, line)
                if complete_search is not None:
                    for key in keys:
                        value = float(complete_search[key])
                        if parameters.get(key, value) != value:
                            raise ValueError(f&#34;&#39;{key}&#39; value is ambigous. Is it {parameters[key]} or {value}?&#34;)
                        parameters[key] = value
                    if complete_search[&#34;pixelsize&#34;] is not None:
                        pixelsize = float(complete_search[&#34;pixelsize&#34;])
                        if parameters.get(&#34;pixelsize&#34;, pixelsize) != pixelsize:
                            raise ValueError(&#34;&#39;pixelsize&#39; value is ambigous. &#34;
                                f&#34;Is it {parameters[&#39;pixelsize&#39;]} or {pixelsize}?&#34;)
                        parameters[&#34;pixelsize&#34;] = pixelsize

                # Recherches des parametres isoles.
                for key, model in {**keys, &#34;pixelsize&#34;: pixelsize_model}.items():
                    search = re.search(model, line)
                    if search is not None:
                        value = float(search[key])
                        if parameters.get(key, value) != value:
                            raise ValueError(f&#34;&#39;{key}&#39; value is ambigous. Is it {parameters[key]} or {value}?&#34;)
                        parameters[key] = value

    # 3 Extraction des informations expicites.
    for keys in [(&#34;dd&#34;, &#34;detect&#34;, &#34;distance&#34;),
                 (&#34;xcen&#34;, &#34;x0&#34;),
                 (&#34;ycen&#34;, &#34;y0&#34;),
                 (&#34;xbet&#34;, &#34;bet&#34;, &#34;beta&#34;, &#34;angle1&#34;),
                 (&#34;xgam&#34;, &#34;gam&#34;, &#34;gamma&#34;, &#34;angle2&#34;),
                 (&#34;pixelsize&#34;, &#34;size&#34;, &#34;pxlsize&#34;)]:
        for key in keys:
            if key in detector_parameters:
                value = detector_parameters[key]
                if parameters.get(keys[0], value) != value:
                    raise ValueError(f&#34;&#39;{keys[0]}&#39; value is ambigous. Is it {parameters[keys[0]]} or {value}?&#34;)
                parameters[keys[0]] = value

    # Ajout des valeurs manquantes.
    if not ignore_missing:
        keys = {&#34;dd&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;pixelsize&#34;}
        missing_keys = keys - set(parameters)
        if missing_keys:
            raise KeyError(f&#34;Il manque les parametres {&#39;, &#39;.join(missing_keys)}.&#34;)

    return parameters</code></pre>
</details>
</dd>
<dt id="laue.utilities.images_to_iter"><code class="name flex">
<span>def <span class="ident">images_to_iter</span></span>(<span>images)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.image.images_to_iter" href="image.html#laue.utilities.image.images_to_iter">images_to_iter()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def images_to_iter(images):
    &#34;&#34;&#34;
    ** Converti les images en un generateur d&#39;images. **

    Parameters
    ----------
    images
        Ce qui representes les images. Que ce soit le nom
        d&#39;un dossier, d&#39;une image elle meme, une glob expression,
        une liste d&#39;image ou bien un generateur.
    &#34;&#34;&#34;
    if isinstance(images, str): # Dans le cas ou une chaine de caractere
        if os.path.isdir(images): # decrit l&#39;ensemble des images.
            images = sorted(
                os.path.join(father, file)
                for father, _, files in os.walk(images)
                for file in files)
        else:
            from glob import iglob
            images = sorted(iglob(images, recursive=True))
    elif isinstance(images, (tuple, set)):
        images = list(images)

    assert hasattr(images, &#34;__iter__&#34;), (&#34;&#39;images&#39; must to be iterable. &#34;
        f&#34;It can not be of type {type(images).__name__}.&#34;)

    return images</code></pre>
</details>
</dd>
<dt id="laue.utilities.limited_imap"><code class="name flex">
<span>def <span class="ident">limited_imap</span></span>(<span>pool, func, iterable, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.limited_imap" href="multi_core.html#laue.utilities.multi_core.limited_imap">limited_imap()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limited_imap(pool, func, iterable, **kwargs):
    &#34;&#34;&#34;
    ** Same as ``Pool.imap`` with limited buffer. **

    La fonction ``Pool.imap`` du module multiprocessing epuise
    tant qu&#39;elle peut l&#39;iterable d&#39;entree, et accumule les resultat
    dans une memoir tampon. Seulement, elle ne se preocupe
    pas de la memoire disponible ni des autres processus.
    Ici, les calcul sont fait en economisant les ressources
    disponible de facon a accroitre les peformances.

    Parameters
    ----------
    pool : multiprocessing.pool.Pool
        Pool de ``multiprocessing.Pool()``.
    func : callable
        La fonction serialisable avec pickle qui sera evaluee.
    iterable : iterable
        Cede sucessivement les argument a fournir a ``func``.
    **kwargs
        See ``multiprocessing.Pool().imap``.

    Yields
    ------
    result
        Cede peu a peu les resultats de la fonction ``func``.
    &#34;&#34;&#34;
    class Regulator:
        &#34;&#34;&#34;
        Permet de reguler le flot d&#39;un bloc.
        &#34;&#34;&#34;
        def __init__(self, pool, iterable):
            self.pool = pool
            self.iterable = iterable
            self.nbr_yields = 0 # Le nombre de resultats cedes.
            self.nbr_args = 0 # Le nombre d&#39;arguments pompes.
            self.max_tasks = 2*os.cpu_count() # Nombre de taches maximales en cours de calcul.

        def __iter__(self):
            &#34;&#34;&#34;
            Cede les arguments au compte gouttes.
            &#34;&#34;&#34;
            for args in self.iterable:
                while True: # Permet d&#39;attendre en cas de besoin.
                    buff_size = self.nbr_args - self.nbr_yields
                    if buff_size &lt; self.max_tasks:
                        break
                    if buff_size &gt; 10*self.max_tasks: # Si il y a suffisement de resultats en avance.
                        time.sleep(.1) # On fait une grande pause.
                        continue # Et on attend que ca se decante.
                    cpu = min(psutil.cpu_percent(interval=0.05, percpu=True))
                    mem = psutil.virtual_memory().percent
                    if cpu &lt; 50 and mem &lt; 75: # Si il y a suffisement de ressources.
                        break

                self.nbr_args += 1
                yield args

        def imap(self, func, **kwargs):
            &#34;&#34;&#34;
            Cede les resultats.
            &#34;&#34;&#34;
            for res in self.pool.imap(func, self, **kwargs):
                self.nbr_yields += 1
                yield res
    
    try:
        import psutil
    except ImportError:
        import logging
        logging.warn(&#34;&#39;psutil&#39; n&#39;est installer, il est impossible de &#34;
            &#34;gerer poprement les ressources.&#34;)
        psutil = None
    
    if psutil is None:
        yield from pool.imap(func, iterable, **kwargs)
    else:
        regulator = Regulator(pool, iterable)
        yield from regulator.imap(func, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.utilities.pickleable_method"><code class="name flex">
<span>def <span class="ident">pickleable_method</span></span>(<span>args, serialize=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.pickleable_method" href="multi_core.html#laue.utilities.multi_core.pickleable_method">pickleable_method()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pickleable_method(args, serialize=False):
    &#34;&#34;&#34;
    ** Permet de serialiser une methode. **

    Notes
    -----
    Comme l&#39;utilisateur ne doit pas utiliser cette fonction, il n&#39;y
    a pas de verifications sur les entree de facon a privilegier la performance.

    Parameters
    ----------
    args : tuple
        * args[0] =&gt; func, La fonction a executer. Si c&#39;est une methode, il est
        possible de fournir ``ClasseName.methode`` au lieu de ``self.methode``.
        * args[1] =&gt; self, Serialiser ou non, c&#39;est le premiers argument.
        * args[2] (facultativ) =&gt; kwargs, Le dictionaire des parametres nomes.
    serialize : bool
        Serialize le resultat (si True), sinon laisse implicitement
        pickle le faire (False). Si pickle est capable de le faire, il
        faut lui laisser gerer ca car c&#39;est plus efficace.
    &#34;&#34;&#34;
    if len(args) == 2:
        (func, self), kwargs = args, {}
    else:
        func, self, kwargs = args
    if isinstance(self, bytes):
        self = cloudpickle.loads(self)
    return (
                (lambda x: cloudpickle.dumps(x))
                if serialize else
                (lambda x: x)
            )(func(self, **kwargs))</code></pre>
</details>
</dd>
<dt id="laue.utilities.prevent_generator_size"><code class="name flex">
<span>def <span class="ident">prevent_generator_size</span></span>(<span>min_size=1, max_size=inf)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.prevent_generator_size" href="multi_core.html#laue.utilities.multi_core.prevent_generator_size">prevent_generator_size()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prevent_generator_size(min_size=1, max_size=math.inf):
    &#34;&#34;&#34;
    ** Controle que le generateur contient le bon nombre d&#39;elements. **

    C&#39;est un decorateur qui decore une fonction (generateur).

    Parameters
    ----------
    min_size : int
        Le nombre minimum d&#39;elements que doit ceder le generateur avant qu&#39;il ne soit epuise.
    max_size : int
        Le nombre maximum d&#39;elements cedes avant de lever l&#39;exception.

    Raises
    ------
    GeneratorExit
        Si les conditions ne sont pas respectees.
    &#34;&#34;&#34;
    assert isinstance(min_size, int), f&#34;&#39;min_size&#39; has to be int, not {type(min_size).__name__}.&#34;
    assert isinstance(max_size, int) or max_size == math.inf, \
        f&#34;&#39;max_size&#39; has to be int, not {type(max_size).__name__}.&#34;
    assert max_size &gt;= min_size, (&#34;&#39;max_size&#39; doit etre plus grand ou egal a &#39;min_size&#39;. &#34;
        f&#34;Or ils valent respectivement {max_size} et {min_size}.&#34;)
    assert min_size &gt;= 0, f&#34;&#39;min_size&#39; ne doit pas etre negatif ({min_size}).&#34;

    def decorator(func):
        def generator(*args, **kwargs):
            i = -1
            for i, element in enumerate(func(*args, **kwargs)):
                yield element
                if i &gt;= max_size:
                    raise GeneratorExit(f&#34;Le generateur {func} ne doit pas ceder plus de &#34;
                        f&#34;{max_size} elements. Or il tente d&#39;en ceder un {i+1}eme.&#34;)
            if i+1 &lt; min_size:
                raise GeneratorExit(f&#34;Le generateur {func} doit ceder au moins {min_size} &#34;
                    f&#34;elements. Or il n&#39;en a cede que {i+1}.&#34;)

        return generator
    return decorator</code></pre>
</details>
</dd>
<dt id="laue.utilities.read_image"><code class="name flex">
<span>def <span class="ident">read_image</span></span>(<span>image_path, *, ignore_errors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.image.read_image" href="image.html#laue.utilities.image.read_image">read_image()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_image(image_path, *, ignore_errors=False):
    &#34;&#34;&#34;
    ** Lit une image sur le disque dur. **

    Parameters
    ----------
    image_path : str
        Nom de l&#39;image, chemin absolu ou relatif, peu importe.
    ignore_errors : boolean
        Same as ``laue.experiment.base_experiment.Experiment.__init__``.
        Permet de renvoyer ``None`` plutot que de lever une exeption.

    Returns
    -------
    np.ndarray
        L&#39;image en niveau de gris encodee en uint16.

    Raises
    ------
    FileNotFoundError
        Si l&#39;image n&#39;existe pas.
    ImportError
        Si il manque un module pour lire l&#39;image.
    ValueError
        Si le fichier n&#39;est pas lisible.

    Example
    -------
    &gt;&gt;&gt; from laue.utilities.image import read_image
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; read_image(image)
    array([[0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           ...,
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
    &gt;&gt;&gt; read_image(image).shape
    (2048, 2048)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(image_path, (str, bytes)), \
        f&#34;&#39;image_path&#39; has to be str or byte-like object. Not {type(image_path).__name__}.&#34;

    if not os.path.exists(image_path):
        message = f&#34;{repr(image_path)} n&#39;est pas un chemin existant.&#34;
        if not ignore_errors:
            raise FileNotFoundError(message)
        logging.warning(message)
        return None
    if not os.path.isfile(image_path):
        message = f&#34;{repr(image_path)} n&#39;est pas un fichier.&#34;
        if not ignore_errors:
            raise FileNotFoundError(message)
        logging.warning(message)
        return None
    image = cv2.imread(image_path, cv2.IMREAD_ANYDEPTH | cv2.IMREAD_GRAYSCALE)
    if image is None:
        try:
            import fabio # Pour lire les fichier .mccd
        except ImportError as err:
            raise ImportError(&#34;Pour lire les fichier &#39;.mccd&#39; ou &#39;.gz&#39;, &#34;
                &#34;il faut installer le module &#39;fabio&#39;.&#34;) from err
        try:
            image = fabio.open(image_path).data
        except (KeyError, OSError) as err:
            message = f&#34;Echec de lecture du fichier {repr(image_path)} comme une image.&#34;
            if not ignore_errors:
                raise ValueError(message) from err
            logging.warning(message)
            return None
    image = image.astype(np.uint16)
    return image</code></pre>
</details>
</dd>
<dt id="laue.utilities.reduce_object"><code class="name flex">
<span>def <span class="ident">reduce_object</span></span>(<span>obj, attrs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.reduce_object" href="multi_core.html#laue.utilities.multi_core.reduce_object">reduce_object()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_object(obj, attrs=None):
    &#34;&#34;&#34;
    ** Reconstitue un objet partiel. **

    Le but est de rendre un objet plus facilement serialisable et
    aussi de l&#39;alleger pour perdre moins de temps avec la
    serialisation puis la deserialisation.

    Parameters
    ----------
    obj : objet
        Instance de la classe que l&#39;on shouaite reduire.
    attrs : iterable
        Les noms des attributs qui resteront presents dans l&#39;objet final.
        Si il ne sont pas precise, seul les attributs serialisables sont gardes.

    Examples
    --------
    &gt;&gt;&gt; from laue.utilities.multi_core import reduce_object
    &gt;&gt;&gt;
    &gt;&gt;&gt; class Foo:
    ...     def __init__(self):
    ...         self.attr1 = 1
    ...         self.attr2 = 2
    ...     def meth(self):
    ...         pass
    ...
    &gt;&gt;&gt; obj = Foo()
    &gt;&gt;&gt;
    &gt;&gt;&gt; little_obj = reduce_object(obj, [&#34;attr1&#34;])
    &gt;&gt;&gt; hasattr(little_obj, &#34;attr1&#34;)
    True
    &gt;&gt;&gt; hasattr(little_obj, &#34;attr2&#34;)
    False
    &gt;&gt;&gt; hasattr(little_obj, &#34;meth&#34;)
    True
    &gt;&gt;&gt; little_obj.attr1
    1
    &gt;&gt;&gt; type(little_obj.meth)
    &lt;class &#39;method&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    class Partial(type(obj)):
        def __init__(self):
            pass

    if attrs is None:
        all_attrs = [attr for attr in dir(obj)
            if type(getattr(obj, attr)).__name__ != &#34;method&#34;
            and not attr.startswith(&#34;__&#34;)]
        attrs = []
        for attr in all_attrs:
            try:
                cloudpickle.dumps(getattr(obj, attr))
            except (TypeError, RuntimeError):
                continue
            else:
                attrs.append(attr)
        print(attrs)

    partial_obj = Partial()
    for attr in attrs:
        setattr(partial_obj, attr, getattr(obj, attr))
    return partial_obj

    # class Constructor:
    #     &#34;&#34;&#34;
    #     Methaclasse qui fabrique de nouvelle instances sur mesure.
    #     &#34;&#34;&#34;
    #     def __new__(cls, obj, attrs):
    #         name = f&#34;Partial{type(obj).__name__}&#34;
            
    #         # Separation des attributs et des methodes.
    #         meth_name = {attr for attr in attrs if type(getattr(obj, attr)).__name__ == &#34;method&#34;}
    #         attrs = set(attrs) - meth_name
            
    #         # Creation d&#39;un objet ayant que les methodes.
    #         empty_obj = NoAttrs()
    #         # for attr in attrs:
    #         #     setattr(emty_obj, attr, getattr(obj, attr))
    #         methodes = {name: getattr(empty_obj, name) for name in meth_name}

    #         # Ajout des attributs.
    #         partial_obj = type(name, (), methodes)
    #         for attr in attrs:
    #             setattr(partial_obj, attr, getattr(obj, attr))
    #         return partial_obj

    # return Constructor(obj, attrs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laue.utilities.Lambdify"><code class="flex name class">
<span>class <span class="ident">Lambdify</span></span>
<span>(</span><span>args, expr, *, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.lambdify.Lambdify" href="lambdify.html#laue.utilities.lambdify.Lambdify">Lambdify</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lambdify:
    &#34;&#34;&#34;
    ** Permet de manipuler plus simplement une fonction. **
    &#34;&#34;&#34;
    def __init__(self, args, expr, *, verbose=False, _simp_expr=None):
        &#34;&#34;&#34;
        ** Prepare la fonction. **

        Parameters
        ----------
        args : iterable
            Les parametres d&#39;entre de la fonction.
        expr : sympy.core
            L&#39;expresion sympy a vectoriser.
        &#34;&#34;&#34;
        # Preparation symbolique.
        self.args = [arg for arg in sympy.sympify(args)]
        self.args_name = [str(arg) for arg in self.args]
        self.args_position = {arg: i for i, arg in enumerate(self.args_name)}
        self.expr = expr
        self.verbose = verbose

        # Preparation vectoriele.
        self._simp_expr = _simp_expr
        if self._simp_expr is None:
            self._simp_expr = simplify(self.expr, measure=TimeCost(), verbose=verbose)
        self.fct = lambdify(self.args, self._simp_expr, cse=True, modules=&#34;numpy&#34;)
        try:
            self.fct_numexpr = lambdify(self.args, evalf(self._simp_expr, n=15), cse=True, modules=&#34;numexpr&#34;)
        except (ImportError, TypeError, RuntimeError):
            self.fct_numexpr = None

    def __str__(self, *, name=&#34;lambdifygenerated&#34;, bloc=&#34;numpy&#34;):
        &#39;&#39;&#39;
        ** Offre une representation explicite de la fonction. **

        Parameters
        ----------
        name : str
            Le nom a donner a la fonction.
        bloc : str
            La partie du code a impromer. Permet de selectionner la fonction.

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos, pi
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; print(Lambdify([x, y], pi*cos(x + y) + x + y), end=&#34;&#34;)
        def _lambdifygenerated_numpy(x, y):
            &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;
            x0 = x + y
            _0 = x0 + 3.14159265358979*cos(x0)
            return _0
        &gt;&gt;&gt;
        &#39;&#39;&#39;
        assert isinstance(name, str), f&#34;&#39;name&#39; has to be str, not {type(name).__name__}.&#34;
        assert bloc in {&#34;main&#34;, &#34;numpy&#34;, &#34;numpy128&#34;, &#34;numexpr&#34;, &#34;sympy&#34;}
        import re

        # Code numexpr.
        if bloc == &#34;numexpr&#34;:
            if self.fct_numexpr is not None:
                code = self.fct_numexpr.__doc__.split(&#34;\n&#34;)
                code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numexpr&#34;)
                code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float64 using the numexpr module.&#34;&#34;&#34;&#39;)
            else:
                code = []

        # Code &lt; float 64
        elif bloc == &#34;numpy&#34;:
            code = lambdify(self.args, evalf(self._simp_expr),
                cse=True, modules=&#34;numpy&#34;).__doc__.split(&#34;\n&#34;)
            code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy&#34;)
            code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;&#39;)

        # Code float 128
        elif bloc == &#34;numpy128&#34;:
            f_mod = re.compile(r&#34;&#34;&#34;(?:[+-]*
                (?:
                  \. [0-9]+ (?:_[0-9]+)*
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)* \. (?: [0-9]+ (?:_[0-9]+)* )?
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)*
                  e [+-]? [0-9]+ (?:_[0-9]+)*
                ))&#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE) # Model d&#39;un flottant.
            code_str = self.fct.__doc__
            code_str = re.sub(f_mod,
                lambda m: (f&#34;float128({repr(m.group())})&#34; if len(m.group()) &gt;= 15 else m.group()),
                code_str)
            code = code_str.split(&#34;\n&#34;)
            code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy128&#34;)
            code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float128 using the numpy module.&#34;&#34;&#34;&#39;)

        # Expression formelle
        elif bloc == &#34;sympy&#34;:
            defs, rvs = cse_homogeneous(self.expr)
            code = []
            code.append(f&#34;def _{name}_sympy():&#34;)
            code.append( &#39;    &#34;&#34;&#34;Returns the tree of the sympy expression.&#34;&#34;&#34;&#39;)
            code.append(f&#34;    {&#39;, &#39;.join(self.args_name)} = symbols(&#39;{&#39; &#39;.join(self.args_name)}&#39;)&#34;)
            for var, expr in defs:
                code.append(f&#34;    {var} = {expr}&#34;)
            code.append(f&#34;    return {rvs}&#34;)
            code.append( &#34;&#34;)

        # Fonction principale Equivalent as self.__call__.
        elif bloc == &#34;main&#34;:
            code = []
            code.append(f&#34;def {name}(*args, **kwargs):&#34;)
            code.append( &#39;    &#34;&#34;&#34;&#39;)
            code.append( &#34;    ** Choose the most suitable function according to&#34;)
            code.append( &#34;    the type and size of the input data. **&#34;)
            code.append( &#34;&#34;)
            code.append( &#34;    Parameters&#34;)
            code.append( &#34;    ----------&#34;)
            code.append( &#34;    *args&#34;)
            code.append( &#34;        Les parametres ordonnes de la fonction.&#34;)
            code.append( &#34;    **kwargs&#34;)
            code.append( &#34;        Les parametres nomes de la fonction. Ils&#34;)
            code.append( &#34;        ont le dessus sur les args en cas d&#39;ambiguite.&#34;)
            code.append( &#39;    &#34;&#34;&#34;&#39;)

            code.append( &#34;    assert len(args) &lt;= %d, f&#39;The function cannot take {len(args)} arguments.&#39;&#34;
                                                % len(self.args))
            code.append( &#34;    assert not set(kwargs) - {%s}, f&#39;You cannot provide {kwargs}.&#39;&#34;
                                                      % &#34;, &#34;.join(repr(a) for a in self.args_name))
            code.append( &#34;    if not args and not kwargs:&#34;)
            code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
            code.append(f&#34;        return _{name}_sympy()&#34;)

            code.append( &#34;    args = list(args)&#34;)
            code.append(f&#34;    if len(args) &lt; {len(self.args)}:&#34;)
            code.append(f&#34;        args += sympy.symbols(&#39; &#39;.join({self.args_name}[len(args):]))&#34;)
            code.append( &#34;    if kwargs:&#34;)
            code.append( &#34;        for arg, value in kwargs.items():&#34;)
            code.append(f&#34;            args[{self.args_position}[arg]] = value&#34;)

            code.append( &#34;    if any(isinstance(a, sympy.Basic) for a in args):&#34;)
            code.append( &#34;        sub = {arg: value for arg, value in zip(%s, args)}&#34; % self.args_name)
            code.append( &#34;        from laue.utilities.lambdify import subs&#34;)
            code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
            code.append(f&#34;        return subs(_{name}_sympy(), sub)&#34;)

            if hasattr(np, &#34;float128&#34;):
                code.append( &#34;    if any(a.dtype == np.float128 for a in args if isinstance(a, np.ndarray)):&#34;)
                code.append(f&#34;        from laue.data.numpy128_lambdify import _{name}_numpy128&#34;)
                code.append(f&#34;        return _{name}_numpy128(*args)&#34;)
            if self.fct_numexpr is not None:
                code.append( &#34;    if (&#34;)
                code.append( &#34;            (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)&#34;)
                code.append( &#34;            and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))&#34;)
                code.append( &#34;        ):&#34;)
                code.append(f&#34;        from laue.data.numexpr_lambdify import _{name}_numexpr&#34;)
                code.append(f&#34;        return _{name}_numexpr(*args)&#34;)
            code.append(f&#34;    from laue.data.numpy_lambdify import _{name}_numpy&#34;)
            code.append(f&#34;    return _{name}_numpy(*args)&#34;)
            code.append( &#34;&#34;)

        else:
            raise KeyError

        return &#34;\n&#34;.join(code)

    def __repr__(self):
        &#34;&#34;&#34;
        ** Offre une representation evaluable de l&#39;objet. **

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return f&#34;Lambdify([{&#39;, &#39;.join(self.args_name)}], {self.expr})&#34;

    def __call__(self, *args, **kwargs):
        &#34;&#34;&#34;
        ** Evalue la fonction. **

        Parameters
        ----------
        *args
            Les parametres ordonnes de la fonction.
        **kwargs
            Les parametres nomes de la fonction. Ils
            ont le dessus sur les args en cas d&#39;ambiguite.

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt; l = Lambdify([x, y], x + y + cos(x + y))

        Les cas symboliques.
        &gt;&gt;&gt; l() # Retourne l&#39;expression sympy.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(x) # Complete la suite en rajoutant &#39;y&#39;.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(y) # Complete aussi en rajoutant &#39;y&#39;.
        2*y + cos(2*y)
        &gt;&gt;&gt; l(x, y) # Retourne une copie de l&#39;expression sympy.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(1, y=2*y) # Il est possible de faire un melange symbolique / numerique.
        2*y + cos(2*y + 1) + 1
        &gt;&gt;&gt;

        Les cas purement numeriques.
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; l(-1, 1)
        1.0
        &gt;&gt;&gt; l(x=-1, y=1)
        1.0
        &gt;&gt;&gt; np.round(l(0, np.linspace(-1, 1, 5)), 2)
        array([-0.46,  0.38,  1.  ,  1.38,  1.54])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # Cas patologiques.
        if not args and not kwargs:
            return self.expr
        if len(args) &gt; len(self.args):
            raise IndexError(f&#34;La fonction ne prend que {len(self.args)} arguments. &#34;
                f&#34;Or vous en avez fournis {len(args)}.&#34;)
        
        # Recuperation des arguments complets.
        args = list(args)
        args += self.args[len(args):]
        if kwargs:
            if set(kwargs) - set(self.args_position):
                raise NameError(f&#34;Les parametres {set(kwargs) - set(self.args_position)} &#34;
                    f&#34;ne sont pas admissible, seul {set(self.args_position)} sont admissibles.&#34;)
            for arg, value in kwargs.items():
                args[self.args_position[arg]] = value

        # Cas symbolique.
        if any(isinstance(a, sympy.Basic) for a in args):
            sub = {arg: value for arg, value in zip(self.args, args)}
            return subs(self.expr, sub)

        # Cas numerique.
        if (
                (self.fct_numexpr is not None)
                and (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)
                and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))
            ):
            return self.fct_numexpr(*args)
        return self.fct(*args)

    def __getstate__(self):
        &#34;&#34;&#34;
        ** Extrait l&#39;information serialisable. **

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; l = Lambdify([x, y], cos(x + y) + x + y)
        &gt;&gt;&gt; l.__getstate__()
        ([x, y], x + y + cos(x + y), False)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.expr == self._simp_expr:
            return (self.args, self.expr, self.verbose)
        return (self.args, self.expr, self.verbose, self._simp_expr)

    def __setstate__(self, state):
        &#34;&#34;&#34;
        ** Instancie l&#39;objet a partir de l&#39;etat. **

        Examples
        --------
        &gt;&gt;&gt; import pickle
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt; pickle.loads(pickle.dumps(_))
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if len(state) == 4:
            self.__init__(state[0], state[1], verbose=state[2], _simp_expr=state[3])
        else:
            self.__init__(state[0], state[1], verbose=state[2])</code></pre>
</details>
</dd>
<dt id="laue.utilities.NestablePool"><code class="flex name class">
<span>class <span class="ident">NestablePool</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.NestablePool" href="multi_core.html#laue.utilities.multi_core.NestablePool">NestablePool</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NestablePool(multiprocessing.pool.Pool):
    &#34;&#34;&#34;Permet de faire des pool de pool.&#34;&#34;&#34;
    def __init__(self, *args, **kwargs):
        kwargs[&#34;context&#34;] = NoDaemonContext()
        super(NestablePool, self).__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>multiprocessing.pool.Pool</li>
</ul>
</dd>
<dt id="laue.utilities.RecallingIterator"><code class="flex name class">
<span>class <span class="ident">RecallingIterator</span></span>
<span>(</span><span>base_iterator, *, mother=None, buff_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.RecallingIterator" href="multi_core.html#laue.utilities.multi_core.RecallingIterator">RecallingIterator</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecallingIterator:
    &#34;&#34;&#34;
    ** Permet d&#39;iterer plusieurs instances d&#39;un unique generateur. **

    Examples
    --------
    Example avec une classe.
    &gt;&gt;&gt; from laue.utilities.multi_core import RecallingIterator
    &gt;&gt;&gt;
    &gt;&gt;&gt; class Foo:
    ...     def __init__(self):
    ...         self.it = iter(range(5))
    ...     def __iter__(self):
    ...         yield from RecallingIterator(self.it, mother=self)
    ...
    &gt;&gt;&gt; foo = Foo()
    &gt;&gt;&gt; for a, b in zip(foo, foo):
    ...     a, b
    ... 
    (0, 0)
    (1, 1)
    (2, 2)
    (3, 3)
    (4, 4)
    &gt;&gt;&gt; list(foo)
    [0, 1, 2, 3, 4]
    &gt;&gt;&gt;

    Example sans classe
    &gt;&gt;&gt; it = iter(range(5))
    &gt;&gt;&gt; for a, b in zip(RecallingIterator(it), RecallingIterator(it)):
    ...     a, b
    ... 
    (0, 0)
    (1, 1)
    (2, 2)
    (3, 3)
    (4, 4)
    &gt;&gt;&gt; list(RecallingIterator(it))
    [0, 1, 2, 3, 4]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def __init__(self, base_iterator, *, mother=None, buff_name=None):
        &#34;&#34;&#34;
        Paremeters
        ----------
        base_iterator : iterator
            L&#39;iterateur epuisable, qui ne doit en tout et pour tout
            etre parcouru qu&#39;une seule fois.
        mother : object (optional)
            Instance de la classe dans laquelle on met cet iterateur.
            Si il est omis, la memoire est globale et ne sera pas netoyee
            par le ramasse-miette. Il est conseille si possible fournir &#39;mother&#39;.
        buff_name : str (optional)
            Si il est precise, c&#39;est le nom de la variable du buffer.
        &#34;&#34;&#34;
        self.mother = mother
        self.base_iterator = base_iterator
        signature = hashlib.md5(id(base_iterator).to_bytes(16, &#34;big&#34;)).hexdigest()

        self.stape = 0 # Le rang de l&#39;element suivant a ceder.

        # Mise en place du verrou.
        lock_name = f&#34;_lock_{signature}&#34;
        if self.mother is not None:
            if not hasattr(self.mother, lock_name):
                setattr(self.mother, lock_name, multiprocessing.Lock())
            self.lock = getattr(self.mother, lock_name)
        else:
            if lock_name not in globals():
                globals()[lock_name] = multiprocessing.Lock()
            self.lock = globals()[lock_name]

        # Mise en place de la memoire pour reiterer.
        buffer_name = f&#34;_buffer_recalling_{signature}&#34; if buff_name is None else buff_name
        if self.mother is not None:
            if not hasattr(self.mother, buffer_name):
                setattr(self.mother, buffer_name, [])
            self.buffer = getattr(self.mother, buffer_name)
        else:
            if buffer_name not in globals():
                globals()[buffer_name] = []
            self.buffer = globals()[buffer_name]

    def __iter__(self):
        &#34;&#34;&#34;
        ** Permet d&#39;etre mis dans une boucle for. **
        &#34;&#34;&#34;
        return self

    def __next__(self):
        &#34;&#34;&#34;
        ** Itere de facon intrementale. **

        Raises
        ------
        StopIteration
            Quand tous les paquets sont cedes.
        &#34;&#34;&#34;
        with self.lock:
            # Si il ne faut pas iterer &#39;base_iterator&#39;
            if self.stape &lt; len(self.buffer):
                self.stape += 1
                return self.buffer[self.stape-1]

            # Si il faut iterer.
            while True:
                try:
                    element = next(self.base_iterator)
                except ValueError: # precisement: generator already executing
                    time.sleep(.1) # On attend 100 ms avant de retenter.
                else:
                    self.buffer.append(element)
                    self.stape += 1
                    return element</code></pre>
</details>
</dd>
<dt id="laue.utilities.Recordable"><code class="flex name class">
<span>class <span class="ident">Recordable</span></span>
<span>(</span><span>saving_file='experiment_state', compress=False, dt=600, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.data_consistency.Recordable" href="data_consistency.html#laue.utilities.data_consistency.Recordable">Recordable</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Recordable(threading.Thread):
    &#34;&#34;&#34;
    ** Interface asynchrone gerant la persistance des donnees. **
    &#34;&#34;&#34;
    def __init__(self, saving_file=&#34;experiment_state&#34;, compress=False, dt=600, **_kwargs):
        &#34;&#34;&#34;
        ** Initialise le gestionaire d&#39;enregistrement. **

        Dans le cas ou l&#39;etat de l&#39;ancienne session de travail
        est fournis en parametre, les element de la nouvelle experience
        sont mis a jour.

        Parameters
        ----------
        saving_file : str
            Le path du fichier dans lequel sera enregistre l&#39;etat de l&#39;experience.
        compress : boolean
            Si True, compresse les donnees avec l&#39;algorithme gzip. Cela utilise
            plus de CPU mais reduit un peu la taille des donnees a ecrire.
        dt : number
            Le temps qui separe 2 enregistrements (en secondes).
        &#34;&#34;&#34;
        assert isinstance(saving_file, str), f&#34;&#39;file&#39; has to be of type str, not {type(saving_file).__name__}.&#34;
        assert isinstance(compress, bool), \
            f&#34;&#39;compress&#39; has to be of type bool, not {type(compress).__name__}.&#34;
        assert isinstance(dt, numbers.Number), f&#34;&#39;dt&#39; has to be a number, not a {type(dt).__name__}.&#34;
        assert dt &gt; 0, f&#34;Le temps vaut {dt}.&#34;

        self.saving_file = saving_file
        self.compress = compress
        self.dt = dt

        self._must_die = False

        threading.Thread.__init__(self)

        if os.path.exists(self.saving_file):
            self._load()

    def __enter__(self):
        &#34;&#34;&#34;
        ** Gestionaire de contexte. **

        Demarre l&#39;activite du thread.

        Examples
        --------
        &gt;&gt;&gt; import os, tempfile
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; saving_file = os.path.join(tempfile.mkdtemp(), &#34;state&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; with laue.experiment.base_experiment.Experiment(image, saving_file=saving_file, verbose=2) as experiment:
        ...     pass
        ...
        Starting the thread.
        The thread says: I was just born.
        Sends the thread the order to succumb...
        Recording of the current status...
            OK: the state of the experiment is recorded.
        The thread says: Oh help! I&#39;m dying!
            the thread is killed.
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        self.start()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.kill()

    def __del__(self):
        try:
            if self.is_alive():
                self.kill()
        except AssertionError:
            pass

    def kill(self):
        &#34;&#34;&#34;
        ** Stop the thread activity. **
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Sends the thread the order to succumb...&#34;)
        self._must_die = True
        while self.is_alive():
            time.sleep(.1)
        if self.verbose:
            print(&#34;    the thread is killed.&#34;)

    def run(self):
        &#34;&#34;&#34;
        ** Enregistre indefiniment l&#39;etat de l&#39;experience. **

        Cette methode ne doit pas etre appelee directement car elle
        est bloquante. Pour l&#39;executer en tache de fond il faut invoquer
        ``laue.utilities.data_consistency.Recordable.start``. Ou bien
        l&#39;instanceier via un gestionaire de contexte.
        &#34;&#34;&#34;
        def pause(dt):
            ti = time.time()
            while not self._must_die and time.time() - ti &lt; dt:
                time.sleep(0.01)

        if self.verbose &gt;= 2:
            print(&#34;The thread says: I was just born.&#34;)

        while not self._must_die:
            pause(self.dt)
            self.save_state()

        if self.verbose &gt;= 2:
            print(&#34;The thread says: Oh help! I&#39;m dying!&#34;)

    def start(self):
        &#34;&#34;&#34;
        ** Demarre l&#39;activite du thread. **

        Elle doit etre appelee au maximum une fois par objet thread.
        Elle fait en sorte que la methode run()
        de l&#39;objet soit invoquee dans un thread de controle separe.

        Cette methode declenchera une RuntimeError si elle
        est appelee plus d&#39;une fois sur le meme objet thread.
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Starting the thread.&#34;)
        super().start()

    def _load(self):
        &#34;&#34;&#34;
        ** Met a jour l&#39;etat de l&#39;experience a partir du fichier. **
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Updating the current state...&#34;)
        with open(self.saving_file, &#34;rb&#34;) as f:
            compress = f.read(1)
            if compress == b&#34;\x00&#34;:
                state = pickle.load(f)
            elif compress == b&#34;\x01&#34;:
                from gzip import decompress
                state = pickle.loads(decompress(f.read()))
            else:
                raise ValueError(r&#34;Le fichier doit commencer par b&#39;\x00&#39; ou b&#39;\x01&#39;.&#34;
                    f&#34;Or il commence par {compress}.&#34;)
        self.__setstate__(state)
        if self.verbose:
            print(&#34;    OK: the attributes are updated&#34;)

    def save_state(self):
        &#34;&#34;&#34;
        ** Enregistre l&#39;etat courant. **
        &#34;&#34;&#34;
        if self.verbose &gt;= 2:
            print(&#34;Recording of the current status...&#34;)
        state = self.__getstate__()
        with open(self.saving_file, &#34;wb&#34;) as f:
            if self.compress:
                from gzip import compress
                f.write(b&#34;\x01&#34;)
                f.write(compress(pickle.dumps(state)))
            else:
                f.write(b&#34;\x00&#34;)
                pickle.dump(state, f)
        if self.verbose &gt;= 2:
            print(&#34;    OK: the state of the experiment is recorded.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="laue.experiment.base_experiment.Experiment" href="../experiment/base_experiment.html#laue.experiment.base_experiment.Experiment">Experiment</a></li>
</ul>
</dd>
<dt id="laue.utilities.TimeCost"><code class="flex name class">
<span>class <span class="ident">TimeCost</span></span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.lambdify.TimeCost" href="lambdify.html#laue.utilities.lambdify.TimeCost">TimeCost</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeCost:
    &#34;&#34;&#34;
    ** Estime le cout d&#39;une expression. **
    &#34;&#34;&#34;
    def __init__(self):
        self.costs = {}

        self._zero = np.zeros(shape=(1000, 1000))
        self._one = np.ones(shape=(1000, 1000))
        self._false = self._zero.astype(bool)
        self._true = self._one.astype(bool)
        self._negone = -self._one
        self._two = 2.0*self._one
        self._bat = .32267452*self._one
        self._comp = (1.0 + 1.0j)*self._one

        self._tests = {
            &#34;Abs&#34;: (lambda: np.abs(self._negone)),
            &#34;Add&#34;: (lambda: self._bat + self._bat),
            &#34;And&#34;: (lambda: self._true &amp; self._true),
            &#34;BooleanTrue&#34;: (lambda: self._one.astype(bool)),
            &#34;Equality&#34;: (lambda: self._bat == self._bat),
            &#34;GreaterThan&#34;: (lambda: self._one &gt;= self._one),
            &#34;LessThan&#34;: (lambda: self._one &lt;= self._one),
            &#34;MatAdd&#34;: (lambda: self._bat + self._bat),
            &#34;MatMul&#34;: (lambda: self._bat @ self._bat),
            &#34;MatPow&#34;: (lambda: self._bat ** self._bat),
            &#34;Max&#34;: (lambda: np.max(self._one)),
            &#34;Min&#34;: (lambda: np.min(self._one)),
            &#34;Mod&#34;: (lambda: self._one % self._bat),
            &#34;Mul&#34;: (lambda: self._bat * self._bat),
            &#34;Nand&#34;: (lambda: not np.all(self._true)),
            &#34;Nor&#34;: (lambda: not np.any(self._false)),
            &#34;Not&#34;: (lambda: ~ self._true),
            &#34;Or&#34;: (lambda: self._false | self._false),
            &#34;Piecewise&#34;: (lambda: ... if True else ...),
            &#34;Pow&#34;: (lambda: self._two ** self._bat),
            &#34;StrictGreaterThan&#34;: (lambda: self._one &gt; self._one),
            &#34;StrictLessThan&#34;: (lambda: self._one &lt; self._one),
            &#34;Transpose&#34;: (lambda: np.transpose(self._zero)),
            &#34;Unequality&#34;: (lambda: self._bat != self._bat),
            &#34;Xor&#34;: (lambda: (self._false|self._true) &amp; ~(self._false&amp;self._true)),
            &#34;acos&#34;: (lambda: np.arccos(self._bat)),
            &#34;acosh&#34;: (lambda: np.arccosh(self._two)),
            &#34;arg&#34;: (lambda: np.angle(self._comp)),
            &#34;asin&#34;: (lambda: np.arcsin(self._bat)),
            &#34;asinh&#34;: (lambda: np.arcsinh(self._bat)),
            &#34;atan&#34;: (lambda: np.arctan(self._bat)),
            &#34;atan2&#34;: (lambda: np.arctan2(self._bat, self._one)),
            &#34;atanh&#34;: (lambda: np.arctanh(self._bat)),
            &#34;conjugate&#34;: (lambda: np.conjugate(self._comp)),
            &#34;cos&#34;: (lambda: np.cos(self._bat)),
            &#34;cosh&#34;: (lambda: np.cosh(self._bat)),
            &#34;exp&#34;: (lambda: np.exp(self._bat)),
            &#34;im&#34;: (lambda: np.imag(self._comp)),
            &#34;log&#34;: (lambda: np.log(self._bat)),
            &#34;re&#34;: (lambda: np.real(self._comp)),
            &#34;sign&#34;: (lambda: np.sign(self._bat)),
            &#34;sin&#34;: (lambda: np.sin(self._bat)),
            &#34;sinc&#34;: (lambda: np.sinc(self._bat)),
            &#34;sinh&#34;: (lambda: np.sinh(self._bat)),
            &#34;sqrt&#34;: (lambda: np.sqrt(self._bat)),
            &#34;tan&#34;: (lambda: np.tan(self._bat)),
            &#34;tanh&#34;: (lambda: np.tanh(self._bat)),
            &#34;eval&#34;: (lambda: np.float64(&#34;0.123456789e+01&#34;)),
            &#34;aloc&#34;: (lambda: np.zeros(shape=(1000, 1000))),
            &#34;div&#34;: (lambda: 1/self._bat),
            &#34;**2&#34;: (lambda: self._bat**2),
        }

        self.load_save()

    def load_save(self):
        &#34;&#34;&#34;
        Charge le fichier qui contient les resultats.
        &#34;&#34;&#34;
        dirname = os.path.join(os.path.dirname(os.path.abspath(laue.__file__)), &#34;data&#34;)
        file = os.path.join(dirname, &#34;timecost.pickle&#34;)
        if os.path.exists(file):
            with open(file, &#34;rb&#34;) as f:
                self.__setstate__(pickle.load(f))
        else:
            with open(file, &#34;wb&#34;) as f:
                pickle.dump(self.__getstate__(), f)

    def atom_cost(self, key):
        &#34;&#34;&#34;
        Retourne le cout de l&#39;opperateur.
        &#34;&#34;&#34;
        if key in self.costs:
            return self.costs[key]
        if hasattr(self, &#34;_tests&#34;):
            if key in self._tests:
                self.costs[key] = timeit.timeit(self._tests[key], number=100)
                return self.costs[key]
        raise ValueError(f&#34;L&#39;opperation {key} est inconnue.&#34;)

    def branch_cost(self, branch):
        &#34;&#34;&#34;
        Le cout brut de l&#39;expression sympy sans cse.
        &#34;&#34;&#34;
        if isinstance(branch, (sympy.Atom, numbers.Number)):
            return self.atom_cost(&#34;eval&#34;)

        if isinstance(branch, (sympy.Add, sympy.And, sympy.MatAdd, sympy.MatMul,
                sympy.MatPow, sympy.Mul, sympy.Nand, sympy.Nor, sympy.Or, sympy.Xor)):
            op_cost = self.atom_cost(type(branch).__name__) * (len(branch.args)-1)
            return sum((self.branch_cost(e) for e in branch.args)) + op_cost

        if isinstance(branch, sympy.Pow):
            if isinstance(branch.exp, sympy.Number):
                if branch.exp == 2:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;**2&#34;)
                if branch.exp == sympy.S.Half:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;sqrt&#34;)
                if branch.exp == -sympy.S.Half:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;sqrt&#34;)
                if branch.exp == -sympy.S.One:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;)
                if branch.exp == -2:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;**2&#34;)
            return self.branch_cost(branch.base) + self.branch_cost(branch.exp) + self.atom_cost(&#34;Pow&#34;)

        if isinstance(branch, sympy.Piecewise):
            op_cost = self.atom_cost(&#34;Piecewise&#34;) * (len(branch.args)-1)
            return sum(
                self.branch_cost(val) + sum(self.branch_cost(a) for a in cond.args)
                for val, cond in branch.args) + op_cost

        return sum((self.branch_cost(e) for e in branch.args)) + self.atom_cost(type(branch).__name__)

    def __call__(self, expr):
        &#34;&#34;&#34;
        Le cout de l&#39;expression avec cse.
        &#34;&#34;&#34;
        defs, rvs = sympy.cse(expr)
        return (sum(self.branch_cost(e) for var, e in defs)
              + sum(self.branch_cost(e) for e in rvs)
              + len(defs)*self.atom_cost(&#34;aloc&#34;))

    def __getstate__(self):
        if hasattr(self, &#34;_tests&#34;):
            for key in self._tests:
                self.atom_cost(key)
        return self.costs

    def __setstate__(self, state):
        self.costs = state</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#outils-en-tout-genre">Outils en tout genre.</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="laue" href="../index.html">laue</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="laue.utilities.data_consistency" href="data_consistency.html">laue.utilities.data_consistency</a></code></li>
<li><code><a title="laue.utilities.fork_lambdify" href="fork_lambdify.html">laue.utilities.fork_lambdify</a></code></li>
<li><code><a title="laue.utilities.image" href="image.html">laue.utilities.image</a></code></li>
<li><code><a title="laue.utilities.lambdify" href="lambdify.html">laue.utilities.lambdify</a></code></li>
<li><code><a title="laue.utilities.multi_core" href="multi_core.html">laue.utilities.multi_core</a></code></li>
<li><code><a title="laue.utilities.parsing" href="parsing.html">laue.utilities.parsing</a></code></li>
<li><code><a title="laue.utilities.serialization" href="serialization.html">laue.utilities.serialization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laue.utilities.create_image" href="#laue.utilities.create_image">create_image</a></code></li>
<li><code><a title="laue.utilities.extract_parameters" href="#laue.utilities.extract_parameters">extract_parameters</a></code></li>
<li><code><a title="laue.utilities.images_to_iter" href="#laue.utilities.images_to_iter">images_to_iter</a></code></li>
<li><code><a title="laue.utilities.limited_imap" href="#laue.utilities.limited_imap">limited_imap</a></code></li>
<li><code><a title="laue.utilities.pickleable_method" href="#laue.utilities.pickleable_method">pickleable_method</a></code></li>
<li><code><a title="laue.utilities.prevent_generator_size" href="#laue.utilities.prevent_generator_size">prevent_generator_size</a></code></li>
<li><code><a title="laue.utilities.read_image" href="#laue.utilities.read_image">read_image</a></code></li>
<li><code><a title="laue.utilities.reduce_object" href="#laue.utilities.reduce_object">reduce_object</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laue.utilities.Lambdify" href="#laue.utilities.Lambdify">Lambdify</a></code></h4>
</li>
<li>
<h4><code><a title="laue.utilities.NestablePool" href="#laue.utilities.NestablePool">NestablePool</a></code></h4>
</li>
<li>
<h4><code><a title="laue.utilities.RecallingIterator" href="#laue.utilities.RecallingIterator">RecallingIterator</a></code></h4>
</li>
<li>
<h4><code><a title="laue.utilities.Recordable" href="#laue.utilities.Recordable">Recordable</a></code></h4>
</li>
<li>
<h4><code><a title="laue.utilities.TimeCost" href="#laue.utilities.TimeCost">TimeCost</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>