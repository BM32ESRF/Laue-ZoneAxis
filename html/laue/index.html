<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>laue API documentation</title>
<meta name="description" content="** Permet de manipuler un lot de diagrammes de laue. **
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>laue</code></h1>
</header>
<section id="section-intro">
<h2 id="permet-de-manipuler-un-lot-de-diagrammes-de-laue"><strong> Permet de manipuler un lot de diagrammes de laue. </strong></h2>
<h2 id="notes">Notes</h2>
<ul>
<li>Pour effectuer les bancs de tests, il faut installer le module <code>pip install pytest</code>.
Il faut ensuite saisir la commande suivante:<ul>
<li><code>clear &amp;&amp; pytest --doctest-modules laue/
&amp;&amp; pytest -vv --exitfirst laue/tests.py &amp;&amp; cat tests_results.txt</code></li>
</ul>
</li>
<li>Pour generer la documentation, il faut installer le module <code>pip install pdoc3</code>.
Il faut ensuite saisir la commande suivante:<ul>
<li><code>pdoc3 laue/ -c latex_math=True --force --html</code></li>
</ul>
</li>
</ul>
<h2 id="examples">Examples</h2>
<p>preparation</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt;
</code></pre>
<p>creation d'une experience</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(image)
&gt;&gt;&gt;
&gt;&gt;&gt; experiment
Experiment(verbose=False, max_space=5, threshold=5.1)
&gt;&gt;&gt;
</code></pre>
<p>recuperation des diagrammes</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; for diag in experiment:
...     print(type(diag))
...
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt;
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
** Permet de manipuler un lot de diagrammes de laue. **
-------------------------------------------------------

Notes
-----
* Pour effectuer les bancs de tests, il faut installer le module ``pip install pytest``.
    Il faut ensuite saisir la commande suivante:
    * ``clear &amp;&amp; pytest --doctest-modules laue/
        &amp;&amp; pytest -vv --exitfirst laue/tests.py &amp;&amp; cat tests_results.txt``
* Pour generer la documentation, il faut installer le module ``pip install pdoc3``.
    Il faut ensuite saisir la commande suivante:
    * ``pdoc3 laue/ -c latex_math=True --force --html``

Examples
--------

preparation
&gt;&gt;&gt; import laue
&gt;&gt;&gt;

creation d&#39;une experience
&gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
&gt;&gt;&gt; experiment = laue.Experiment(image)
&gt;&gt;&gt;
&gt;&gt;&gt; experiment
Experiment(verbose=False, max_space=5, threshold=5.1)
&gt;&gt;&gt;

recuperation des diagrammes
&gt;&gt;&gt; for diag in experiment:
...     print(type(diag))
...
&lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
&gt;&gt;&gt;

&#34;&#34;&#34;

# Pour genereer la documentation, il faut taper dans un terminal:
# $ pdoc3 laue/ -c latex_math=True --force --html
# Pour faire passer les tests, il faut taper:
# $ python3 -m pytest --doctest-modules laue &amp;&amp; python3 -m pytest laue/tools/tests.py

__all__ = [&#34;Experiment&#34;, &#34;Transformer&#34;,
           &#34;atomic_find_zone_axes&#34;, &#34;atomic_find_subsets&#34;]
__pdoc__ = {&#34;tests&#34;: False,
            &#34;Experiment.__getitem__&#34;: True,
            &#34;Experiment.__iter__&#34;: True,
            &#34;Experiment.__len__&#34;: True}

from laue.experiment.base_experiment import Experiment
from laue.core.geometry.transformer import Transformer
from laue.core.zone_axes import atomic_find_zone_axes
from laue.core.subsets import atomic_find_subsets</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="laue.core" href="core/index.html">laue.core</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="laue.diagram" href="diagram.html">laue.diagram</a></code></dt>
<dd>
<div class="desc"><p><strong> Permet de manipuler un diagramme de Laue unique. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.experiment" href="experiment/index.html">laue.experiment</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="laue.spot" href="spot.html">laue.spot</a></code></dt>
<dd>
<div class="desc"><p><strong> Represente un spot dans un diagramme de Laue. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.utilities" href="utilities/index.html">laue.utilities</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="laue.zone_axis" href="zone_axis.html">laue.zone_axis</a></code></dt>
<dd>
<div class="desc"><p><strong> Represente un axe de zone. </strong>
…</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laue.atomic_find_subsets"><code class="name flex">
<span>def <span class="ident">atomic_find_subsets</span></span>(<span>spots_dict, axes_dict, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Fonction 'bas niveau' de separation de grains. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Cette fonction n'est pas faite pour etre utilisee directement,
il vaut mieux s'en servir a travers <code><a title="laue.Experiment.find_subsets" href="#laue.Experiment.find_subsets">Experiment.find_subsets()</a></code>
ou encore via <code><a title="laue.diagram.LaueDiagram.find_subsets" href="core/subsets.html#laue.core.subsets.Splitable.find_subsets">Splitable.find_subsets()</a></code> car le context
est mieu gere, les entrees sont plus simples et les sorties aussi.</li>
<li>Il n'y a pas de verifications sur les entrees car elles sont faite
dans les methodes de plus haut niveau.</li>
<li>Cette fonction n'est pas parallelisee. Par contre la methode
<code><a title="laue.Experiment.find_subsets" href="#laue.Experiment.find_subsets">Experiment.find_subsets()</a></code> gere nativement le parallelisme.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spots_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Une representation des spots et des information minimales
qui y sont raccrochees. Il doit prendre la forme suivante:
<code>{spot_ind: {"gnom": (x_gnom, y_gnom), "axes": {1, 3, ...}}, ...}</code></dd>
<dt><strong><code>axes_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Une representations des axes de zone. Doit etre de la forme:
<code>{axe_ind: {"polar": (theta, dist), "quality": .7, "spots": {1, 4, 5, 6}}, ...}</code></dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Doit au moins contenir les 3 champs <code>angle_max</code>, <code>spots_max</code> et <code>distance_max</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Chaque element est un ensemble d'indice de spot appartenant au meme grain.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; spots_dict = {0: {'gnom': (0.3136510725564478, -0.44091934214920697), 'axes': set()},
...               1: {'gnom': (0.3092269223801162, -0.3703963974694111), 'axes': {0}},
...               2: {'gnom': (0.29464954430652696, 0.39670741889986955), 'axes': {1}},
...               3: {'gnom': (0.30191318963902786, 0.011759364157261544), 'axes': {2}},
...               4: {'gnom': (0.2656586060012433, -0.29892567761860783), 'axes': {0}},
...               5: {'gnom': (0.2537441830952802, 0.32256757073867776), 'axes': {1}},
...               6: {'gnom': (0.259687191990358, 0.011094867051531301), 'axes': {2}},
...               7: {'gnom': (0.21447480004378858, -0.2150686716681864), 'axes': {0}},
...               8: {'gnom': (0.2057015738443993, 0.2356420984106664), 'axes': {1}},
...               9: {'gnom': (0.09095514707222462, -0.5356714822419564), 'axes': {3, 4}},
...               10: {'gnom': (0.06846289051965272, 0.5548594993575858), 'axes': {3, 5}},
...               11: {'gnom': (0.16685972592987006, -0.1362785647833782), 'axes': {0}},
...               12: {'gnom': (0.16092652407854113, 0.15424696872260854), 'axes': {1}},
...               13: {'gnom': (0.0880179013812851, -0.40043047804756454), 'axes': {3}},
...               14: {'gnom': (0.07130573600458438, 0.4174843621463065), 'axes': {3}},
...               15: {'gnom': (0.08639048300887514, -0.31911672107326594), 'axes': {3}},
...               16: {'gnom': (0.07308383568548608, 0.3351760458933546), 'axes': {3}},
...               17: {'gnom': (-0.016567440130016563, -0.5541568143935384), 'axes': {6}},
...               18: {'gnom': (-0.04084781468303007, 0.5689448068249144), 'axes': {7}},
...               19: {'gnom': (0.0011982188252073992, -0.45016007120047424), 'axes': set()},
...               20: {'gnom': (-0.018154025485441625, 0.46402526754308027), 'axes': set()},
...               21: {'gnom': (-0.07286049562681773, -0.5640133440412382), 'axes': set()},
...               22: {'gnom': (0.0798366324753105, 0.007023938379407561), 'axes': {0, 1, 2, 3}},
...               23: {'gnom': (-0.0026903259324252246, 0.3921879524265071), 'axes': {5}},
...               24: {'gnom': (-0.09784778756977644, 0.5766271192972883), 'axes': set()},
...               25: {'gnom': (0.008002458469782677, -0.12293574282766238), 'axes': {1}},
...               26: {'gnom': (0.0027460490484708115, 0.13394781189060836), 'axes': {0}},
...               27: {'gnom': (-0.00523750349077013, -0.1470394198008183), 'axes': {1}},
...               28: {'gnom': (-0.011614516626281228, 0.15777148638160254), 'axes': {0}},
...               29: {'gnom': (-0.02477598980567221, -0.1823836791494654), 'axes': {1}},
...               30: {'gnom': (-0.03264505249777272, 0.19229497060446735), 'axes': {0}},
...               31: {'gnom': (-0.05554717740227801, -0.23832176191125093), 'axes': {1, 4}},
...               32: {'gnom': (-0.06606796372263056, 0.24757266647939288), 'axes': {0, 5}},
...               33: {'gnom': (-0.07907768658950604, -0.28096918114364355), 'axes': {1}},
...               34: {'gnom': (-0.09156428823859053, 0.2893970244445073), 'axes': {0}},
...               35: {'gnom': (-0.1126289846318788, -0.3416241560303849), 'axes': {1, 6}},
...               36: {'gnom': (-0.060637577826655534, 0.0040391083212410655), 'axes': {2}},
...               37: {'gnom': (-0.12787900102974828, 0.3491863530719953), 'axes': {0, 7}},
...               38: {'gnom': (-0.1638208798822865, -0.4347286698438957), 'axes': {1}},
...               39: {'gnom': (-0.18763951100210385, -0.4776573606384503), 'axes': {1}},
...               40: {'gnom': (-0.1835787305562983, 0.4411739247300923), 'axes': {0}},
...               41: {'gnom': (-0.08524649743749545, 0.003436523504335945), 'axes': {2}},
...               42: {'gnom': (-0.2523542667003644, -0.5949096601292776), 'axes': {8, 1}},
...               43: {'gnom': (-0.20958039716029048, 0.4837711867805186), 'axes': {0}},
...               44: {'gnom': (-0.11758167206566646, -0.1123768702642382), 'axes': {4}},
...               45: {'gnom': (-0.12266805447587614, 0.11817207059217111), 'axes': {5}},
...               46: {'gnom': (-0.17376685735949005, 0.0016472083664571353), 'axes': {2, 4, 5}},
...               47: {'gnom': (-0.20724297206742168, -0.25150647771157364), 'axes': set()},
...               48: {'gnom': (-0.19501092265693473, -0.15910834995174863), 'axes': {6}},
...               49: {'gnom': (-0.21870028043714163, 0.25404867230414246), 'axes': set()},
...               50: {'gnom': (-0.2022799134764107, 0.16163477331619278), 'axes': {7}},
...               51: {'gnom': (-0.2581018757728966, -0.3579924435989167), 'axes': {8}},
...               52: {'gnom': (-0.2748170617964089, 0.3596407013965223), 'axes': {8}},
...               53: {'gnom': (-0.21290266125204668, 0.0008346770568725252), 'axes': {2}},
...               54: {'gnom': (-0.21986841578944072, -0.10369811043407293), 'axes': {5, 6}},
...               55: {'gnom': (-0.224622744015843, 0.10503684334781563), 'axes': {4, 7}},
...               56: {'gnom': (-0.25955409478645797, -0.29848728294016463), 'axes': {8}},
...               57: {'gnom': (-0.27338619051240226, 0.299389601118816), 'axes': {8}},
...               58: {'gnom': (-0.3156632165624574, -0.4202358686963255), 'axes': set()},
...               59: {'gnom': (-0.2618304221414466, -0.19929059589121062), 'axes': {8, 5}},
...               60: {'gnom': (-0.2711073666720387, 0.1994839074523256), 'axes': {8, 4}},
...               61: {'gnom': (-0.2637120677768278, -0.11984479170021081), 'axes': {8}},
...               62: {'gnom': (-0.26934469418071083, 0.11943958616023759), 'axes': {8}},
...               63: {'gnom': (-0.26653796331705015, -0.00040349411462381246), 'axes': {8, 2, 6, 7}},
...               64: {'gnom': (-0.3351088299984176, -0.36661822106768144), 'axes': {5}},
...               65: {'gnom': (-0.30919293226499917, -0.22782988778598667), 'axes': set()},
...               66: {'gnom': (-0.3524825023650732, 0.3647641920521141), 'axes': {4}},
...               67: {'gnom': (-0.31990969642322137, 0.22611752961083748), 'axes': set()},
...               68: {'gnom': (-0.3144023520521512, -0.0013698968940222644), 'axes': {2}},
...               69: {'gnom': (-0.3223772542169661, -0.14153279317889217), 'axes': {7}},
...               70: {'gnom': (-0.3290872223583307, 0.13867490378055763), 'axes': {6}},
...               71: {'gnom': (-0.34380505280556134, -0.0019232844125064402), 'axes': {2}},
...               72: {'gnom': (-0.3716527272451695, -0.2655541496297943), 'axes': {7}},
...               73: {'gnom': (-0.384382394518522, 0.26137948985364423), 'axes': {6}},
...               74: {'gnom': (-0.4150393355485816, -0.37556396956837046), 'axes': {7}},
...               75: {'gnom': (-0.4213116259525938, -0.1277995546595711), 'axes': set()},
...               76: {'gnom': (-0.42743697409652126, 0.12091462467337603), 'axes': set()},
...               77: {'gnom': (-0.4305672928685682, -0.10207732996277492), 'axes': set()}}
&gt;&gt;&gt; axes_dict = {0: {'polar': (0.5456325, 0.07189146), 'quality': 0.7786729549943984, 'spots': {32, 1, 34, 4, 37, 7, 40, 11, 43, 22, 26, 28, 30}},
...              1: {'polar': (-0.50404394, 0.066435024), 'quality': 0.8495679649229442, 'spots': {33, 2, 35, 5, 38, 39, 8, 42, 12, 22, 25, 27, 29, 31}},
...              2: {'polar': (1.5920126, 0.0053436677), 'quality': 0.5048333500772214, 'spots': {3, 36, 68, 6, 71, 41, 46, 53, 22, 63}},
...              3: {'polar': (0.020630987, 0.07989738), 'quality': 0.32446216058045907, 'spots': {9, 10, 13, 14, 15, 16, 22}},
...              4: {'polar': (-2.6840417, 0.15513226), 'quality': 0.32470155528405464, 'spots': {66, 9, 44, 46, 55, 60, 31}},
...              5: {'polar': (2.7287471, 0.15980783), 'quality': 0.36693478788694234, 'spots': {32, 64, 10, 45, 46, 54, 23, 59}},
...              6: {'polar': (-2.7180853, 0.24310948), 'quality': 0.324204821510315, 'spots': {35, 70, 73, 48, 17, 54, 63}},
...              7: {'polar': (2.7643242, 0.24759501), 'quality': 0.3668147624332471, 'spots': {69, 37, 72, 74, 18, 50, 55, 63}},
...              8: {'polar': (-3.118213, 0.26645306), 'quality': 0.5046664108258551, 'spots': {42, 51, 52, 56, 57, 59, 60, 61, 62, 63}}}
&gt;&gt;&gt; kwargs = {'angle_max': 0.1308996938995747, 'spots_max': 20, 'distance_max': 0.08}
&gt;&gt;&gt; laue.atomic_find_subsets(spots_dict, axes_dict, **kwargs)
[{9, 10, 22}]
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_find_subsets(spots_dict, axes_dict, **kwargs):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de separation de grains. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.Experiment.find_subsets``
    ou encore via ``laue.diagram.LaueDiagram.find_subsets`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.Experiment.find_subsets`` gere nativement le parallelisme.

    Parameters
    ----------
    spots_dict : dict
        Une representation des spots et des information minimales
        qui y sont raccrochees. Il doit prendre la forme suivante:
        ``{spot_ind: {&#34;gnom&#34;: (x_gnom, y_gnom), &#34;axes&#34;: {1, 3, ...}}, ...}``
    axes_dict : dict
        Une representations des axes de zone. Doit etre de la forme:
        ``{axe_ind: {&#34;polar&#34;: (theta, dist), &#34;quality&#34;: .7, &#34;spots&#34;: {1, 4, 5, 6}}, ...}``
    **kwargs
        Doit au moins contenir les 3 champs ``angle_max``, ``spots_max`` et ``distance_max``.

    Returns
    -------
    list
        Chaque element est un ensemble d&#39;indice de spot appartenant au meme grain.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; spots_dict = {0: {&#39;gnom&#39;: (0.3136510725564478, -0.44091934214920697), &#39;axes&#39;: set()},
    ...               1: {&#39;gnom&#39;: (0.3092269223801162, -0.3703963974694111), &#39;axes&#39;: {0}},
    ...               2: {&#39;gnom&#39;: (0.29464954430652696, 0.39670741889986955), &#39;axes&#39;: {1}},
    ...               3: {&#39;gnom&#39;: (0.30191318963902786, 0.011759364157261544), &#39;axes&#39;: {2}},
    ...               4: {&#39;gnom&#39;: (0.2656586060012433, -0.29892567761860783), &#39;axes&#39;: {0}},
    ...               5: {&#39;gnom&#39;: (0.2537441830952802, 0.32256757073867776), &#39;axes&#39;: {1}},
    ...               6: {&#39;gnom&#39;: (0.259687191990358, 0.011094867051531301), &#39;axes&#39;: {2}},
    ...               7: {&#39;gnom&#39;: (0.21447480004378858, -0.2150686716681864), &#39;axes&#39;: {0}},
    ...               8: {&#39;gnom&#39;: (0.2057015738443993, 0.2356420984106664), &#39;axes&#39;: {1}},
    ...               9: {&#39;gnom&#39;: (0.09095514707222462, -0.5356714822419564), &#39;axes&#39;: {3, 4}},
    ...               10: {&#39;gnom&#39;: (0.06846289051965272, 0.5548594993575858), &#39;axes&#39;: {3, 5}},
    ...               11: {&#39;gnom&#39;: (0.16685972592987006, -0.1362785647833782), &#39;axes&#39;: {0}},
    ...               12: {&#39;gnom&#39;: (0.16092652407854113, 0.15424696872260854), &#39;axes&#39;: {1}},
    ...               13: {&#39;gnom&#39;: (0.0880179013812851, -0.40043047804756454), &#39;axes&#39;: {3}},
    ...               14: {&#39;gnom&#39;: (0.07130573600458438, 0.4174843621463065), &#39;axes&#39;: {3}},
    ...               15: {&#39;gnom&#39;: (0.08639048300887514, -0.31911672107326594), &#39;axes&#39;: {3}},
    ...               16: {&#39;gnom&#39;: (0.07308383568548608, 0.3351760458933546), &#39;axes&#39;: {3}},
    ...               17: {&#39;gnom&#39;: (-0.016567440130016563, -0.5541568143935384), &#39;axes&#39;: {6}},
    ...               18: {&#39;gnom&#39;: (-0.04084781468303007, 0.5689448068249144), &#39;axes&#39;: {7}},
    ...               19: {&#39;gnom&#39;: (0.0011982188252073992, -0.45016007120047424), &#39;axes&#39;: set()},
    ...               20: {&#39;gnom&#39;: (-0.018154025485441625, 0.46402526754308027), &#39;axes&#39;: set()},
    ...               21: {&#39;gnom&#39;: (-0.07286049562681773, -0.5640133440412382), &#39;axes&#39;: set()},
    ...               22: {&#39;gnom&#39;: (0.0798366324753105, 0.007023938379407561), &#39;axes&#39;: {0, 1, 2, 3}},
    ...               23: {&#39;gnom&#39;: (-0.0026903259324252246, 0.3921879524265071), &#39;axes&#39;: {5}},
    ...               24: {&#39;gnom&#39;: (-0.09784778756977644, 0.5766271192972883), &#39;axes&#39;: set()},
    ...               25: {&#39;gnom&#39;: (0.008002458469782677, -0.12293574282766238), &#39;axes&#39;: {1}},
    ...               26: {&#39;gnom&#39;: (0.0027460490484708115, 0.13394781189060836), &#39;axes&#39;: {0}},
    ...               27: {&#39;gnom&#39;: (-0.00523750349077013, -0.1470394198008183), &#39;axes&#39;: {1}},
    ...               28: {&#39;gnom&#39;: (-0.011614516626281228, 0.15777148638160254), &#39;axes&#39;: {0}},
    ...               29: {&#39;gnom&#39;: (-0.02477598980567221, -0.1823836791494654), &#39;axes&#39;: {1}},
    ...               30: {&#39;gnom&#39;: (-0.03264505249777272, 0.19229497060446735), &#39;axes&#39;: {0}},
    ...               31: {&#39;gnom&#39;: (-0.05554717740227801, -0.23832176191125093), &#39;axes&#39;: {1, 4}},
    ...               32: {&#39;gnom&#39;: (-0.06606796372263056, 0.24757266647939288), &#39;axes&#39;: {0, 5}},
    ...               33: {&#39;gnom&#39;: (-0.07907768658950604, -0.28096918114364355), &#39;axes&#39;: {1}},
    ...               34: {&#39;gnom&#39;: (-0.09156428823859053, 0.2893970244445073), &#39;axes&#39;: {0}},
    ...               35: {&#39;gnom&#39;: (-0.1126289846318788, -0.3416241560303849), &#39;axes&#39;: {1, 6}},
    ...               36: {&#39;gnom&#39;: (-0.060637577826655534, 0.0040391083212410655), &#39;axes&#39;: {2}},
    ...               37: {&#39;gnom&#39;: (-0.12787900102974828, 0.3491863530719953), &#39;axes&#39;: {0, 7}},
    ...               38: {&#39;gnom&#39;: (-0.1638208798822865, -0.4347286698438957), &#39;axes&#39;: {1}},
    ...               39: {&#39;gnom&#39;: (-0.18763951100210385, -0.4776573606384503), &#39;axes&#39;: {1}},
    ...               40: {&#39;gnom&#39;: (-0.1835787305562983, 0.4411739247300923), &#39;axes&#39;: {0}},
    ...               41: {&#39;gnom&#39;: (-0.08524649743749545, 0.003436523504335945), &#39;axes&#39;: {2}},
    ...               42: {&#39;gnom&#39;: (-0.2523542667003644, -0.5949096601292776), &#39;axes&#39;: {8, 1}},
    ...               43: {&#39;gnom&#39;: (-0.20958039716029048, 0.4837711867805186), &#39;axes&#39;: {0}},
    ...               44: {&#39;gnom&#39;: (-0.11758167206566646, -0.1123768702642382), &#39;axes&#39;: {4}},
    ...               45: {&#39;gnom&#39;: (-0.12266805447587614, 0.11817207059217111), &#39;axes&#39;: {5}},
    ...               46: {&#39;gnom&#39;: (-0.17376685735949005, 0.0016472083664571353), &#39;axes&#39;: {2, 4, 5}},
    ...               47: {&#39;gnom&#39;: (-0.20724297206742168, -0.25150647771157364), &#39;axes&#39;: set()},
    ...               48: {&#39;gnom&#39;: (-0.19501092265693473, -0.15910834995174863), &#39;axes&#39;: {6}},
    ...               49: {&#39;gnom&#39;: (-0.21870028043714163, 0.25404867230414246), &#39;axes&#39;: set()},
    ...               50: {&#39;gnom&#39;: (-0.2022799134764107, 0.16163477331619278), &#39;axes&#39;: {7}},
    ...               51: {&#39;gnom&#39;: (-0.2581018757728966, -0.3579924435989167), &#39;axes&#39;: {8}},
    ...               52: {&#39;gnom&#39;: (-0.2748170617964089, 0.3596407013965223), &#39;axes&#39;: {8}},
    ...               53: {&#39;gnom&#39;: (-0.21290266125204668, 0.0008346770568725252), &#39;axes&#39;: {2}},
    ...               54: {&#39;gnom&#39;: (-0.21986841578944072, -0.10369811043407293), &#39;axes&#39;: {5, 6}},
    ...               55: {&#39;gnom&#39;: (-0.224622744015843, 0.10503684334781563), &#39;axes&#39;: {4, 7}},
    ...               56: {&#39;gnom&#39;: (-0.25955409478645797, -0.29848728294016463), &#39;axes&#39;: {8}},
    ...               57: {&#39;gnom&#39;: (-0.27338619051240226, 0.299389601118816), &#39;axes&#39;: {8}},
    ...               58: {&#39;gnom&#39;: (-0.3156632165624574, -0.4202358686963255), &#39;axes&#39;: set()},
    ...               59: {&#39;gnom&#39;: (-0.2618304221414466, -0.19929059589121062), &#39;axes&#39;: {8, 5}},
    ...               60: {&#39;gnom&#39;: (-0.2711073666720387, 0.1994839074523256), &#39;axes&#39;: {8, 4}},
    ...               61: {&#39;gnom&#39;: (-0.2637120677768278, -0.11984479170021081), &#39;axes&#39;: {8}},
    ...               62: {&#39;gnom&#39;: (-0.26934469418071083, 0.11943958616023759), &#39;axes&#39;: {8}},
    ...               63: {&#39;gnom&#39;: (-0.26653796331705015, -0.00040349411462381246), &#39;axes&#39;: {8, 2, 6, 7}},
    ...               64: {&#39;gnom&#39;: (-0.3351088299984176, -0.36661822106768144), &#39;axes&#39;: {5}},
    ...               65: {&#39;gnom&#39;: (-0.30919293226499917, -0.22782988778598667), &#39;axes&#39;: set()},
    ...               66: {&#39;gnom&#39;: (-0.3524825023650732, 0.3647641920521141), &#39;axes&#39;: {4}},
    ...               67: {&#39;gnom&#39;: (-0.31990969642322137, 0.22611752961083748), &#39;axes&#39;: set()},
    ...               68: {&#39;gnom&#39;: (-0.3144023520521512, -0.0013698968940222644), &#39;axes&#39;: {2}},
    ...               69: {&#39;gnom&#39;: (-0.3223772542169661, -0.14153279317889217), &#39;axes&#39;: {7}},
    ...               70: {&#39;gnom&#39;: (-0.3290872223583307, 0.13867490378055763), &#39;axes&#39;: {6}},
    ...               71: {&#39;gnom&#39;: (-0.34380505280556134, -0.0019232844125064402), &#39;axes&#39;: {2}},
    ...               72: {&#39;gnom&#39;: (-0.3716527272451695, -0.2655541496297943), &#39;axes&#39;: {7}},
    ...               73: {&#39;gnom&#39;: (-0.384382394518522, 0.26137948985364423), &#39;axes&#39;: {6}},
    ...               74: {&#39;gnom&#39;: (-0.4150393355485816, -0.37556396956837046), &#39;axes&#39;: {7}},
    ...               75: {&#39;gnom&#39;: (-0.4213116259525938, -0.1277995546595711), &#39;axes&#39;: set()},
    ...               76: {&#39;gnom&#39;: (-0.42743697409652126, 0.12091462467337603), &#39;axes&#39;: set()},
    ...               77: {&#39;gnom&#39;: (-0.4305672928685682, -0.10207732996277492), &#39;axes&#39;: set()}}
    &gt;&gt;&gt; axes_dict = {0: {&#39;polar&#39;: (0.5456325, 0.07189146), &#39;quality&#39;: 0.7786729549943984, &#39;spots&#39;: {32, 1, 34, 4, 37, 7, 40, 11, 43, 22, 26, 28, 30}},
    ...              1: {&#39;polar&#39;: (-0.50404394, 0.066435024), &#39;quality&#39;: 0.8495679649229442, &#39;spots&#39;: {33, 2, 35, 5, 38, 39, 8, 42, 12, 22, 25, 27, 29, 31}},
    ...              2: {&#39;polar&#39;: (1.5920126, 0.0053436677), &#39;quality&#39;: 0.5048333500772214, &#39;spots&#39;: {3, 36, 68, 6, 71, 41, 46, 53, 22, 63}},
    ...              3: {&#39;polar&#39;: (0.020630987, 0.07989738), &#39;quality&#39;: 0.32446216058045907, &#39;spots&#39;: {9, 10, 13, 14, 15, 16, 22}},
    ...              4: {&#39;polar&#39;: (-2.6840417, 0.15513226), &#39;quality&#39;: 0.32470155528405464, &#39;spots&#39;: {66, 9, 44, 46, 55, 60, 31}},
    ...              5: {&#39;polar&#39;: (2.7287471, 0.15980783), &#39;quality&#39;: 0.36693478788694234, &#39;spots&#39;: {32, 64, 10, 45, 46, 54, 23, 59}},
    ...              6: {&#39;polar&#39;: (-2.7180853, 0.24310948), &#39;quality&#39;: 0.324204821510315, &#39;spots&#39;: {35, 70, 73, 48, 17, 54, 63}},
    ...              7: {&#39;polar&#39;: (2.7643242, 0.24759501), &#39;quality&#39;: 0.3668147624332471, &#39;spots&#39;: {69, 37, 72, 74, 18, 50, 55, 63}},
    ...              8: {&#39;polar&#39;: (-3.118213, 0.26645306), &#39;quality&#39;: 0.5046664108258551, &#39;spots&#39;: {42, 51, 52, 56, 57, 59, 60, 61, 62, 63}}}
    &gt;&gt;&gt; kwargs = {&#39;angle_max&#39;: 0.1308996938995747, &#39;spots_max&#39;: 20, &#39;distance_max&#39;: 0.08}
    &gt;&gt;&gt; laue.atomic_find_subsets(spots_dict, axes_dict, **kwargs)
    [{9, 10, 22}]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.zone_axis import distance as distance_axis
    from laue.spot import distance as distance_pic
    import networkx

    def count_variant_axis(spot_id):
        &#34;&#34;&#34;
        Compte le nombre d&#39;axes de zone qui different beaucoup.
        (ie considere 2 axes proche comme un seul axe)
        &#34;&#34;&#34;
        axes_id = spots_dict[spot_id][&#34;axes&#34;]
        if len(axes_id) &lt;= 1:
            return len(axes_id)
        axes = [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes_id]
        nbr_near = (distance_axis(axes, axes, weight=1) &lt; kwargs[&#34;angle_max&#34;]).sum()
        nbr = len(axes) - (nbr_near-len(axes))//2
        return nbr

    def simul_remove_axis(graph, axis, excluded):
        &#34;&#34;&#34;
        Retire les aretes liees a cet axe, puis regarde ce que ca donne.
        &#34;&#34;&#34;
        graph_bis = graph.copy()
        for spot1, spot2, axis_found in graph.edges.data(&#34;axis&#34;):
            if axis_found is axis:
                graph_bis.remove_edge(spot1, spot2)
        excluded_bis = [edge for edge in excluded if networkx.algorithms.has_path(graph_bis, *edge)]
        return excluded_bis, graph_bis

    # Extraction des spots.
    spots_at_cross = sorted(spots_dict, key=count_variant_axis, reverse=True)[:kwargs[&#34;spots_max&#34;]]
    max_cross = count_variant_axis(spots_at_cross[0])
    limit = math.sqrt(max(2**2, max_cross)) # Permet d&#39;eviter &#39;ValueError: math domain error&#39;
    spots_at_cross = [spot_id for spot_id in spots_at_cross if count_variant_axis(spot_id) &gt;= limit]

    # Creation des noeuds du graphe.
    graph = networkx.Graph()
    graph.add_nodes_from(spots_at_cross)

    # Ajout grossier de certaine aretes.
    excluded = [] # La liste des noeuds appartenant a des grains differents.
    candidate_axes = set() # L&#39;ensemble des axes de zone consideres.
    for i, spot1 in enumerate(spots_at_cross[:-1]): # On faite toutes les combinaisons
        for spot2 in spots_at_cross[i+1:]: # de 2 sommets possibles.

            ## Exclusion des spots trop proches.
            if distance_pic(
                    spots_dict[spot1][&#34;gnom&#34;],
                    spots_dict[spot2][&#34;gnom&#34;],
                    space=&#34;gnomonic&#34;
                    ) &lt; kwargs[&#34;distance_max&#34;]:
                excluded.append((spot1, spot2))
                continue

            ## On ne relie pas les spots qui n&#39;ont pas d&#39;axe commun.
            common_axes = spots_dict[spot1][&#34;axes&#34;] &amp; spots_dict[spot2][&#34;axes&#34;]
            if not common_axes:
                continue

            ## Exclusion des spots ayant 2 axes de zone paralleles.
            axes1, axes2 = spots_dict[spot1][&#34;axes&#34;]-common_axes, spots_dict[spot2][&#34;axes&#34;]-common_axes
            if axes1 and axes2 and distance_axis(
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes1],
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes2],
                    weight=1).min() &lt; kwargs[&#34;angle_max&#34;]: # tolerance angulaire de pi/32
                excluded.append((spot1, spot2))
                continue

            ## Ajout dans le graphe.
            best_axis = sorted(common_axes, key=lambda axis_id: axes_dict[axis_id][&#34;quality&#34;])[-1]
            candidate_axes.add(best_axis)
            graph.add_edge(spot1, spot2, quality=axes_dict[best_axis][&#34;quality&#34;], axis=best_axis)

    # Suppression des aretes en trop afin de discosier les grains.
    excluded = [edge for edge in excluded if networkx.algorithms.has_path(graph, *edge)]
    while excluded:
        predictions = [(*simul_remove_axis(graph, axis_id, excluded), axis_id) for axis_id in candidate_axes]
        best_len = min(len(excluded_bis) for excluded_bis, _, _ in predictions)
        predictions = [p for p in predictions if len(p[0]) == best_len]
        costs = [axes_dict[axis_id][&#34;quality&#34;] for _, _, axis_id in predictions]
        min_quality = min(costs)
        predictions = [p for p in predictions if axes_dict[p[2]][&#34;quality&#34;] == min_quality]
        excluded, graph, axis_id = predictions.pop()
        candidate_axes.remove(axis_id)

    # Creation des clusters.
    subsets = list(networkx.algorithms.connected_components(graph))
    subsets = sorted(subsets, key=lambda con: len(con), reverse=True)
    subsets = [con for con in subsets if len(con) &gt;= 2]
    return subsets</code></pre>
</details>
</dd>
<dt id="laue.atomic_find_zone_axes"><code class="name flex">
<span>def <span class="ident">atomic_find_zone_axes</span></span>(<span>transformer, gnomonics, dmax, nbr, tol)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Fonction 'bas niveau' de recherche d'axes de zonnes. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Cette fonction n'est pas faite pour etre utilisee directement,
il vaut mieux s'en servir a travers <code><a title="laue.Experiment.find_zone_axes" href="#laue.Experiment.find_zone_axes">Experiment.find_zone_axes()</a></code>
ou encore via <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code> car le context
est mieu gere, les entrees sont plus simples et les sorties aussi.</li>
<li>Il n'y a pas de verifications sur les entrees car elles sont faite
dans les methodes de plus haut niveau.</li>
<li>Cette fonction n'est pas parallelisee. Par contre la methode
<code><a title="laue.Experiment.find_zone_axes" href="#laue.Experiment.find_zone_axes">Experiment.find_zone_axes()</a></code> gere nativement le parallelisme.</li>
<li>La seule raison d'utiliser cette fonction, c'est si le pic_search
utilise n'est pas celui de <code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code>. Sinon, l'utilisation
de cette fonction ne fera qu'alourdir et ralentir votre code.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transformer</code></strong> :&ensp;<code><a title="laue.core.geometry.transformer.Transformer" href="core/geometry/transformer.html#laue.core.geometry.transformer.Transformer">Transformer</a></code></dt>
<dd>Instance d'un objet capable de gerer formellement
la transformee de hough. (Cet argument n'est pas present
si on utilise les methodes ci dessus car il fait partie
d'une <code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code>.)</dd>
<dt><strong><code>gnomonics</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Les positions des spots en coordonnees gnomonic.
Il faut que <code>x_gnomonic = gnomonic[0]</code>
et que <code>y_gnomonic = gnomonic[1]</code>.</dd>
<dt><strong><code>dmax</code></strong></dt>
<dd>Comme <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code> a la difference
que ce parametre n'est pas factultatif.</dd>
<dt><strong><code>nbr</code></strong></dt>
<dd>Comme <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code> a la difference
que ce parametre n'est pas factultatif.</dd>
<dt><strong><code>tol</code></strong></dt>
<dd>Comme <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code> a la difference
que ce parametre doit etre fixe par vous et ne peut
pas prendre tous seulle une valeur optimale.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>angles</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Vecteur des angles des droites. C'est la premiere partie
de la representation polaire des droites. (C'est l'angle
algebrique entre l'axe x et un vecteur normal a la droite.)</dd>
<dt><strong><code>dists</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Vecteur des distances des droites. C'est la seconde partie
de la representation polaire des droites. (C'est la plus courte
distance entre l'origine et tous les points constituant la droite.)</dd>
<dt><strong><code>axes_spots_ind</code></strong> :&ensp;<code>list</code></dt>
<dd>Vecteur des ensembles de spots lies a chaque droites.
On a <code>len(axes_spots_ind) == nbr_d_axe_de_zones</code>.</dd>
<dt><strong><code>spots_axes_ind</code></strong> :&ensp;<code>list</code></dt>
<dd>Vecteur des indices des droites passant par chaque spot.
On a <code>len(spots_axes_ind) == nbr_de_spots</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import laue
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; gnomonics = np.array(
... [[ 3.13651353e-01,  3.09226930e-01,  2.94649661e-01,  3.01913261e-01,
...    2.65658647e-01,  2.53744185e-01,  2.59687364e-01,  2.14474797e-01,
...    2.05701679e-01,  9.09550861e-02,  6.84629381e-02,  1.66859716e-01,
...    1.60926506e-01,  8.80179554e-02,  7.13057593e-02,  8.63905624e-02,
...    7.30837137e-02, -1.65674724e-02, -4.08478454e-02,  1.19812461e-03,
...   -1.81540363e-02, -7.28605017e-02,  7.98366740e-02, -2.69038416e-03,
...   -9.78478342e-02,  8.00240133e-03,  2.74614431e-03, -5.23754954e-03,
...   -1.16145127e-02, -2.47761104e-02, -3.26450653e-02, -5.55472001e-02,
...   -6.60679415e-02, -7.90777430e-02, -9.15642828e-02, -1.12629071e-01,
...   -6.06376082e-02, -1.27878949e-01, -1.63820893e-01, -1.87639564e-01,
...   -1.83578789e-01, -8.52464810e-02, -2.52354264e-01, -2.09580392e-01,
...   -1.17581628e-01, -1.22668095e-01, -1.73766926e-01, -2.07243070e-01,
...   -1.95010900e-01, -2.18700320e-01, -2.02279896e-01, -2.58101851e-01,
...   -2.74817050e-01, -2.12902710e-01, -2.19868407e-01, -2.24622726e-01,
...   -2.59554148e-01, -2.73386180e-01, -3.15663189e-01, -2.61830509e-01,
...   -2.71107376e-01, -2.63712078e-01, -2.69344717e-01, -2.66537964e-01,
...   -3.35108876e-01, -3.09192955e-01, -3.52482527e-01, -3.19909692e-01,
...   -3.14402401e-01, -3.22377235e-01, -3.29087257e-01, -3.43805134e-01,
...   -3.71652663e-01, -3.84382367e-01, -4.15039361e-01, -4.21311647e-01,
...   -4.27436978e-01, -4.30567324e-01],
...  [-4.40919399e-01, -3.70396405e-01,  3.96707416e-01,  1.17593547e-02,
...   -2.98925638e-01,  3.22567523e-01,  1.10948607e-02, -2.15068594e-01,
...    2.35642120e-01, -5.35671413e-01,  5.54859519e-01, -1.36278614e-01,
...    1.54246926e-01, -4.00430471e-01,  4.17484373e-01, -3.19116771e-01,
...    3.35176021e-01, -5.54156780e-01,  5.68944812e-01, -4.50160027e-01,
...    4.64025259e-01, -5.64013302e-01,  7.02395430e-03,  3.92187923e-01,
...    5.76627076e-01, -1.22935735e-01,  1.33947819e-01, -1.47039399e-01,
...    1.57771528e-01, -1.82383612e-01,  1.92295000e-01, -2.38321751e-01,
...    2.47572735e-01, -2.80969173e-01,  2.89397061e-01, -3.41624111e-01,
...    4.03913576e-03,  3.49186361e-01, -4.34728622e-01, -4.77657378e-01,
...    4.41173941e-01,  3.43652675e-03, -5.94909608e-01,  4.83771175e-01,
...   -1.12376906e-01,  1.18172102e-01,  1.64722977e-03, -2.51506448e-01,
...   -1.59108326e-01,  2.54048705e-01,  1.61634743e-01, -3.57992381e-01,
...    3.59640747e-01,  8.34673643e-04, -1.03698038e-01,  1.05036855e-01,
...   -2.98487246e-01,  2.99389601e-01, -4.20235783e-01, -1.99290574e-01,
...    1.99483901e-01, -1.19844824e-01,  1.19439557e-01, -4.03501937e-04,
...   -3.66618216e-01, -2.27829859e-01,  3.64764214e-01,  2.26117536e-01,
...   -1.36989250e-03, -1.41532809e-01,  1.38674900e-01, -1.92326447e-03,
...   -2.65554100e-01,  2.61379480e-01, -3.75563949e-01, -1.27799526e-01,
...    1.20914638e-01, -1.02077320e-01]])
&gt;&gt;&gt; dmax = 0.01086181640625
&gt;&gt;&gt; nbr = 7
&gt;&gt;&gt; tol = 0.01758723266
&gt;&gt;&gt; angles, dists, axes_spots_ind, spots_axes_ind = laue.atomic_find_zone_axes(
...     transformer, gnomonics, dmax, nbr, tol)
&gt;&gt;&gt; len(angles), len(dists)
(9, 9)
&gt;&gt;&gt; for spots in axes_spots_ind:
...     print(sorted(spots))
...
[1, 4, 7, 11, 22, 26, 28, 30, 32, 34, 37, 40, 43]
[2, 5, 8, 12, 22, 25, 27, 29, 31, 33, 35, 38, 39, 42]
[3, 6, 22, 36, 41, 46, 53, 63, 68, 71]
[9, 10, 13, 14, 15, 16, 22]
[9, 31, 44, 46, 55, 60, 66]
[10, 23, 32, 45, 46, 54, 59, 64]
[17, 35, 48, 54, 63, 70, 73]
[18, 37, 50, 55, 63, 69, 72, 74]
[42, 51, 52, 56, 57, 59, 60, 61, 62, 63]
&gt;&gt;&gt; spots_axes_ind[0]
set()
&gt;&gt;&gt; sorted(spots_axes_ind[22])
[0, 1, 2, 3]
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_find_zone_axes(transformer, gnomonics, dmax, nbr, tol):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de recherche d&#39;axes de zonnes. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.Experiment.find_zone_axes``
    ou encore via ``laue.diagram.LaueDiagram.find_zone_axes`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.Experiment.find_zone_axes`` gere nativement le parallelisme.
    * La seule raison d&#39;utiliser cette fonction, c&#39;est si le pic_search
    utilise n&#39;est pas celui de ``laue.Experiment``. Sinon, l&#39;utilisation
    de cette fonction ne fera qu&#39;alourdir et ralentir votre code.

    Parameters
    ----------
    transformer : laue.core.geometry.transformer.Transformer
        Instance d&#39;un objet capable de gerer formellement
        la transformee de hough. (Cet argument n&#39;est pas present
        si on utilise les methodes ci dessus car il fait partie
        d&#39;une ``laue.Experiment``.)
    gnomonics : np.ndarray
        Les positions des spots en coordonnees gnomonic.
        Il faut que ``x_gnomonic = gnomonic[0]``
        et que ``y_gnomonic = gnomonic[1]``.
    dmax
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre n&#39;est pas factultatif.
    nbr
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre n&#39;est pas factultatif.
    tol
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre doit etre fixe par vous et ne peut
        pas prendre tous seulle une valeur optimale.

    Returns
    -------
    angles : iterable
        Vecteur des angles des droites. C&#39;est la premiere partie
        de la representation polaire des droites. (C&#39;est l&#39;angle
        algebrique entre l&#39;axe x et un vecteur normal a la droite.)
    dists : iterable
        Vecteur des distances des droites. C&#39;est la seconde partie
        de la representation polaire des droites. (C&#39;est la plus courte
        distance entre l&#39;origine et tous les points constituant la droite.)
    axes_spots_ind : list
        Vecteur des ensembles de spots lies a chaque droites.
        On a ``len(axes_spots_ind) == nbr_d_axe_de_zones``.
    spots_axes_ind : list
        Vecteur des indices des droites passant par chaque spot.
        On a ``len(spots_axes_ind) == nbr_de_spots``.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; gnomonics = np.array(
    ... [[ 3.13651353e-01,  3.09226930e-01,  2.94649661e-01,  3.01913261e-01,
    ...    2.65658647e-01,  2.53744185e-01,  2.59687364e-01,  2.14474797e-01,
    ...    2.05701679e-01,  9.09550861e-02,  6.84629381e-02,  1.66859716e-01,
    ...    1.60926506e-01,  8.80179554e-02,  7.13057593e-02,  8.63905624e-02,
    ...    7.30837137e-02, -1.65674724e-02, -4.08478454e-02,  1.19812461e-03,
    ...   -1.81540363e-02, -7.28605017e-02,  7.98366740e-02, -2.69038416e-03,
    ...   -9.78478342e-02,  8.00240133e-03,  2.74614431e-03, -5.23754954e-03,
    ...   -1.16145127e-02, -2.47761104e-02, -3.26450653e-02, -5.55472001e-02,
    ...   -6.60679415e-02, -7.90777430e-02, -9.15642828e-02, -1.12629071e-01,
    ...   -6.06376082e-02, -1.27878949e-01, -1.63820893e-01, -1.87639564e-01,
    ...   -1.83578789e-01, -8.52464810e-02, -2.52354264e-01, -2.09580392e-01,
    ...   -1.17581628e-01, -1.22668095e-01, -1.73766926e-01, -2.07243070e-01,
    ...   -1.95010900e-01, -2.18700320e-01, -2.02279896e-01, -2.58101851e-01,
    ...   -2.74817050e-01, -2.12902710e-01, -2.19868407e-01, -2.24622726e-01,
    ...   -2.59554148e-01, -2.73386180e-01, -3.15663189e-01, -2.61830509e-01,
    ...   -2.71107376e-01, -2.63712078e-01, -2.69344717e-01, -2.66537964e-01,
    ...   -3.35108876e-01, -3.09192955e-01, -3.52482527e-01, -3.19909692e-01,
    ...   -3.14402401e-01, -3.22377235e-01, -3.29087257e-01, -3.43805134e-01,
    ...   -3.71652663e-01, -3.84382367e-01, -4.15039361e-01, -4.21311647e-01,
    ...   -4.27436978e-01, -4.30567324e-01],
    ...  [-4.40919399e-01, -3.70396405e-01,  3.96707416e-01,  1.17593547e-02,
    ...   -2.98925638e-01,  3.22567523e-01,  1.10948607e-02, -2.15068594e-01,
    ...    2.35642120e-01, -5.35671413e-01,  5.54859519e-01, -1.36278614e-01,
    ...    1.54246926e-01, -4.00430471e-01,  4.17484373e-01, -3.19116771e-01,
    ...    3.35176021e-01, -5.54156780e-01,  5.68944812e-01, -4.50160027e-01,
    ...    4.64025259e-01, -5.64013302e-01,  7.02395430e-03,  3.92187923e-01,
    ...    5.76627076e-01, -1.22935735e-01,  1.33947819e-01, -1.47039399e-01,
    ...    1.57771528e-01, -1.82383612e-01,  1.92295000e-01, -2.38321751e-01,
    ...    2.47572735e-01, -2.80969173e-01,  2.89397061e-01, -3.41624111e-01,
    ...    4.03913576e-03,  3.49186361e-01, -4.34728622e-01, -4.77657378e-01,
    ...    4.41173941e-01,  3.43652675e-03, -5.94909608e-01,  4.83771175e-01,
    ...   -1.12376906e-01,  1.18172102e-01,  1.64722977e-03, -2.51506448e-01,
    ...   -1.59108326e-01,  2.54048705e-01,  1.61634743e-01, -3.57992381e-01,
    ...    3.59640747e-01,  8.34673643e-04, -1.03698038e-01,  1.05036855e-01,
    ...   -2.98487246e-01,  2.99389601e-01, -4.20235783e-01, -1.99290574e-01,
    ...    1.99483901e-01, -1.19844824e-01,  1.19439557e-01, -4.03501937e-04,
    ...   -3.66618216e-01, -2.27829859e-01,  3.64764214e-01,  2.26117536e-01,
    ...   -1.36989250e-03, -1.41532809e-01,  1.38674900e-01, -1.92326447e-03,
    ...   -2.65554100e-01,  2.61379480e-01, -3.75563949e-01, -1.27799526e-01,
    ...    1.20914638e-01, -1.02077320e-01]])
    &gt;&gt;&gt; dmax = 0.01086181640625
    &gt;&gt;&gt; nbr = 7
    &gt;&gt;&gt; tol = 0.01758723266
    &gt;&gt;&gt; angles, dists, axes_spots_ind, spots_axes_ind = laue.atomic_find_zone_axes(
    ...     transformer, gnomonics, dmax, nbr, tol)
    &gt;&gt;&gt; len(angles), len(dists)
    (9, 9)
    &gt;&gt;&gt; for spots in axes_spots_ind:
    ...     print(sorted(spots))
    ...
    [1, 4, 7, 11, 22, 26, 28, 30, 32, 34, 37, 40, 43]
    [2, 5, 8, 12, 22, 25, 27, 29, 31, 33, 35, 38, 39, 42]
    [3, 6, 22, 36, 41, 46, 53, 63, 68, 71]
    [9, 10, 13, 14, 15, 16, 22]
    [9, 31, 44, 46, 55, 60, 66]
    [10, 23, 32, 45, 46, 54, 59, 64]
    [17, 35, 48, 54, 63, 70, 73]
    [18, 37, 50, 55, 63, 69, 72, 74]
    [42, 51, 52, 56, 57, 59, 60, 61, 62, 63]
    &gt;&gt;&gt; spots_axes_ind[0]
    set()
    &gt;&gt;&gt; sorted(spots_axes_ind[22])
    [0, 1, 2, 3]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.core.geometry.transformer import ind2comb

    # Recherches des axes de zone.
    angles, dists = transformer.hough_reduce(
        *transformer.hough(*gnomonics),
        nbr=nbr, tol=tol) # Recuperation des axes.
    if len(angles) &lt;= 1: # Si on a pas trouve suffisement de choses.
        return (), (), (), ((),)*gnomonics.shape[-1]

    # Attribution des points aux droites.
    axes_spots_ind = [set() for _ in range(len(angles))] # A chaque droite, c&#39;est les spots qu&#39;elle possede.
    spots_axes_ind = [set() for _ in range(gnomonics.shape[-1])]
    x_inters, y_inters = transformer.inter_lines(angles, dists)
    xg_spots, yg_spots = gnomonics

    ## Recuperation des points aux intersections.
    
    ### Calcul des points les plus proche pour chaque intersections.
    used_memory = len(x_inters)*len(xg_spots)*8 # Taille de la matrice de distance en octet.
    if psutil is not None and psutil.virtual_memory().available &gt; 2*used_memory:
        xg_spots_mesh, x_inters_mesh = np.meshgrid(xg_spots, x_inters, copy=False)
        yg_spots_mesh, y_inters_mesh = np.meshgrid(yg_spots, y_inters, copy=False)
        if numexpr is not None: # d[inter, gnomo]
            distances = numexpr.evaluate(
                &#34;sqrt((xg_spots_mesh-x_inters_mesh)**2 + (yg_spots_mesh-y_inters_mesh)**2)&#34;)
        else:
            distances = np.sqrt((xg_spots_mesh-x_inters_mesh)**2 + (yg_spots_mesh-y_inters_mesh)**2)
        nearest_spots = np.argmin(distances, axis=1) # Pour chaque intersections, son spot le plus proche.
        del distances, xg_spots_mesh, x_inters_mesh, yg_spots_mesh, y_inters_mesh
    else: # Si il n&#39;y a pas suffisement de RAM.
        nearest_spots = np.array([ # attention &#39;numexpr&#39; est 7 fois plus lent.
            np.argmin(np.sqrt((xg_spots-x_inter)**2 + (yg_spots-y_inter)**2))
            for x_inter, y_inter in zip(x_inters, y_inters)], dtype=int)

    ### Selection des bons candidats.
    spots_left = [] # Les spots non references.
    for spot_ind, (xg_pic, yg_pic) in enumerate(zip(xg_spots, yg_spots)):
        inters_cand = np.argwhere(nearest_spots == spot_ind)
        adds_inter = inters_cand[
            (x_inters[inters_cand]-xg_pic)**2
          + (y_inters[inters_cand]-yg_pic)**2
          &lt; dmax**2]
        if adds_inter.any():
            _adds_axes_1, _adds_axes_2 = ind2comb(adds_inter, n=len(angles))
            adds_axes = set(_adds_axes_1) | set(_adds_axes_2)
            for add_axis in adds_axes:
                axes_spots_ind[add_axis].add(spot_ind)
            spots_axes_ind[spot_ind].update(adds_axes) # f&#34;le spot num {spot_ind} est l&#39;intersections des axes {adds_axes}.&#34;
        else:
            spots_left.append(spot_ind)

    ## Recuperation des points colles a un seul axe.
    spots_left = np.array(spots_left, dtype=int) # Les indices des spots restants.

    used_memory = len(spots_left)*len(angles)*8 # Taille memoire de la matrice de distances.
    if psutil is not None and psutil.virtual_memory().available &gt; 2*used_memory:
        distances = transformer.dist_line( # d[line, point]
            angles, dists, xg_spots[spots_left], yg_spots[spots_left])
        axis_ind = np.argmin(distances, axis=0) # A chaque points, indice de la droite la plus proche.
        close_spots = distances.min(axis=0) &lt; dmax # La matrice des points suffisement proches.
        del distances
        for axis_ind, spot_left in zip(axis_ind[close_spots], spots_left[close_spots]):
            axes_spots_ind[axis_ind].add(spot_left)
            spots_axes_ind[spot_left].add(axis_ind)   
    else: # Si il n&#39;y a pas suffisement de RAM.
        for spot_left, xg_pic, yg_pic in zip(spots_left, xg_spots[spots_left], yg_spots[spots_left]):
            xg_pic, yg_pic = np.array([xg_pic], dtype=np.float32), np.array([yg_pic], dtype=np.float32)
            distances = transformer.dist_line(angles, dists, xg_pic, yg_pic) # d[line, point]
            axis_ind = np.argmin(distances[:, 0])
            if distances[axis_ind] &lt; dmax:
                axes_spots_ind[axis_ind].add(spot_left)
                spots_axes_ind[spot_left].add(axis_ind)

    # Suppression des axes qui contiennent pas suffisement de points.
    mask_axes_to_keep = np.array([len(spots_ind) for spots_ind in axes_spots_ind]) &gt;= nbr
    ind_axes_to_keep = set(np.argwhere(mask_axes_to_keep)[:, 0])
    spots_axes_ind = [axes_ind &amp; ind_axes_to_keep for axes_ind in spots_axes_ind]
    axes_spots_ind = [spots_ind for axis_ind, spots_ind
                     in enumerate(axes_spots_ind)
                     if axis_ind in ind_axes_to_keep]
    angles, dists = angles[mask_axes_to_keep], dists[mask_axes_to_keep]

    # Changement des anciens par les nouveaux indices de droites.
    old_to_new = {
        old_axis_ind: new_axis_ind
        for new_axis_ind, old_axis_ind
        in enumerate(sorted(set.union(*spots_axes_ind)))}
    spots_axes_ind = [
        {old_to_new[old_axis_ind] for old_axis_ind in old_axes_ind}
        for old_axes_ind in spots_axes_ind]

    return angles, dists, axes_spots_ind, spots_axes_ind</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laue.Experiment"><code class="flex name class">
<span>class <span class="ident">Experiment</span></span>
<span>(</span><span>images=(), *, config_file=None, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Permet de travailler sur un lot d'images. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>str, iterable</code></dt>
<dd>
<ul>
<li>Toutes les images qui constituent l'experience.</li>
<li>Peut prendre plein de forme differentes:<ul>
<li>Iterable d'images. Chaque elements peut prendre 2 formes:<ul>
<li>Le chemin de l'image (str) absolu ou relatif.</li>
<li>L'image elle meme, matrice 2d en uint16 (np.ndarray).<ul>
<li>Il vaut mieux donner le nom de l'image que l'image elle-meme
car la gestion de la RAM sera meilleur, surtout si il y a
un nombre important d'images ce qui saturerait la memoire.</li>
</ul>
</li>
</ul>
</li>
<li>Repertoire. Nom du dossier qui contient recursivement les images.</li>
<li>Glob expression. Par example "mon_dossier/*.tiff".</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>
<ul>
<li>Permet d'afficher ou non des informations suplementaires.<ul>
<li>0 or False =&gt; N'affiche rien du tout, ne pollue pas l'ecran.</li>
<li>1 or True =&gt; Affiche seulement les etapes principales.</li>
<li>2 =&gt; Affiche les resultats intermediaires.</li>
<li>3 =&gt; Affiche vraiment beaucoup de choses (pas tres lisible).</li>
<li>4 =&gt; Affiche aussi des choses graphiques en plus de
tous ce qui est dans le terminal.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>max_space</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Le nombre minimum de pixels qui separent 2 taches.
Quand des taches ne sont pas separes par cet intevalle,
elles se retrouvent aglomerees. La valeur par defaut de 5
permet d'avoir une recherche tres hexaustive.</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>
<ul>
<li>Seuil relatif par raport a l'ecart type de l'image sans fond.</li>
<li>Plus la valeur est grande, moins on capture de spots:<ul>
<li>3.5 =&gt; Prend enormement de spots, beaucoup de fausses detection.</li>
<li>5.1 =&gt; Bon compromis, reste sensible sans trop capturer le fond.</li>
<li>10 =&gt; Asser selectif, ne prend que les taches qui ressortent beaucoup.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>font_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Diametre de l'element structurant qui permet d'evaluer le fond par
une ouverture morphologique. La valeur par defaut est 21,
normalement cette valeur est bien, il faut pas y toucher.</dd>
<dt><strong><code>ignore_errors</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Permet d'ignorer certaine erreurs qui ne sont pas critiques.
La valeur par defaut et True.</dd>
<dt><strong><code>config_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Alias vers <code>**detector_parameters</code>.</dd>
<dt><strong><code>**detector_parameters</code></strong> :&ensp;<code>number</code></dt>
<dd>Les parametres de set_calibration de la camera deja connus.
Il servent dans la methode <code><a title="laue.experiment.base_experiment.Experiment.set_calibration" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.set_calibration">Experiment.set_calibration()</a></code>
a accelerer la recherche ou a la rendre plus precise.
Pour avoir le detail sur ces parametres, voir
<code><a title="laue.utilities.parsing.extract_parameters" href="utilities/parsing.html#laue.utilities.parsing.extract_parameters">extract_parameters()</a></code>.</dd>
<dt><strong><code>**bbox</code></strong> :&ensp;<code>number</code></dt>
<dd>Ce sont les limites min et max des parametres de set_calibration a ne pas depasser.
Les bornes minimum doivent etre precedes de '_min' et les maximum de '_max'.
Vous pouvez par example donner <code>Experiment(dd_min=90.0, dd_max=100.0)</code>.
Il sont utilises dans la methode <code><a title="laue.experiment.base_experiment.Experiment.set_calibration" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.set_calibration">Experiment.set_calibration()</a></code>.
Les noms possibles des parametres sont les meme que <code>**detector_parameters</code>
a l'exeption de <code>pixelsize, size, pxlsize et config_file</code> qui n'admettent
pas de bornes.
Les valeur par defaut sont:<pre><code>dd   : 60.0 mm          ; 80.0 mm
xbet : -0.9 degre       ; 0.9 degre
xgam : -0.9 degre       ; 0.9 degre
xcen : milieu - 150 pxl ; milieu + 150 pxl
ycen : milieu - 150 pxl ; milieu + 150 pxl
</code></pre>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Experiment:
    &#34;&#34;&#34;
    ** Permet de travailler sur un lot d&#39;images. **
    &#34;&#34;&#34;
    def __init__(self, images=(), *, config_file=None, verbose=False, **kwargs):
        &#34;&#34;&#34;
        Parameters
        ----------
        images : str, iterable
            - Toutes les images qui constituent l&#39;experience.
            - Peut prendre plein de forme differentes:
                - Iterable d&#39;images. Chaque elements peut prendre 2 formes:
                    - Le chemin de l&#39;image (str) absolu ou relatif.
                    - L&#39;image elle meme, matrice 2d en uint16 (np.ndarray).
                        - Il vaut mieux donner le nom de l&#39;image que l&#39;image elle-meme
                        car la gestion de la RAM sera meilleur, surtout si il y a
                        un nombre important d&#39;images ce qui saturerait la memoire.
                - Repertoire. Nom du dossier qui contient recursivement les images.
                - Glob expression. Par example &#34;mon_dossier/*.tiff&#34;.
        verbose : int, optional
            * Permet d&#39;afficher ou non des informations suplementaires.
                - 0 or False =&gt; N&#39;affiche rien du tout, ne pollue pas l&#39;ecran.
                - 1 or True =&gt; Affiche seulement les etapes principales.
                - 2 =&gt; Affiche les resultats intermediaires.
                - 3 =&gt; Affiche vraiment beaucoup de choses (pas tres lisible).
                - 4 =&gt; Affiche aussi des choses graphiques en plus de
                    tous ce qui est dans le terminal.

        max_space : int, optional
            Le nombre minimum de pixels qui separent 2 taches.
            Quand des taches ne sont pas separes par cet intevalle,
            elles se retrouvent aglomerees. La valeur par defaut de 5
            permet d&#39;avoir une recherche tres hexaustive.
        threshold : float, optional
            - Seuil relatif par raport a l&#39;ecart type de l&#39;image sans fond.
            - Plus la valeur est grande, moins on capture de spots:
                - 3.5 =&gt; Prend enormement de spots, beaucoup de fausses detection.
                - 5.1 =&gt; Bon compromis, reste sensible sans trop capturer le fond.
                - 10 =&gt; Asser selectif, ne prend que les taches qui ressortent beaucoup.
        font_size : int, optional
            Diametre de l&#39;element structurant qui permet d&#39;evaluer le fond par
            une ouverture morphologique. La valeur par defaut est 21,
            normalement cette valeur est bien, il faut pas y toucher.
        ignore_errors : boolean, optional
            Permet d&#39;ignorer certaine erreurs qui ne sont pas critiques.
            La valeur par defaut et True.
        config_file : str, optional
            Alias vers ``**detector_parameters``.
        **detector_parameters : number
            Les parametres de set_calibration de la camera deja connus.
            Il servent dans la methode ``laue.experiment.base_experiment.Experiment.set_calibration``
            a accelerer la recherche ou a la rendre plus precise.
            Pour avoir le detail sur ces parametres, voir
            ``laue.utilities.parsing.extract_parameters``.
        **bbox : number
            Ce sont les limites min et max des parametres de set_calibration a ne pas depasser.
            Les bornes minimum doivent etre precedes de &#39;_min&#39; et les maximum de &#39;_max&#39;.
            Vous pouvez par example donner ``Experiment(dd_min=90.0, dd_max=100.0)``.
            Il sont utilises dans la methode ``laue.experiment.base_experiment.Experiment.set_calibration``.
            Les noms possibles des parametres sont les meme que ``**detector_parameters``
            a l&#39;exeption de ``pixelsize, size, pxlsize et config_file`` qui n&#39;admettent
            pas de bornes.
            Les valeur par defaut sont:

                dd   : 60.0 mm          ; 80.0 mm
                xbet : -0.9 degre       ; 0.9 degre
                xgam : -0.9 degre       ; 0.9 degre
                xcen : milieu - 150 pxl ; milieu + 150 pxl
                ycen : milieu - 150 pxl ; milieu + 150 pxl
        &#34;&#34;&#34;
        assert hasattr(images, &#34;__iter__&#34;), (&#34;&#39;images&#39; must to be iterable. &#34;
            f&#34;It can not be of type {type(images).__name__}.&#34;)
        assert isinstance(verbose, int), f&#34;&#39;verbose&#39; has to be int, not {type(verbose).__name__}.&#34;
        
        max_space = kwargs.get(&#34;max_space&#34;, 5)
        assert isinstance(max_space, int), &#34;&#39;max_space&#39; has to be an integer, not a %s.&#34; \
            % type(max_space).__name__
        assert max_space &gt;= 1, f&#34;&#39;max_space&#39; has to be positive. His value is &#39;{max_space}&#39;.&#34;
        threshold = kwargs.get(&#34;threshold&#34;, 5.1)
        assert isinstance(threshold, float), \
            f&#34;&#39;threshold&#39; has to be float, not a {type(threshold).__name__}.&#34;
        assert 2.0 &lt; threshold &lt; 80.0, \
            f&#34;Le seuil doit etre compris entre 2 et 50, il vaut &#39;{threshold}&#39;.&#34;
        font_size = kwargs.get(&#34;font_size&#34;, 21)
        assert isinstance(font_size, int), \
            f&#34;&#39;font_size&#39; has to be an integer, not a {type(font_size).__name__}.&#34;
        assert font_size &gt;= 2, (&#34;&#39;font_size&#39; doit etre superieur a 1. &#34;
            f&#34;Il ne peut pas valoir {font_size}.&#34;)
        ignore_errors = kwargs.get(&#34;ignore_errors&#34;, True)
        assert isinstance(ignore_errors, bool), \
            f&#34;&#39;ignore_errors&#39; has to be a boolean, not a {type(ignore_errors).__name__}.&#34;

        if config_file is not None:
            kwargs[&#34;config_file&#34;] = config_file

        self._images = images

        self.verbose = verbose
        self.max_space = max_space
        self.threshold = threshold
        self.font_size = font_size
        self.ignore_errors = ignore_errors
        self.kwargs = kwargs

        # Precalul des constantes.
        self.kernel_font = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (self.font_size, self.font_size))
        self.kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (self.max_space, self.max_space))
        self.transformer = transformer.Transformer() # Outil permetant de faire les transformations geometriques.

        # Declaration des attributs interne de memoire.
        self._len = None # Nombre de diagrames lues.
        self._buff_diags = [] # La liste ordonnee des diagrames lus.

        self._mean_bg = None # Fond diffus estime par la moyenne de toutes les images.
        self._shape = None # Les dimensions des matrices des images xy.
        self._calibration_parameters = None # Le dictionaire des parametres geometrique de la camera.
        self._gnomonic_matrix = None # Les matrices de transformation.

        self._images_iterator = None # Iterateur unique des informations des images.
        self._diagrams_iterator = None # Iterateur unique qui genere les diagrammes.
        self._axes_iterator = None # Iterateur unique qui cede les axes de zonne de chaque diagramme.
        self._subsets_iterator = None # Iterateur unique qui cede les bouts de grains.

    def set_calibration(self, *diagrams):
        &#34;&#34;&#34;
        ** Calibration de la camera. **

        Notes
        -----
        * Ne nessecite aucune connaissances prealable sur le christal.
        * Il n&#39;y a pas besoin d&#39;avoir un diagramme bien calibre, il se debrouille tout seul.
        * Cette fonction peut parfois etre lente (plusieur minutes)!
        * Si vous connaissez les parametres, fournissez-les, ca ira plus vite!
        * Si cette methode a deja ete appelee une fois, elle retourne
            immeditement le resultat sans refaire les calculs.

        Parameters
        ----------
        *diagrams : optional
            Les ou le diagramme.s qui vont servir a faire la calibration.
            Si aucun diagramme n&#39;est precise, cette methode recherche par elle meme
            les diagrammes qu&#39;elle trouve convaincant parmis ceux qui sont disponibles.
            Il doivent etre de type ``laue.diagram.LaueDiagram``.

        Returns
        -------
        dict 
            Le dictionaire qui a chaque non de parametre, associe sa valeur numerique.
            Les clefs sont les suivantes: &#34;dd&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;xbet&#34;, &#34;xgam&#34; and &#34;pixelsize&#34;

        Raises
        ------
        KeyError
            Si l&#39;utilisateur n&#39;a pas precise les parametres vraiment indispenssables.
        ValueError
            Si il y a des incoherences dans les parametres.

        Example
        -------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(image, dd_min=69.5, dd_max=71.5, xbet=0.008)
        &gt;&gt;&gt; parameters = experiment.set_calibration()
        &gt;&gt;&gt; sorted(parameters.keys())
        [&#39;dd&#39;, &#39;pixelsize&#39;, &#39;xbet&#39;, &#39;xcen&#39;, &#39;xgam&#39;, &#39;ycen&#39;]
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self._calibration_parameters is not None: # Si on peut retourner directement,
            return self._calibration_parameters # on ne s&#39;en prive pas.

        assert all(isinstance(diag, LaueDiagram) for diag in diagrams), \
            &#34;Tous les diagrammes doivent etre de type &#39;LaueDiagram&#39;. Or ce n&#39;est pas le cas.&#34;

        if self.verbose:
            print(&#34;Calibration...&#34;)
            if self.verbose &gt;= 2:
                print(&#34;\tPrise en compte des parametres fournis...&#34;)

        # Constantes.
        PIXELSIZE_REF = {(2048, 2048): 0.079856, # Taille des pixels fonction de la camera.
                         (2018, 2016): 0.0734,
                         (2594, 2748): 0.031}
        PARAM_SET = {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;} # Les parametres non deductibles.
        PARAM_MIN = {&#34;dd&#34;: 60.0, # Les bornes minimale par defaut.
                     &#34;xbet&#34;: -.9,
                     &#34;xgam&#34;: -.9,
                     &#34;xcen&#34;: self.get_images_shape()[0]/2 - 150,
                     &#34;ycen&#34;: self.get_images_shape()[0]/2 - 150}
        PARAM_MAX = {&#34;dd&#34;: 80.0, # Les bornes maximales par defaut.
                     &#34;xbet&#34;: .9,
                     &#34;xgam&#34;: .9,
                     &#34;xcen&#34;: self.get_images_shape()[0]/2 + 150,
                     &#34;ycen&#34;: self.get_images_shape()[1]/2 + 150}

        # Recuperation des parametres fournis et deductibles.
        from laue.utilities.parsing import extract_parameters
        given_parameters = extract_parameters(ignore_missing=True, **self.kwargs)
        if (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() in PIXELSIZE_REF):
            given_parameters[&#34;pixelsize&#34;] = PIXELSIZE_REF[self.get_images_shape()]
        
        elif (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() not in PIXELSIZE_REF):
            raise KeyError(&#34;Vous devez fournir le parametre &#39;pixelsize&#39;.\n&#34;
                f&#34;Les images font {self.get_images_shape()} pxl**2. &#34;
                f&#34;Or, seul les &#39;pixelsize&#39; des images {&#39; et &#39;.join(map(str, PIXELSIZE_REF))} sont connus.&#34;)

        # Recuperation des bornes.
        given_min = extract_parameters(ignore_missing=True, **{
            param[:-4]: value
            for param, value in self.kwargs.items()
            if param.endswith(&#34;_min&#34;) and len(param) &gt; 4})
        given_max = extract_parameters(ignore_missing=True, **{
            param[:-4]: value
            for param, value in self.kwargs.items()
            if param.endswith(&#34;_max&#34;) and len(param) &gt; 4})
        parameters_min = {param: given_min.get(param, PARAM_MIN[param]) for param in PARAM_SET}
        parameters_max = {param: given_max.get(param, PARAM_MAX[param]) for param in PARAM_SET}
        
        for param in PARAM_SET: # Verification de la coherence des bornes.
            if parameters_min[param] &gt;= parameters_max[param]:
                raise ValueError(f&#34;Les bornes du parametre {repr(param)} sont inversees, &#34;
                    f&#34;{param}_min={parameters_min[param]} et {param}_max={parameters_max[param]}.&#34;)

        # Valeur de departs des parametres.
        initial_parameters = { # Ce sont les parametres initiaux pour la descente de gradient.
            par: given_parameters.get(par,
                .5*(parameters_min[par] + parameters_max[par]))
            for par in PARAM_SET}
       
        for par, val in initial_parameters.items(): # Verification.
            if par in given_parameters and par in given_min:
                if given_parameters[par] &lt; given_min[par]:
                    raise ValueError(f&#34;Vous avez imposes {par}_min={given_min[par]} &#34;
                        f&#34;et en meme temp vous avez donnes {par}={val}!&#34;)
            if par in given_parameters and par in given_max:
                if given_parameters[par] &gt; given_max[par]:
                    raise ValueError(f&#34;Vous avez imposes {par}_max={given_max[par]} &#34;
                        f&#34;et en meme temps vous avez donnes {par}={val}!&#34;)

        # Parametres restants.
        unknown_parameters = PARAM_SET - set(given_parameters)
        if not unknown_parameters: # Si Il n&#39;y a rien a calculer.
            self._calibration_parameters = given_parameters
            self.transformer.compile(self._calibration_parameters) # Juste pour l&#39;optimisation.
            if self.verbose:
                if self.verbose &gt;= 2:
                    print(&#34;\t\tOK: Tout est fournis, il n&#39;y a rien a faire.&#34;)
                print(f&#34;\tOK: Calibration terminee: {given_parameters}&#34;)
            return self._calibration_parameters

        # Extraction d&#39;un diagramme interressant.
        if self.verbose &gt;= 2:
            print(&#34;\tRecuperation des diagrammes interressants...&#34;)
        if not diagrams: # Si l&#39;utilisateur ne nous aide pas a trouver les bons diagrammes.
            diagrams = []
            for i, dia in enumerate(self):
                if i &gt; 60: # On ne s&#39;interesse qu&#39;a la premiere minute.
                    break
                diagrams.append(dia)
            best_diagrams = [sorted(diagrams, key=lambda dia: dia.get_quality(), reverse=True).pop()]
        else: # Si l&#39;utilisateur nous en fournit.
            best_diagrams = diagrams # C&#39;est un tuple et non pas une liste mais c&#39;est pas genant.
        if self.verbose &gt;= 2:
            for dia in best_diagrams:
                print(f&#34;\t\t{dia.get_id()}&#34;)

        # Vectorisation des donnees pour de bonnes perfs.
        min_size = min(
            200,
            min(len(dia) for dia in best_diagrams)
            ) # Le plus petit nombre de points.
        spots_position = np.array(
            [dia.get_positions(n=min_size, sort=&#34;quality&#34;)
             for dia in best_diagrams],
            dtype=np.float32)
        spots_position = np.swapaxes(spots_position, 0, 1) # shape: (2, n_diagrams, nbr_spots)

        # Perparations des parametres pour la suite.
        vect_labels = tuple(unknown_parameters) # On recupere les nom des parametres inconus seulement.
        bounds = [(parameters_min[name], parameters_max[name]) for name in vect_labels] # Les limites des variables.
        args = (given_parameters, vect_labels, spots_position) # Les arguments en plus de la fonction de cout.
        if self.verbose &gt;= 2:
            print(f&#34;\tcalibration des parametres {vect_labels}&#34;)
            print(f&#34;\tbornes min: {tuple(b_min for b_min, _ in bounds)}&#34;)
            print(f&#34;\tbornes max: {tuple(b_max for _, b_max in bounds)}&#34;)
        
        # Recherche rapide d&#39;un minimum par descente de gradient.
        from scipy import optimize # On ne l&#39;importe que ici car on est pas sur de s&#39;en servir.
        if self.verbose &gt;= 2:
            print(&#34;\tOptimsation globale, algo genetique...&#34;)
        
        if multiprocessing.current_process().name == &#34;MainProcess&#34; and os.cpu_count() &gt; 4:
            attrs = [&#34;transformer&#34;, &#34;verbose&#34;]
            self_bis = collections.namedtuple(&#34;PartialExperiment&#34;, attrs, defaults=[getattr(self, attr) for attr in attrs])()
            opt_res = optimize.differential_evolution(
                _Picklable(cloudpickle.dumps(self_bis), Experiment._calibration_cost,
                    {name: val for name, val in zip((&#34;known_params&#34;, &#34;vect_labels&#34;, &#34;spots_position&#34;), args)}
                    ),
                updating=&#34;deferred&#34;,
                bounds=bounds,
                disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
                polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
                popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
                workers=-1) # Pour utiliser tous les cpus.
        else:
            opt_res = optimize.differential_evolution(
                self._calibration_cost,
                bounds=bounds,
                args=args,
                disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
                polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
                popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
                workers=1) # Pour ne pas creer de sous processus.
                # C&#39;est plus rapide de ne pas creer de sous processus que d&#39;en faire... car cloudpickle est lent!
        if self.verbose &gt;= 2:
            print(f&#34;\t\tOk: cout final = {opt_res[&#39;fun&#39;]}&#34;)
        fit_parameters_vect = opt_res[&#34;x&#34;]
        
        # Mise en forme du resultat.
        fit_parameters = {name: fit_parameters_vect[i] for i, name in enumerate(vect_labels)}
        self._calibration_parameters = {**given_parameters, **fit_parameters}
        self.transformer.compile(self._calibration_parameters) # Juste pour l&#39;optimisation.
        if self.verbose:
            print(f&#34;\tOK: set_calibration terminee: {self._calibration_parameters}&#34;)
        return self._calibration_parameters

    def _calibration_cost(self, params_as_vect, known_params, vect_labels, spots_position):
        &#34;&#34;&#34;
        ** Help for ``set_calibration``. **

        Parameters
        ----------
        params_as_vect : np.ndarray
            Le vecteur des valeurs inconues de parametres.
        :param known_params : dict
            Dictionaire des parametres connus.
        :param vect_labels : tuple
            Le tuple des nom des parametres associes au vecteur.
        spots_position : np.ndarray
            Coordonnees des points x, y des diagrammes de reference.
            shape = (2, n_diagrams, nbr_spots)
        &#34;&#34;&#34;
        # Projection gnomonique.
        _, n_diagrams, nbr_spots = spots_position.shape
        unknown_parameters = {name: value for name, value in zip(vect_labels, params_as_vect)}
        parameters = {**unknown_parameters, **known_params}
        gnom_spots_x, gnom_spots_y = self.transformer.cam_to_gnomonic(*spots_position, parameters) # shape: (n_diagrams, nbr_pic)

        # Recherche des axes de zones intensifs.
        gnom_spots_x = ((gnom_spots_x
                        - np.repeat(gnom_spots_x.mean(axis=-1)[..., np.newaxis], nbr_spots, axis=-1)
                        ) / np.repeat(gnom_spots_x.std(axis=-1)[..., np.newaxis], nbr_spots, axis=-1))
        gnom_spots_y = ((gnom_spots_y
                        - np.repeat(gnom_spots_y.mean(axis=-1)[..., np.newaxis], nbr_spots, axis=-1)
                        ) / np.repeat(gnom_spots_y.std(axis=-1)[..., np.newaxis], nbr_spots, axis=-1))
        thetas, dists = self.transformer.hough(gnom_spots_x, gnom_spots_y) # shape: (n_diagrams, nbr_pic*(nbr_pic-1)/2)
        clusters = self.transformer.hough_reduce(thetas, dists, # shape: (n_diagrams,)
            nbr=6, tol=0.035) # On prend des qu&#39;il y a 6 points environ allignes.

        # Calcul de l&#39;erreur.
        projection = np.mean([np.log(1 + self.transformer.dist_line( # compris generalement entre [0.007, 0.3]
                                clusters[i][0, :], clusters[i][1, :],
                                gnom_spots_x[i, :], gnom_spots_y[i, :]).min(axis=0, initial=1.0)).mean()
                              if clusters[i].shape[-1] else 1.0 # Si il n&#39;y a pas de droite, c&#39;est qu&#39;on est dans les choux.
                            for i in range(n_diagrams)]) # Moyenne des ecarts des projetes des points sur la droite la plus proche.
        scattering = np.mean([np.log(
                                    (gnom_spots_x[i, :] - gnom_spots_x[i, :].mean())**2
                                  + (gnom_spots_y[i, :] - gnom_spots_y[i, :].mean())**2
                                  + 1)
                            for i in range(n_diagrams)]) # Eparpillement [0.1, 0.95], &gt; =&gt; bien eparpille
        cost = projection * scattering**(-4)

        if self.verbose &gt;= 3:
            print(f&#34;\t\tCurrent parameters: {unknown_parameters}&#34;)
            print(f&#34;\t\tCurrent cost: {cost}&#34;)
            if self.verbose &gt;= 4:
                import matplotlib.pyplot as plt
                plt.clf()
                for i in range(n_diagrams):
                    plt.subplot(n_diagrams, 3, 1 + 3*i)
                    plt.title(f&#34;diagramme {i+1}, plan camera&#34;)
                    plt.scatter(spots_position[0, i, ...], spots_position[1, i, ...])

                    plt.subplot(n_diagrams, 3, 2 + 3*i)
                    plt.title(f&#34;diagramme {i+1}, plan gnomonic&#34;)
                    plt.scatter(gnom_spots_x[i, :], gnom_spots_y[i, :])
                    for angle, dist in clusters[i].transpose():
                        v = np.array([np.cos(angle), np.sin(angle)])
                        u = np.array([np.sin(angle), -np.cos(angle)])
                        p = dist*v
                        plt.axline(p, p+u, lw=0.5, color=&#34;r&#34;)

                    plt.subplot(n_diagrams, 3, 3 + 3*i)
                    plt.title(f&#34;diagramme {i+1}, hough&#34;)
                    plt.scatter(thetas[i, :], dists[i, :])
                    plt.scatter(clusters[i][0], clusters[i][1])
                plt.draw()
                plt.pause(1e-6)

        return cost

    def get_diagrams(self, *, tense_flow=False):
        &#34;&#34;&#34;
        ** Genere les diagrammes de l&#39;experience. **

        Notes
        -----
        * Performances:
            * Sur un PC (intel core i7, ssd, 8 coeurs), met environ 37 ms/diagramme.
            * Sur un PC (intel centrino, hdd, 2 coeurs), met environ 530 ms/diagramme.

        Parameters
        ----------
        tense_flow : boolean
            * True : Permet de travailler a flux tendu, c&#39;est a dire
            de cede les diagrammes au fur a meusure qu&#39;ils sont crees.
                * Le generateur termine quand toutes les images sont lues ou
                que le generateur d&#39;images leve un ``StopIteration``.
                * A chaque nouvel appel de cette methode, l&#39;iteration
                recommence a partir du debut et l&#39;ordre reste inchange.
                * Equivalent a ``laue.experiment.base_experiment.Experiment.__iter__``.
            * False. Sinon, attend que tous les diagrammes
            soient lues afin de tout renvoyer en meme temps.

        Returns
        -------
        list
            La liste des diagrammes de type ``laue.diagram.LaueDiagram``.

        Yields
        ------
        laue.diagram.LaueDiagram
            * Chaque diagram extrait au fur a mesure qu&#39;il arrive.
            * L&#39;ordre est concerve pour chaque appel de cette methode a flux tendu.
            * A chaque appel on repars du debut, meme si un autre appel n&#39;est pas termine.
            * Les sections critiques sont verouillees donc cette methode supporte le multithread.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(images)
        &gt;&gt;&gt;
        &gt;&gt;&gt; diagrams = experiment.get_diagrams()
        &gt;&gt;&gt; type(diagrams)
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(diagrams.pop())
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def update_len(func):
            &#34;&#34;&#34;
            Tient a jour la longueur de l&#39;experience.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                for i, element in enumerate(func(*func_args, **func_kwargs)):
                    yield element
                self._len = i + 1

            return decorate

        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Extraction des diagrammes...&#34;)

                for i, diag in enumerate(func(*func_args, **func_kwargs)):
                    if self.verbose &gt;= 2:
                        print(f&#34;\tdiagramme num {i} extrait: &#34;
                              f&#34;(...{diag.get_id()[-20:]}) &#34;
                              f&#34;avec {len(diag)} spots&#34;)
                    yield diag
                if self.verbose:
                    print(&#34;\tOK: Tous les diagrammes sont extraits.&#34;)
            
            return decorate

        @update_len
        @show_iterator_state
        def _diagram_extractor(self):
            &#34;&#34;&#34;
            Premiere vraie lecture. Cede les diagrammes.
            &#34;&#34;&#34;
            if multiprocessing.current_process().name == &#34;MainProcess&#34;:
                attrs = [&#34;kernel_font&#34;, &#34;threshold&#34;, &#34;kernel_dilate&#34;]
                mini_self = collections.namedtuple(&#34;SelfCopy&#34;, attrs)(
                    *(getattr(self, attr) for attr in attrs)
                    ) # Strategie car &#39;pickle&#39; ne sais pas faire ca.
                ser_self = cloudpickle.dumps(mini_self)

                from laue.utilities.multi_core import pickleable_method
                from laue.utilities.multi_core import limited_imap
                with multiprocessing.Pool() as pool:
                    yield from (
                        self._help_get_diagrams(name, image, spot_args=spot_args)
                        for (name, image, spot_args) in limited_imap(pool,
                            pickleable_method,
                            (
                                (
                                    Experiment._help_get_diagrams,
                                    ser_self,
                                    {&#34;name&#34;:name, &#34;image&#34;:image, &#34;thread&#34;:True}
                                )
                                for name, image in self.read_images()
                            )
                        )
                    )
            else:
                yield from (self._help_get_diagrams(name, image)
                    for name, image in self.read_images())
        
        if self._diagrams_iterator is None:
            self._diagrams_iterator = iter(_diagram_extractor(self))

        from laue.utilities.multi_core import RecallingIterator
        return (
            (lambda x: (yield from x))(RecallingIterator(self._diagrams_iterator, mother=self))
            if tense_flow else list(RecallingIterator(self._diagrams_iterator, mother=self)))

    def _help_get_diagrams(self, name, image, thread=False, spot_args=None):
        &#34;&#34;&#34;
        ** Comme ``laue.experiment.base_experiment.Experiment.get_diagrams`` pour une seule image. **

        * Cette methode n&#39;est utile qu&#39;a fin de parallelisation.
        * Elle ne doit pas etre appelle par l&#39;utilisateur.
        * Cette methode est indirectement appelle par self.get_diagrams().
        * Il n&#39;y a pas de verifications pour une histoire de performance.

        :retrun: Le diagramme de Laue correspondant.
        :rtype: LaueDiagram
        &#34;&#34;&#34;
        if isinstance(self, bytes):
            self = cloudpickle.loads(self)

        if spot_args is None:
            # Binarisation de l&#39;image.
            bg_image = cv2.morphologyEx(image, cv2.MORPH_OPEN, self.kernel_font, iterations=1)
            fg_image = image - bg_image
            thresh_image = (fg_image &gt; self.threshold*fg_image.std()).astype(np.uint8)
            dilated_image = cv2.dilate(thresh_image, self.kernel_dilate, iterations=1)

            # Detection des contours grossiers.
            outlines, _ = cv2.findContours(dilated_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            bbox = [cv2.boundingRect(outl) for outl in outlines]

            # Calcul des distortions.
            distortions_open = (2*np.sqrt(np.pi)) / np.array([
                cv2.arcLength(outl, True)/np.sqrt(cv2.contourArea(outl))
                for outl in outlines])

            # Preparations des arguments des spot.
            spot_args = [((x, y, w, h), fg_image[y:y+h, x:x+w], dis)
                for dis, (x, y, w, h) in zip(distortions_open, bbox)]

        if thread:
            if (not os.path.exists(name)) or (psutil is not None and psutil.virtual_memory().percent &lt; 50):
                return (name, image, spot_args)
            return (name, None, spot_args)

        # Mise en forme du resultat.
        if image is not None and (
                (not os.path.exists(name)) or (psutil is not None and psutil.virtual_memory().percent &lt; 50)
                ):
            laue_diagram = LaueDiagram(name, None, experiment=self, image_xy=image)
        else:
            laue_diagram = LaueDiagram(name, None, experiment=self)

        # Creation des ensembles de spots.
        spots_open = [Spot(bbox=bbox, spot_im=spot_im, distortion=distortion, diagram=laue_diagram, identifier=i)
                     for i, (bbox, spot_im, distortion) in enumerate(spot_args)]
        laue_diagram.spots = spots_open

        return laue_diagram

    def find_subsets(self, *, tense_flow=False, **kwds):
        &#34;&#34;&#34;
        ** Estime les grains dans chaque diagrame. **

        Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_subsets``.
        Le resultat est le meme que: ``[diag.find_subsets(**kwds) for diag in self]``

        Notes
        -----
        * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.
        
        Parameters
        ----------
        tense_flow : boolean
            * True : Permet de travailler a flux tendu, c&#39;est a dire
            de ceder les bouts de grains des diagrammes au fur a meusure qu&#39;ils sont trouves.
                * Le generateur termine quand toutes les images sont lues ou
                que le generateur d&#39;images leve un ``StopIteration``.
                * A chaque nouvel appel de cette methode, l&#39;iteration
                recommence a partir du debut et l&#39;ordre reste inchange.
                * Equivalent a ``(diag.find_subsets(**kwds) for diag in self)``.
            * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
                * C&#39;est equvalent a ``[diag.find_subsets(**kwds) for diag in self]``.
                * Au lieu de retourner un generateur, retourne une liste.
        **kwds
            Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_subsets``.

        Returns
        -------
        list
            Pour chaque diagramme de cette experience, cede une estimation des grains.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(experiment.find_subsets())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(experiment.find_subsets(tense_flow=True))
        &lt;class &#39;generator&#39;&gt;
        &gt;&gt;&gt; type(next(iter(experiment.find_subsets(tense_flow=True))))
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Estimation des grains...&#34;)
                
                for i, groups in enumerate(func(*func_args, **func_kwargs)):
                    if self.verbose &gt;= 2:
                        print(f&#34;\tgrain du diagramme num {i} estimes: il y a {len(groups)} clusters&#34;)
                    yield groups

                if self.verbose:
                    print(&#34;\tOK: Tous les clusters de grains sont estimes.&#34;)

            return decorate

        @show_iterator_state
        def _subsets_extractor(self):
            if multiprocessing.current_process().name == &#34;MainProcess&#34;:
                from laue.core.subsets import _pickelable as atomic_find_subsets
                from laue.utilities.multi_core import limited_imap
                with multiprocessing.Pool() as pool:
                    yield from (
                        diag.find_subsets(_atomic_subsets_res=args)
                        for diag, args
                        in zip(
                            self,
                            limited_imap(pool,
                                atomic_find_subsets,
                                (   # transformer, gnomonics, dmax, nbr, tol
                                    diag.find_subsets(**kwds, _get_args=True)
                                    for diag in self
                                )
                            )
                        )
                    )
            else:
                yield from (diag.find_subsets(**kwds) for diag in self)

        if not tense_flow:
            return list(self.find_subsets(tense_flow=True, **kwds))

        if self._subsets_iterator is None:
            self._subsets_iterator = iter(_subsets_extractor(self))

        from laue.utilities.multi_core import RecallingIterator
        return (lambda x: (yield from x))(RecallingIterator(self._subsets_iterator, mother=self))

    def find_zone_axes(self, *, tense_flow=False, **kwds):
        &#34;&#34;&#34;
        ** Recherche l&#39;ensemble des axes de zones. **

        Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_zone_axes``.
        Le resultat est le meme que: ``[diag.find_zone_axes(**kwds) for diag in self]``

        Notes
        -----
        * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.

        Parameters
        ----------
        tense_flow : boolean
            * True : Permet de travailler a flux tendu, c&#39;est a dire
            de ceder les axes des diagrammes au fur a meusure qu&#39;ils sont trouves.
                * Le generateur termine quand toutes les images sont lues ou
                que le generateur d&#39;images leve un ``StopIteration``.
                * A chaque nouvel appel de cette methode, l&#39;iteration
                recommence a partir du debut et l&#39;ordre reste inchange.
                * Equivalent a ``(diag.find_zone_axes(**kwds) for diag in self)``.
            * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
                * C&#39;est equvalent a ``[diag.find_zone_axes(**kwds) for diag in self]``.
                * Au lieu de retourner un generateur, retourne une liste.
        **kwds
            Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_zone_axes``.

        Returns
        -------
        list
            Pour chaque diagramme de cette experience, cede la liste
            des axes de zones du diagramme. Les elements de l&#39;ensemble
            sont de type ``laue.zone_axis.ZoneAxis``.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(experiment.find_zone_axes())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(experiment.find_zone_axes(tense_flow=True))
        &lt;class &#39;generator&#39;&gt;
        &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))))
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))).pop())
        &lt;class &#39;laue.zone_axis.ZoneAxis&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Extraction des axes de zone...&#34;)
                
                for i, axes in enumerate(func(*func_args, **func_kwargs)):
                    if self.verbose &gt;= 2:
                        print(f&#34;\taxes du diagramme num {i} trouves: il y en a {len(axes)}&#34;)
                    yield axes

                if self.verbose:
                    print(&#34;\tOK: Tous les axes de zone sont extraits.&#34;)

            return decorate

        @show_iterator_state
        def _axes_extractor(self):
            &#34;&#34;&#34;
            Premiere vraie extraction.
            &#34;&#34;&#34;
            if multiprocessing.current_process().name == &#34;MainProcess&#34;:
                # Compilation et serialisation des equations.
                self.transformer.compile()
                self.set_calibration()
                transformer_ser = cloudpickle.dumps(self.transformer)

                # Parallelisation des fils.
                from laue.core.zone_axes import _get_zone_axes_pickle
                from laue.utilities.multi_core import limited_imap
                with multiprocessing.Pool() as pool:
                    yield from (
                        diag.find_zone_axes(_axes_args=args)
                        for diag, args
                        in zip(
                            self,
                            limited_imap(pool,
                                _get_zone_axes_pickle,
                                ( # transformer, gnomonics, dmax, nbr, tol
                                    (transformer_ser, *diag.find_zone_axes(**kwds, _get_args=True))
                                    for diag in self
                                )
                            )
                        )
                    )

            else:
                yield from (diag.find_zone_axes(**kwds) for diag in self)

        if not tense_flow:
            return list(self.find_zone_axes(tense_flow=True, **kwds))

        if self._axes_iterator is None:
            self._axes_iterator = iter(_axes_extractor(self))

        from laue.utilities.multi_core import RecallingIterator
        return (lambda x: (yield from x))(RecallingIterator(self._axes_iterator, mother=self))

    def _get_gnomonic_matrix(self):
        &#34;&#34;&#34;
        ** Calcul les matrices de transformation gnomonic **

        Notes
        -----
        * Permet via ``cv2`` d&#39;avoir une image dans le plan gnomonic.
        * Les tailles des image sont le meme dans le plan
        de la camera et dans le plan gnommonic.

        Returns
        -------
        np.ndarray(np.float32) : map_x
            La premiere matrice que l&#39;on peut voir comme une fonction
            de ``f(x_gnomon, y_gnomon) -&gt; x_camera``, avec les coordonnees
            gnomonique exprimees en pxl.
        np.ndarray(np.float32) : map_y
            La seconde matrice ``f(x_gnomon, y_gnomon) -&gt; y_camera``
        tuple : bornes
            Les limite en mm des pixel extremes:
            (xmin, xmax, ymin, ymax)
        &#34;&#34;&#34;
        if self._gnomonic_matrix is not None:
            return self._gnomonic_matrix

        if self.verbose:
            print(&#34;Recuperation de la matrice gnomonic...&#34;)
        # Recherche des bornes.
        x_max, y_max = self.get_images_shape()
        xg, yg = self.transformer.cam_to_gnomonic(
            *np.meshgrid(np.arange(x_max), np.arange(y_max), copy=False),
            self.set_calibration())
        bornes = (xg.min(), xg.max(), yg.min(), yg.max())
        
        del xg, yg
        x_side = np.linspace(bornes[0], bornes[1], num=x_max)
        y_side = np.linspace(bornes[2], bornes[3], num=y_max)

        # Fonction inverse.
        map_x, map_y = self.transformer.gnomonic_to_cam(
            *np.meshgrid(x_side, y_side, copy=False),
            self.set_calibration(), dtype=np.float32)
        # map_x, map_y = map_x.astype(np.float32, copy=False), map_y.astype(np.float32, copy=False) # cv2 en a besoin.

        if self.verbose:
            print(&#34;\tOK: La matrice gnomonic est calculee.&#34;)

        # Sauvegarde
        if psutil is not None and psutil.virtual_memory().percent &lt; 75:
            self._gnomonic_matrix = (map_x, map_y, bornes)
            return self._gnomonic_matrix
        return (map_x, map_y, bornes)

    def get_mean(self):
        &#34;&#34;&#34;
        ** Estime la moyenne des images. **

        Cela permet d&#39;avoir une estimation du fond diffus.

        Notes
        -----
        * A cause des arrondis machine, seule les 9e15 permieres images sont considerees.
        * Ne retourne pas tant que toutes les images d&#39;entree ne sont pas lues.

        Returns
        -------
        np.ndarray
            L&#39;image de la moyenne des images en matrice 2d uint16.
        &#34;&#34;&#34;
        if self._mean_bg is not None:
            return self._mean_bg

        if self.verbose:
            print(&#34;Estimation du fond par la moyenne...&#34;)

        im_gen = iter((image.astype(np.float64) for _, image in self.read_images()))
        try:
            mean_array = next(im_gen)
        except StopIteration as err:
            raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
        for i, image in enumerate(im_gen):
            mean_array = i/(i+1) * mean_array + 1/(i+1) * image

        self._mean_bg = mean_array.astype(np.uint16)

        if self.verbose:
            print(&#34;\tOK: La moyenne des images est estimee.&#34;)
        return self._mean_bg

    def get_images_shape(self):
        &#34;&#34;&#34;
        ** Recupere les dimensions des images. **

        Returns
        -------
        tuple
            (nbr de lignes, nbr de colones), de type (int, int).
        &#34;&#34;&#34;
        if self._shape is not None:
            return self._shape

        try:
            _, image = next(iter(self.read_images()))
        except StopIteration as err:
            raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
        self._shape = image.shape
        return self._shape

    def read_images(self):
        &#34;&#34;&#34;
        ** Cede le contenu des images. **

        Notes
        -----
        * Reitere depuis le debut a chaque appel.
        * Il peut y avoir plusieurs appels en parallele
        sans que cela ne genere de conflits. Dumoins tans que des threads
        ne sont pas utilises, car il n&#39;y a pas de mecanisme de verrou.
        * A chaque appel de cette methode, l&#39;ordre est conserve.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.

        Yields
        ------
        name : str
            Le nom de l&#39;image (path si possible)
        image : np.ndarray
            Le contenu de l&#39;image

        Raises
        ------
        TypeError
            Si l&#39;image n&#39;est pas bien typee.
        FileNotFoundError
            Si le chemin de l&#39;image n&#39;est pas correcte.
        ValueError
            Si les images ne sont pas de la meme taille.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; for image in laue.Experiment(images):
        ...     pass
        ...
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        from laue.utilities.multi_core import RecallingIterator, prevent_generator_size

        def read_and_check_any_image(image_info, image_num):
            &#34;&#34;&#34;
            Soit retroune directement, soit lit le fichier.
            Retourne le nom de l&#39;image et l&#39;image elle-meme.
            Renvoi None, None si il faut ignorer cette image.
            &#34;&#34;&#34;            
            # Mise en forme.
            if isinstance(image_info, str):
                image_name = image_info
                from laue.utilities.image import read_image
                image = read_image(image_info, ignore_errors=self.ignore_errors)
                if image is None:
                    return None, None
            elif isinstance(image_info, np.ndarray):
                image_name = f&#34;image_{image_num}&#34;
                image = image_info
            else:
                raise TypeError(&#34;L&#39;image doit etre de type str ou np.array, &#34;
                    f&#34;pas {type(image_info).__name__}.&#34;)

            # Verifications
            if not isinstance(image, np.ndarray):
                raise TypeError(f&#34;L&#39;image doit etre un array numpy, pas un {type(image).__name__}.&#34;)
            if image.ndim != 2:
                raise TypeError(f&#34;L&#39;image {image_name} doit etre en niveau de gris pas de dimension {image.ndim}.&#34;)
            if image.dtype != np.uint16:
                raise TypeError(f&#34;L&#39;image {image_name} doit etre encodee en uint16, pas {image.dtype}.&#34;)
            if self._shape is None:
                self._shape = image.shape
            if self._shape != image.shape:
                raise ValueError(f&#34;L&#39;image {image_name} a pour taille {image.shape} tandis que les images &#34;
                    f&#34;precedentes ont pour taille {self._shape}. Les images ne sont pas issues de la meme experience.&#34;)

            return image_name, image

        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Lecture des images...&#34;)
                
                for image_info in func(*func_args, **func_kwargs):
                    yield image_info
                    if self.verbose &gt;= 2:
                        print(f&#34;\timage : (...{str(image_info)[-20:]}) cedes.&#34;)

                if self.verbose:
                    print(&#34;\tOK: Toutes les images sont lues.&#34;)

            return decorate

        @show_iterator_state
        def _images_extractor():
            &#34;&#34;&#34;
            Premiere vraie extraction.
            &#34;&#34;&#34;
            # Convertion str vers generateur
            if isinstance(self._images, str): # Dans le cas ou une chaine de caractere
                if os.path.isdir(self._images): # decrit l&#39;ensemble des images.
                    self._images = (
                        os.path.join(father, file)
                        for father, _, files in os.walk(self._images)
                        for file in files)
                else:
                    self._images = glob.iglob(self._images, recursive=True)

            yield from self._images

        @prevent_generator_size(min_size=1)
        def jump_map(multi_image_iterator):
            image_num = 0
            for image_info in multi_image_iterator:
                image_name, image = read_and_check_any_image(image_info, image_num)
                if image is None:
                    continue
                image_num += 1
                yield image_name, image

        if self._images_iterator is None:
            self._images_iterator = iter(_images_extractor())

        return jump_map(RecallingIterator(self._images_iterator, mother=self))

    def save_file(self, filename):
        &#34;&#34;&#34;
        ** Enregistre un fichier contenant des informations. **

        Notes
        -----
        * Les extensions prises en charge sont ``.det``.
        * Pour les fichiers propres a chaque diagrammes, voir ``laue.diagram.LaueDiagram.save_file``.

        Parameters
        ----------
        filename : str
            Nom ou chemin du fichier de destination.
            L&#39;extension doit etre comprise dans le nom du fichier.
            Si un fichier du meme nom existe deja, il est ecrase.

        Example
        -------
        &gt;&gt;&gt; import os, tempfile
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt;
        &gt;&gt;&gt; images = [&#34;laue/examples/ge_blanc.mccd&#34;]
        &gt;&gt;&gt; rep = tempfile.mkdtemp()
        &gt;&gt;&gt; expe = laue.Experiment(images, dd=71.5, x0=938.5, y0=1078.1)
        &gt;&gt;&gt; expe.save_file(os.path.join(rep, &#34;fit.det&#34;))
        &#34;&#34;&#34;
        assert isinstance(filename, str), \
            f&#34;&#39;filename&#39; has to be a string, not a {type(filename).__name__}.&#34;
        assert &#34;.&#34; in filename, &#34;Le fichier doit posseder une extension.&#34;
        assert filename.split(&#34;.&#34;)[-1].lower() in {&#34;det&#34;}, \
            f&#34;Seule les extensions &#39;.det&#39; sont supportees. Pas &#39;.{filename.split(&#39;.&#39;)[-1]}&#39;.&#34;

        ext = filename.split(&#34;.&#34;)[-1].lower()
        if ext == &#34;det&#34;:
            with open(filename, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
                file.write(
                   (f&#34;{self.set_calibration()[&#39;dd&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;xcen&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;ycen&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;xbet&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;xgam&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;pixelsize&#39;]}, &#34;
                    f&#34;{self.get_images_shape()[0]}, &#34;
                    f&#34;{self.get_images_shape()[1]}\n&#34;))
                file.write(&#34;Sample-Detector distance(IM), xO, yO, angle1, angle2, pixelsize, dim1, dim2\n&#34;)
                file.write(f&#34;{repr(self)}\n&#34;)
                file.write(f&#34;Calibration done at {time.asctime()}.\n&#34;)

    def _clean(self):
        &#34;&#34;&#34;
        ** Tente de liberer de la memoire. **

        Supprime tous les attributs qui sont suceptibles
        de prendre de la place en memoire.
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Suppression des attributs facultatifs...&#34;)
        self._gnomonic_matrix = None
        for diag in self:
            diag._clean()
        if self.verbose:
            print(&#34;\tOK: Le volume de donnees et minimum.&#34;)

    def __getitem__(self, item):
        &#34;&#34;&#34;
        ** Recupere un diagrame. **

        Retroune le ou les diagrames de type ``laue.diagram.LaueDiagram``.

        Parameters
        ----------
        item
            * Ce qui permet de reconaitre un diagrame parmis tous.
                * ``int`` =&gt; Retourne le ieme diagrame, genere par la
                    ieme image lue.
                * ``slice`` =&gt; Permet de manipuler l&#39;experience comme une
                    liste de diagrames ordones dans l&#39;ordre de generation des images.

        Raises
        ------
        KeyError
            Si la clef est correcte mais qu&#39;aucun diagrame ne correspond a cette clef.
        TypeError
            Si la clef n&#39;est pas correcte.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(laue.Experiment(images)[0])
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt; type(laue.Experiment(images)[-1])
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(laue.Experiment(images)[:])
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; len(laue.Experiment(images)[:])
        2
        &gt;&gt;&gt; laue.Experiment(images)[2:]
        []
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def get_diag_list(limit, ignore=False):
            # Cas simple ou il n&#39;y a rien a extraire.
            if limit &gt;= 0 and len(self._buff_diags) &gt; limit: # Si on a deja une liste de la bone taille.
                return self._buff_diags
            if limit &lt; 0 and len(self) and -limit &lt;= len(self):
                return self._buff_diags
            if len(self) and ignore: # Si il faut se contenter de ce qu&#39;on a, meme si c&#39;est pas suffisant.
                return self._buff_diags
            if len(self) and limit &gt;= len(self):
                raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                    f&#34;Or vous tentez d&#39;acceder au {limit+1}eme diagrame!&#34;)
            if len(self) and -limit &gt; len(self):
                raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                    f&#34;Or vous tentez d&#39;acceder rang {limit}. Le plus petit rang possible c&#39;est {-len(self)}.&#34;)

            # Cas ou il faut extraire.
            if limit &gt;= 0:
                target_limit = max(limit, 2*len(self._buff_diags))
                self._buff_diags = []
                for i, diag in enumerate(self):
                    self._buff_diags.append(diag)
                    if i == self._buff_diags:
                        break
            else:
                self._buff_diags = self.get_diagrams()

            return get_diag_list(limit=limit, ignore=ignore)

        if isinstance(item, int):
            return get_diag_list(item)[item]

        if isinstance(item, slice):
            assert item.start is None or isinstance(item.start, int), \
                f&#34;Slice arguments has to be int, not {type(item.start).__name__}.&#34;
            assert item.stop is None or isinstance(item.stop, int), \
                f&#34;Slice arguments has to be int, not {type(item.stop).__name__}.&#34;
            assert item.step is None or isinstance(item.step, int), \
                f&#34;Slice arguments has to be int, not {type(item.step).__name__}.&#34;
            l1 = get_diag_list(item.start, ignore=True) if item.start is not None else []
            l2 = get_diag_list(item.stop, ignore=True) if item.stop is not None else self.get_diagrams()
            return (l1 if len(l1) &gt; len(l2) else l2)[item]

        raise TypeError(f&#34;La clef doit etre de type int ou slice. Pas {type(item).__name__}.&#34;)

    def __iter__(self):
        &#34;&#34;&#34;
        ** Cede les differents diagrammes contenus dans l&#39;experience. **

        * L&#39;ordre est arbitraire la premiere fois mais reste le meme a chaque appel.
        * Strictement equivalent a ``self.get_diagrams(tense_flow=True)`` de
        la methode ``laue.experiment.base_experiment.Experiment.get_diagrams``.

        Yields
        ------
        diagram : laue.diagram.LaueDiagram
            Chaque diagramme contenus dans l&#39;experience.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(image)
        &gt;&gt;&gt;
        &gt;&gt;&gt; for diag in experiment:
        ...     pass # Allows to process each diagram as it is ready.
        ...
        &gt;&gt;&gt; type(next(iter(experiment)))
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        yield from self.get_diagrams(tense_flow=True)

    def __len__(self):
        &#34;&#34;&#34;
        ** Nombre de diagrammes constituants l&#39;experience. **

        Returns
        -------
        int
            Renvoi le nombre de diagrames presents dans cette experience.
            Si tous les diagrames ne sont pas lus, la valeur 0 est renvoyee.
        &#34;&#34;&#34;
        if self._len is None:
            return 0
        return self._len

    def __repr__(self):
        &#34;&#34;&#34;
        ** Renvoi une chaine evaluable de self. **
        &#34;&#34;&#34;
        kwargs = [&#34;verbose&#34;, &#34;max_space&#34;, &#34;threshold&#34;]
        attr1 = [f&#34;{kwarg}={repr(getattr(self, kwarg))}&#34; for kwarg in kwargs]
        attr2 = [f&#34;{k}={v}&#34; for k, v in self.kwargs.items()]
        return &#34;Experiment(%s)&#34; % &#34;, &#34;.join(attr1 + attr2)

    def __str__(self):
        &#34;&#34;&#34;
        ** Retourne une jolie representation. **
        &#34;&#34;&#34;
        addi_kwargs = &#39;\t\t\n&#39;.join(f&#39;{k}={v}&#39; for k, v in self.kwargs.items())
        addi_print = f&#34;\n\tadditional kwargs: \n\t\t{addi_kwargs}&#34; if addi_kwargs else &#34;&#34;
        return (&#34;Basic Experiment:\n&#34;
                f&#34;\tnbr reading diagrams: {len(self)}\n&#34;
                f&#34;\tmax_space: {self.max_space} pxl\n&#34;
                f&#34;\tthreshold: {self.threshold} impact/impact\n&#34;
                f&#34;\tfont_size: {self.font_size} pxl\n&#34;
                f&#34;\tignore_errors: {self.ignore_errors}\n&#34;
                f&#34;\tverbose: {self.verbose}&#34;
                f&#34;{addi_print}&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="laue.experiment.theorical_experiment.TheoricalExperiment" href="experiment/theorical_experiment.html#laue.experiment.theorical_experiment.TheoricalExperiment">TheoricalExperiment</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laue.Experiment.__getitem__"><code class="name flex">
<span>def <span class="ident">__getitem__</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere un diagrame. </strong></p>
<p>Retroune le ou les diagrames de type <code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>
<ul>
<li>Ce qui permet de reconaitre un diagrame parmis tous.<ul>
<li><code>int</code> =&gt; Retourne le ieme diagrame, genere par la
ieme image lue.</li>
<li><code>slice</code> =&gt; Permet de manipuler l'experience comme une
liste de diagrames ordones dans l'ordre de generation des images.</li>
</ul>
</li>
</ul>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>Si la clef est correcte mais qu'aucun diagrame ne correspond a cette clef.</dd>
<dt><code>TypeError</code></dt>
<dd>Si la clef n'est pas correcte.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; type(laue.Experiment(images)[0])
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt; type(laue.Experiment(images)[-1])
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; type(laue.Experiment(images)[:])
&lt;class 'list'&gt;
&gt;&gt;&gt; len(laue.Experiment(images)[:])
2
&gt;&gt;&gt; laue.Experiment(images)[2:]
[]
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __getitem__(self, item):
    &#34;&#34;&#34;
    ** Recupere un diagrame. **

    Retroune le ou les diagrames de type ``laue.diagram.LaueDiagram``.

    Parameters
    ----------
    item
        * Ce qui permet de reconaitre un diagrame parmis tous.
            * ``int`` =&gt; Retourne le ieme diagrame, genere par la
                ieme image lue.
            * ``slice`` =&gt; Permet de manipuler l&#39;experience comme une
                liste de diagrames ordones dans l&#39;ordre de generation des images.

    Raises
    ------
    KeyError
        Si la clef est correcte mais qu&#39;aucun diagrame ne correspond a cette clef.
    TypeError
        Si la clef n&#39;est pas correcte.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(laue.Experiment(images)[0])
    &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
    &gt;&gt;&gt; type(laue.Experiment(images)[-1])
    &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(laue.Experiment(images)[:])
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; len(laue.Experiment(images)[:])
    2
    &gt;&gt;&gt; laue.Experiment(images)[2:]
    []
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def get_diag_list(limit, ignore=False):
        # Cas simple ou il n&#39;y a rien a extraire.
        if limit &gt;= 0 and len(self._buff_diags) &gt; limit: # Si on a deja une liste de la bone taille.
            return self._buff_diags
        if limit &lt; 0 and len(self) and -limit &lt;= len(self):
            return self._buff_diags
        if len(self) and ignore: # Si il faut se contenter de ce qu&#39;on a, meme si c&#39;est pas suffisant.
            return self._buff_diags
        if len(self) and limit &gt;= len(self):
            raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                f&#34;Or vous tentez d&#39;acceder au {limit+1}eme diagrame!&#34;)
        if len(self) and -limit &gt; len(self):
            raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                f&#34;Or vous tentez d&#39;acceder rang {limit}. Le plus petit rang possible c&#39;est {-len(self)}.&#34;)

        # Cas ou il faut extraire.
        if limit &gt;= 0:
            target_limit = max(limit, 2*len(self._buff_diags))
            self._buff_diags = []
            for i, diag in enumerate(self):
                self._buff_diags.append(diag)
                if i == self._buff_diags:
                    break
        else:
            self._buff_diags = self.get_diagrams()

        return get_diag_list(limit=limit, ignore=ignore)

    if isinstance(item, int):
        return get_diag_list(item)[item]

    if isinstance(item, slice):
        assert item.start is None or isinstance(item.start, int), \
            f&#34;Slice arguments has to be int, not {type(item.start).__name__}.&#34;
        assert item.stop is None or isinstance(item.stop, int), \
            f&#34;Slice arguments has to be int, not {type(item.stop).__name__}.&#34;
        assert item.step is None or isinstance(item.step, int), \
            f&#34;Slice arguments has to be int, not {type(item.step).__name__}.&#34;
        l1 = get_diag_list(item.start, ignore=True) if item.start is not None else []
        l2 = get_diag_list(item.stop, ignore=True) if item.stop is not None else self.get_diagrams()
        return (l1 if len(l1) &gt; len(l2) else l2)[item]

    raise TypeError(f&#34;La clef doit etre de type int ou slice. Pas {type(item).__name__}.&#34;)</code></pre>
</details>
</dd>
<dt id="laue.Experiment.__iter__"><code class="name flex">
<span>def <span class="ident">__iter__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Cede les differents diagrammes contenus dans l'experience. </strong></p>
<ul>
<li>L'ordre est arbitraire la premiere fois mais reste le meme a chaque appel.</li>
<li>Strictement equivalent a <code>self.get_diagrams(tense_flow=True)</code> de
la methode <code><a title="laue.experiment.base_experiment.Experiment.get_diagrams" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.get_diagrams">Experiment.get_diagrams()</a></code>.</li>
</ul>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>diagram</code></strong> :&ensp;<code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code></dt>
<dd>Chaque diagramme contenus dans l'experience.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(image)
&gt;&gt;&gt;
&gt;&gt;&gt; for diag in experiment:
...     pass # Allows to process each diagram as it is ready.
...
&gt;&gt;&gt; type(next(iter(experiment)))
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __iter__(self):
    &#34;&#34;&#34;
    ** Cede les differents diagrammes contenus dans l&#39;experience. **

    * L&#39;ordre est arbitraire la premiere fois mais reste le meme a chaque appel.
    * Strictement equivalent a ``self.get_diagrams(tense_flow=True)`` de
    la methode ``laue.experiment.base_experiment.Experiment.get_diagrams``.

    Yields
    ------
    diagram : laue.diagram.LaueDiagram
        Chaque diagramme contenus dans l&#39;experience.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(image)
    &gt;&gt;&gt;
    &gt;&gt;&gt; for diag in experiment:
    ...     pass # Allows to process each diagram as it is ready.
    ...
    &gt;&gt;&gt; type(next(iter(experiment)))
    &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    yield from self.get_diagrams(tense_flow=True)</code></pre>
</details>
</dd>
<dt id="laue.Experiment.__len__"><code class="name flex">
<span>def <span class="ident">__len__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Nombre de diagrammes constituants l'experience. </strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Renvoi le nombre de diagrames presents dans cette experience.
Si tous les diagrames ne sont pas lus, la valeur 0 est renvoyee.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __len__(self):
    &#34;&#34;&#34;
    ** Nombre de diagrammes constituants l&#39;experience. **

    Returns
    -------
    int
        Renvoi le nombre de diagrames presents dans cette experience.
        Si tous les diagrames ne sont pas lus, la valeur 0 est renvoyee.
    &#34;&#34;&#34;
    if self._len is None:
        return 0
    return self._len</code></pre>
</details>
</dd>
<dt id="laue.Experiment.find_subsets"><code class="name flex">
<span>def <span class="ident">find_subsets</span></span>(<span>self, *, tense_flow=False, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Estime les grains dans chaque diagrame. </strong></p>
<p>Sorte d'alias parallelise vers <code><a title="laue.diagram.LaueDiagram.find_subsets" href="core/subsets.html#laue.core.subsets.Splitable.find_subsets">Splitable.find_subsets()</a></code>.
Le resultat est le meme que: <code>[diag.find_subsets(**kwds) for diag in self]</code></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Il est possible d'appeler plusieur fois cette methode en parallele.</li>
<li>Les sections critiques sont verouillees donc cette methode supporte le multithread.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tense_flow</code></strong> :&ensp;<code>boolean</code></dt>
<dd>
<ul>
<li>True : Permet de travailler a flux tendu, c'est a dire
de ceder les bouts de grains des diagrammes au fur a meusure qu'ils sont trouves.<ul>
<li>Le generateur termine quand toutes les images sont lues ou
que le generateur d'images leve un <code>StopIteration</code>.</li>
<li>A chaque nouvel appel de cette methode, l'iteration
recommence a partir du debut et l'ordre reste inchange.</li>
<li>Equivalent a <code>(diag.find_subsets(**kwds) for diag in self)</code>.</li>
</ul>
</li>
<li>False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.<ul>
<li>C'est equvalent a <code>[diag.find_subsets(**kwds) for diag in self]</code>.</li>
<li>Au lieu de retourner un generateur, retourne une liste.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>**kwds</code></strong></dt>
<dd>Se sont les parametres de la fonction <code><a title="laue.diagram.LaueDiagram.find_subsets" href="core/subsets.html#laue.core.subsets.Splitable.find_subsets">Splitable.find_subsets()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Pour chaque diagramme de cette experience, cede une estimation des grains.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&quot;laue/examples/ge_blanc.det&quot;)
&gt;&gt;&gt;
&gt;&gt;&gt; type(experiment.find_subsets())
&lt;class 'list'&gt;
&gt;&gt;&gt; type(experiment.find_subsets(tense_flow=True))
&lt;class 'generator'&gt;
&gt;&gt;&gt; type(next(iter(experiment.find_subsets(tense_flow=True))))
&lt;class 'list'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_subsets(self, *, tense_flow=False, **kwds):
    &#34;&#34;&#34;
    ** Estime les grains dans chaque diagrame. **

    Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_subsets``.
    Le resultat est le meme que: ``[diag.find_subsets(**kwds) for diag in self]``

    Notes
    -----
    * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
    * Les sections critiques sont verouillees donc cette methode supporte le multithread.
    
    Parameters
    ----------
    tense_flow : boolean
        * True : Permet de travailler a flux tendu, c&#39;est a dire
        de ceder les bouts de grains des diagrammes au fur a meusure qu&#39;ils sont trouves.
            * Le generateur termine quand toutes les images sont lues ou
            que le generateur d&#39;images leve un ``StopIteration``.
            * A chaque nouvel appel de cette methode, l&#39;iteration
            recommence a partir du debut et l&#39;ordre reste inchange.
            * Equivalent a ``(diag.find_subsets(**kwds) for diag in self)``.
        * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
            * C&#39;est equvalent a ``[diag.find_subsets(**kwds) for diag in self]``.
            * Au lieu de retourner un generateur, retourne une liste.
    **kwds
        Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_subsets``.

    Returns
    -------
    list
        Pour chaque diagramme de cette experience, cede une estimation des grains.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(experiment.find_subsets())
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; type(experiment.find_subsets(tense_flow=True))
    &lt;class &#39;generator&#39;&gt;
    &gt;&gt;&gt; type(next(iter(experiment.find_subsets(tense_flow=True))))
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def show_iterator_state(func):
        &#34;&#34;&#34;
        Insere des commentaires.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            if self.verbose:
                print(&#34;Estimation des grains...&#34;)
            
            for i, groups in enumerate(func(*func_args, **func_kwargs)):
                if self.verbose &gt;= 2:
                    print(f&#34;\tgrain du diagramme num {i} estimes: il y a {len(groups)} clusters&#34;)
                yield groups

            if self.verbose:
                print(&#34;\tOK: Tous les clusters de grains sont estimes.&#34;)

        return decorate

    @show_iterator_state
    def _subsets_extractor(self):
        if multiprocessing.current_process().name == &#34;MainProcess&#34;:
            from laue.core.subsets import _pickelable as atomic_find_subsets
            from laue.utilities.multi_core import limited_imap
            with multiprocessing.Pool() as pool:
                yield from (
                    diag.find_subsets(_atomic_subsets_res=args)
                    for diag, args
                    in zip(
                        self,
                        limited_imap(pool,
                            atomic_find_subsets,
                            (   # transformer, gnomonics, dmax, nbr, tol
                                diag.find_subsets(**kwds, _get_args=True)
                                for diag in self
                            )
                        )
                    )
                )
        else:
            yield from (diag.find_subsets(**kwds) for diag in self)

    if not tense_flow:
        return list(self.find_subsets(tense_flow=True, **kwds))

    if self._subsets_iterator is None:
        self._subsets_iterator = iter(_subsets_extractor(self))

    from laue.utilities.multi_core import RecallingIterator
    return (lambda x: (yield from x))(RecallingIterator(self._subsets_iterator, mother=self))</code></pre>
</details>
</dd>
<dt id="laue.Experiment.find_zone_axes"><code class="name flex">
<span>def <span class="ident">find_zone_axes</span></span>(<span>self, *, tense_flow=False, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recherche l'ensemble des axes de zones. </strong></p>
<p>Sorte d'alias parallelise vers <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code>.
Le resultat est le meme que: <code>[diag.find_zone_axes(**kwds) for diag in self]</code></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Il est possible d'appeler plusieur fois cette methode en parallele.</li>
<li>Les sections critiques sont verouillees donc cette methode supporte le multithread.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tense_flow</code></strong> :&ensp;<code>boolean</code></dt>
<dd>
<ul>
<li>True : Permet de travailler a flux tendu, c'est a dire
de ceder les axes des diagrammes au fur a meusure qu'ils sont trouves.<ul>
<li>Le generateur termine quand toutes les images sont lues ou
que le generateur d'images leve un <code>StopIteration</code>.</li>
<li>A chaque nouvel appel de cette methode, l'iteration
recommence a partir du debut et l'ordre reste inchange.</li>
<li>Equivalent a <code>(diag.find_zone_axes(**kwds) for diag in self)</code>.</li>
</ul>
</li>
<li>False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.<ul>
<li>C'est equvalent a <code>[diag.find_zone_axes(**kwds) for diag in self]</code>.</li>
<li>Au lieu de retourner un generateur, retourne une liste.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>**kwds</code></strong></dt>
<dd>Se sont les parametres de la fonction <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Pour chaque diagramme de cette experience, cede la liste
des axes de zones du diagramme. Les elements de l'ensemble
sont de type <code><a title="laue.zone_axis.ZoneAxis" href="zone_axis.html#laue.zone_axis.ZoneAxis">ZoneAxis</a></code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&quot;laue/examples/ge_blanc.det&quot;)
&gt;&gt;&gt;
&gt;&gt;&gt; type(experiment.find_zone_axes())
&lt;class 'list'&gt;
&gt;&gt;&gt; type(experiment.find_zone_axes(tense_flow=True))
&lt;class 'generator'&gt;
&gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))))
&lt;class 'list'&gt;
&gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))).pop())
&lt;class 'laue.zone_axis.ZoneAxis'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_zone_axes(self, *, tense_flow=False, **kwds):
    &#34;&#34;&#34;
    ** Recherche l&#39;ensemble des axes de zones. **

    Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_zone_axes``.
    Le resultat est le meme que: ``[diag.find_zone_axes(**kwds) for diag in self]``

    Notes
    -----
    * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
    * Les sections critiques sont verouillees donc cette methode supporte le multithread.

    Parameters
    ----------
    tense_flow : boolean
        * True : Permet de travailler a flux tendu, c&#39;est a dire
        de ceder les axes des diagrammes au fur a meusure qu&#39;ils sont trouves.
            * Le generateur termine quand toutes les images sont lues ou
            que le generateur d&#39;images leve un ``StopIteration``.
            * A chaque nouvel appel de cette methode, l&#39;iteration
            recommence a partir du debut et l&#39;ordre reste inchange.
            * Equivalent a ``(diag.find_zone_axes(**kwds) for diag in self)``.
        * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
            * C&#39;est equvalent a ``[diag.find_zone_axes(**kwds) for diag in self]``.
            * Au lieu de retourner un generateur, retourne une liste.
    **kwds
        Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_zone_axes``.

    Returns
    -------
    list
        Pour chaque diagramme de cette experience, cede la liste
        des axes de zones du diagramme. Les elements de l&#39;ensemble
        sont de type ``laue.zone_axis.ZoneAxis``.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(experiment.find_zone_axes())
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; type(experiment.find_zone_axes(tense_flow=True))
    &lt;class &#39;generator&#39;&gt;
    &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))))
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))).pop())
    &lt;class &#39;laue.zone_axis.ZoneAxis&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def show_iterator_state(func):
        &#34;&#34;&#34;
        Insere des commentaires.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            if self.verbose:
                print(&#34;Extraction des axes de zone...&#34;)
            
            for i, axes in enumerate(func(*func_args, **func_kwargs)):
                if self.verbose &gt;= 2:
                    print(f&#34;\taxes du diagramme num {i} trouves: il y en a {len(axes)}&#34;)
                yield axes

            if self.verbose:
                print(&#34;\tOK: Tous les axes de zone sont extraits.&#34;)

        return decorate

    @show_iterator_state
    def _axes_extractor(self):
        &#34;&#34;&#34;
        Premiere vraie extraction.
        &#34;&#34;&#34;
        if multiprocessing.current_process().name == &#34;MainProcess&#34;:
            # Compilation et serialisation des equations.
            self.transformer.compile()
            self.set_calibration()
            transformer_ser = cloudpickle.dumps(self.transformer)

            # Parallelisation des fils.
            from laue.core.zone_axes import _get_zone_axes_pickle
            from laue.utilities.multi_core import limited_imap
            with multiprocessing.Pool() as pool:
                yield from (
                    diag.find_zone_axes(_axes_args=args)
                    for diag, args
                    in zip(
                        self,
                        limited_imap(pool,
                            _get_zone_axes_pickle,
                            ( # transformer, gnomonics, dmax, nbr, tol
                                (transformer_ser, *diag.find_zone_axes(**kwds, _get_args=True))
                                for diag in self
                            )
                        )
                    )
                )

        else:
            yield from (diag.find_zone_axes(**kwds) for diag in self)

    if not tense_flow:
        return list(self.find_zone_axes(tense_flow=True, **kwds))

    if self._axes_iterator is None:
        self._axes_iterator = iter(_axes_extractor(self))

    from laue.utilities.multi_core import RecallingIterator
    return (lambda x: (yield from x))(RecallingIterator(self._axes_iterator, mother=self))</code></pre>
</details>
</dd>
<dt id="laue.Experiment.get_diagrams"><code class="name flex">
<span>def <span class="ident">get_diagrams</span></span>(<span>self, *, tense_flow=False)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Genere les diagrammes de l'experience. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Performances:<ul>
<li>Sur un PC (intel core i7, ssd, 8 coeurs), met environ 37 ms/diagramme.</li>
<li>Sur un PC (intel centrino, hdd, 2 coeurs), met environ 530 ms/diagramme.</li>
</ul>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tense_flow</code></strong> :&ensp;<code>boolean</code></dt>
<dd>
<ul>
<li>True : Permet de travailler a flux tendu, c'est a dire
de cede les diagrammes au fur a meusure qu'ils sont crees.<ul>
<li>Le generateur termine quand toutes les images sont lues ou
que le generateur d'images leve un <code>StopIteration</code>.</li>
<li>A chaque nouvel appel de cette methode, l'iteration
recommence a partir du debut et l'ordre reste inchange.</li>
<li>Equivalent a <code><a title="laue.experiment.base_experiment.Experiment.__iter__" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.__iter__">Experiment.__iter__()</a></code>.</li>
</ul>
</li>
<li>False. Sinon, attend que tous les diagrammes
soient lues afin de tout renvoyer en meme temps.</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>La liste des diagrammes de type <code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code>.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code></dt>
<dd>
<ul>
<li>Chaque diagram extrait au fur a mesure qu'il arrive.</li>
<li>L'ordre est concerve pour chaque appel de cette methode a flux tendu.</li>
<li>A chaque appel on repars du debut, meme si un autre appel n'est pas termine.</li>
<li>Les sections critiques sont verouillees donc cette methode supporte le multithread.</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(images)
&gt;&gt;&gt;
&gt;&gt;&gt; diagrams = experiment.get_diagrams()
&gt;&gt;&gt; type(diagrams)
&lt;class 'list'&gt;
&gt;&gt;&gt; type(diagrams.pop())
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_diagrams(self, *, tense_flow=False):
    &#34;&#34;&#34;
    ** Genere les diagrammes de l&#39;experience. **

    Notes
    -----
    * Performances:
        * Sur un PC (intel core i7, ssd, 8 coeurs), met environ 37 ms/diagramme.
        * Sur un PC (intel centrino, hdd, 2 coeurs), met environ 530 ms/diagramme.

    Parameters
    ----------
    tense_flow : boolean
        * True : Permet de travailler a flux tendu, c&#39;est a dire
        de cede les diagrammes au fur a meusure qu&#39;ils sont crees.
            * Le generateur termine quand toutes les images sont lues ou
            que le generateur d&#39;images leve un ``StopIteration``.
            * A chaque nouvel appel de cette methode, l&#39;iteration
            recommence a partir du debut et l&#39;ordre reste inchange.
            * Equivalent a ``laue.experiment.base_experiment.Experiment.__iter__``.
        * False. Sinon, attend que tous les diagrammes
        soient lues afin de tout renvoyer en meme temps.

    Returns
    -------
    list
        La liste des diagrammes de type ``laue.diagram.LaueDiagram``.

    Yields
    ------
    laue.diagram.LaueDiagram
        * Chaque diagram extrait au fur a mesure qu&#39;il arrive.
        * L&#39;ordre est concerve pour chaque appel de cette methode a flux tendu.
        * A chaque appel on repars du debut, meme si un autre appel n&#39;est pas termine.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(images)
    &gt;&gt;&gt;
    &gt;&gt;&gt; diagrams = experiment.get_diagrams()
    &gt;&gt;&gt; type(diagrams)
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; type(diagrams.pop())
    &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def update_len(func):
        &#34;&#34;&#34;
        Tient a jour la longueur de l&#39;experience.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            for i, element in enumerate(func(*func_args, **func_kwargs)):
                yield element
            self._len = i + 1

        return decorate

    def show_iterator_state(func):
        &#34;&#34;&#34;
        Insere des commentaires.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            if self.verbose:
                print(&#34;Extraction des diagrammes...&#34;)

            for i, diag in enumerate(func(*func_args, **func_kwargs)):
                if self.verbose &gt;= 2:
                    print(f&#34;\tdiagramme num {i} extrait: &#34;
                          f&#34;(...{diag.get_id()[-20:]}) &#34;
                          f&#34;avec {len(diag)} spots&#34;)
                yield diag
            if self.verbose:
                print(&#34;\tOK: Tous les diagrammes sont extraits.&#34;)
        
        return decorate

    @update_len
    @show_iterator_state
    def _diagram_extractor(self):
        &#34;&#34;&#34;
        Premiere vraie lecture. Cede les diagrammes.
        &#34;&#34;&#34;
        if multiprocessing.current_process().name == &#34;MainProcess&#34;:
            attrs = [&#34;kernel_font&#34;, &#34;threshold&#34;, &#34;kernel_dilate&#34;]
            mini_self = collections.namedtuple(&#34;SelfCopy&#34;, attrs)(
                *(getattr(self, attr) for attr in attrs)
                ) # Strategie car &#39;pickle&#39; ne sais pas faire ca.
            ser_self = cloudpickle.dumps(mini_self)

            from laue.utilities.multi_core import pickleable_method
            from laue.utilities.multi_core import limited_imap
            with multiprocessing.Pool() as pool:
                yield from (
                    self._help_get_diagrams(name, image, spot_args=spot_args)
                    for (name, image, spot_args) in limited_imap(pool,
                        pickleable_method,
                        (
                            (
                                Experiment._help_get_diagrams,
                                ser_self,
                                {&#34;name&#34;:name, &#34;image&#34;:image, &#34;thread&#34;:True}
                            )
                            for name, image in self.read_images()
                        )
                    )
                )
        else:
            yield from (self._help_get_diagrams(name, image)
                for name, image in self.read_images())
    
    if self._diagrams_iterator is None:
        self._diagrams_iterator = iter(_diagram_extractor(self))

    from laue.utilities.multi_core import RecallingIterator
    return (
        (lambda x: (yield from x))(RecallingIterator(self._diagrams_iterator, mother=self))
        if tense_flow else list(RecallingIterator(self._diagrams_iterator, mother=self)))</code></pre>
</details>
</dd>
<dt id="laue.Experiment.get_images_shape"><code class="name flex">
<span>def <span class="ident">get_images_shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere les dimensions des images. </strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(nbr de lignes, nbr de colones), de type (int, int).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_images_shape(self):
    &#34;&#34;&#34;
    ** Recupere les dimensions des images. **

    Returns
    -------
    tuple
        (nbr de lignes, nbr de colones), de type (int, int).
    &#34;&#34;&#34;
    if self._shape is not None:
        return self._shape

    try:
        _, image = next(iter(self.read_images()))
    except StopIteration as err:
        raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
    self._shape = image.shape
    return self._shape</code></pre>
</details>
</dd>
<dt id="laue.Experiment.get_mean"><code class="name flex">
<span>def <span class="ident">get_mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Estime la moyenne des images. </strong></p>
<p>Cela permet d'avoir une estimation du fond diffus.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>A cause des arrondis machine, seule les 9e15 permieres images sont considerees.</li>
<li>Ne retourne pas tant que toutes les images d'entree ne sont pas lues.</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>L'image de la moyenne des images en matrice 2d uint16.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mean(self):
    &#34;&#34;&#34;
    ** Estime la moyenne des images. **

    Cela permet d&#39;avoir une estimation du fond diffus.

    Notes
    -----
    * A cause des arrondis machine, seule les 9e15 permieres images sont considerees.
    * Ne retourne pas tant que toutes les images d&#39;entree ne sont pas lues.

    Returns
    -------
    np.ndarray
        L&#39;image de la moyenne des images en matrice 2d uint16.
    &#34;&#34;&#34;
    if self._mean_bg is not None:
        return self._mean_bg

    if self.verbose:
        print(&#34;Estimation du fond par la moyenne...&#34;)

    im_gen = iter((image.astype(np.float64) for _, image in self.read_images()))
    try:
        mean_array = next(im_gen)
    except StopIteration as err:
        raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
    for i, image in enumerate(im_gen):
        mean_array = i/(i+1) * mean_array + 1/(i+1) * image

    self._mean_bg = mean_array.astype(np.uint16)

    if self.verbose:
        print(&#34;\tOK: La moyenne des images est estimee.&#34;)
    return self._mean_bg</code></pre>
</details>
</dd>
<dt id="laue.Experiment.read_images"><code class="name flex">
<span>def <span class="ident">read_images</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Cede le contenu des images. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Reitere depuis le debut a chaque appel.</li>
<li>Il peut y avoir plusieurs appels en parallele
sans que cela ne genere de conflits. Dumoins tans que des threads
ne sont pas utilises, car il n'y a pas de mecanisme de verrou.</li>
<li>A chaque appel de cette methode, l'ordre est conserve.</li>
<li>Les sections critiques sont verouillees donc cette methode supporte le multithread.</li>
</ul>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Le nom de l'image (path si possible)</dd>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Le contenu de l'image</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Si l'image n'est pas bien typee.</dd>
<dt><code>FileNotFoundError</code></dt>
<dd>Si le chemin de l'image n'est pas correcte.</dd>
<dt><code>ValueError</code></dt>
<dd>Si les images ne sont pas de la meme taille.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt; for image in laue.Experiment(images):
...     pass
...
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_images(self):
    &#34;&#34;&#34;
    ** Cede le contenu des images. **

    Notes
    -----
    * Reitere depuis le debut a chaque appel.
    * Il peut y avoir plusieurs appels en parallele
    sans que cela ne genere de conflits. Dumoins tans que des threads
    ne sont pas utilises, car il n&#39;y a pas de mecanisme de verrou.
    * A chaque appel de cette methode, l&#39;ordre est conserve.
    * Les sections critiques sont verouillees donc cette methode supporte le multithread.

    Yields
    ------
    name : str
        Le nom de l&#39;image (path si possible)
    image : np.ndarray
        Le contenu de l&#39;image

    Raises
    ------
    TypeError
        Si l&#39;image n&#39;est pas bien typee.
    FileNotFoundError
        Si le chemin de l&#39;image n&#39;est pas correcte.
    ValueError
        Si les images ne sont pas de la meme taille.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt; for image in laue.Experiment(images):
    ...     pass
    ...
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.utilities.multi_core import RecallingIterator, prevent_generator_size

    def read_and_check_any_image(image_info, image_num):
        &#34;&#34;&#34;
        Soit retroune directement, soit lit le fichier.
        Retourne le nom de l&#39;image et l&#39;image elle-meme.
        Renvoi None, None si il faut ignorer cette image.
        &#34;&#34;&#34;            
        # Mise en forme.
        if isinstance(image_info, str):
            image_name = image_info
            from laue.utilities.image import read_image
            image = read_image(image_info, ignore_errors=self.ignore_errors)
            if image is None:
                return None, None
        elif isinstance(image_info, np.ndarray):
            image_name = f&#34;image_{image_num}&#34;
            image = image_info
        else:
            raise TypeError(&#34;L&#39;image doit etre de type str ou np.array, &#34;
                f&#34;pas {type(image_info).__name__}.&#34;)

        # Verifications
        if not isinstance(image, np.ndarray):
            raise TypeError(f&#34;L&#39;image doit etre un array numpy, pas un {type(image).__name__}.&#34;)
        if image.ndim != 2:
            raise TypeError(f&#34;L&#39;image {image_name} doit etre en niveau de gris pas de dimension {image.ndim}.&#34;)
        if image.dtype != np.uint16:
            raise TypeError(f&#34;L&#39;image {image_name} doit etre encodee en uint16, pas {image.dtype}.&#34;)
        if self._shape is None:
            self._shape = image.shape
        if self._shape != image.shape:
            raise ValueError(f&#34;L&#39;image {image_name} a pour taille {image.shape} tandis que les images &#34;
                f&#34;precedentes ont pour taille {self._shape}. Les images ne sont pas issues de la meme experience.&#34;)

        return image_name, image

    def show_iterator_state(func):
        &#34;&#34;&#34;
        Insere des commentaires.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            if self.verbose:
                print(&#34;Lecture des images...&#34;)
            
            for image_info in func(*func_args, **func_kwargs):
                yield image_info
                if self.verbose &gt;= 2:
                    print(f&#34;\timage : (...{str(image_info)[-20:]}) cedes.&#34;)

            if self.verbose:
                print(&#34;\tOK: Toutes les images sont lues.&#34;)

        return decorate

    @show_iterator_state
    def _images_extractor():
        &#34;&#34;&#34;
        Premiere vraie extraction.
        &#34;&#34;&#34;
        # Convertion str vers generateur
        if isinstance(self._images, str): # Dans le cas ou une chaine de caractere
            if os.path.isdir(self._images): # decrit l&#39;ensemble des images.
                self._images = (
                    os.path.join(father, file)
                    for father, _, files in os.walk(self._images)
                    for file in files)
            else:
                self._images = glob.iglob(self._images, recursive=True)

        yield from self._images

    @prevent_generator_size(min_size=1)
    def jump_map(multi_image_iterator):
        image_num = 0
        for image_info in multi_image_iterator:
            image_name, image = read_and_check_any_image(image_info, image_num)
            if image is None:
                continue
            image_num += 1
            yield image_name, image

    if self._images_iterator is None:
        self._images_iterator = iter(_images_extractor())

    return jump_map(RecallingIterator(self._images_iterator, mother=self))</code></pre>
</details>
</dd>
<dt id="laue.Experiment.save_file"><code class="name flex">
<span>def <span class="ident">save_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Enregistre un fichier contenant des informations. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Les extensions prises en charge sont <code>.det</code>.</li>
<li>Pour les fichiers propres a chaque diagrammes, voir <code><a title="laue.diagram.LaueDiagram.save_file" href="diagram.html#laue.diagram.LaueDiagram.save_file">LaueDiagram.save_file()</a></code>.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Nom ou chemin du fichier de destination.
L'extension doit etre comprise dans le nom du fichier.
Si un fichier du meme nom existe deja, il est ecrase.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import os, tempfile
&gt;&gt;&gt; import laue
&gt;&gt;&gt;
&gt;&gt;&gt; images = [&quot;laue/examples/ge_blanc.mccd&quot;]
&gt;&gt;&gt; rep = tempfile.mkdtemp()
&gt;&gt;&gt; expe = laue.Experiment(images, dd=71.5, x0=938.5, y0=1078.1)
&gt;&gt;&gt; expe.save_file(os.path.join(rep, &quot;fit.det&quot;))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_file(self, filename):
    &#34;&#34;&#34;
    ** Enregistre un fichier contenant des informations. **

    Notes
    -----
    * Les extensions prises en charge sont ``.det``.
    * Pour les fichiers propres a chaque diagrammes, voir ``laue.diagram.LaueDiagram.save_file``.

    Parameters
    ----------
    filename : str
        Nom ou chemin du fichier de destination.
        L&#39;extension doit etre comprise dans le nom du fichier.
        Si un fichier du meme nom existe deja, il est ecrase.

    Example
    -------
    &gt;&gt;&gt; import os, tempfile
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt;
    &gt;&gt;&gt; images = [&#34;laue/examples/ge_blanc.mccd&#34;]
    &gt;&gt;&gt; rep = tempfile.mkdtemp()
    &gt;&gt;&gt; expe = laue.Experiment(images, dd=71.5, x0=938.5, y0=1078.1)
    &gt;&gt;&gt; expe.save_file(os.path.join(rep, &#34;fit.det&#34;))
    &#34;&#34;&#34;
    assert isinstance(filename, str), \
        f&#34;&#39;filename&#39; has to be a string, not a {type(filename).__name__}.&#34;
    assert &#34;.&#34; in filename, &#34;Le fichier doit posseder une extension.&#34;
    assert filename.split(&#34;.&#34;)[-1].lower() in {&#34;det&#34;}, \
        f&#34;Seule les extensions &#39;.det&#39; sont supportees. Pas &#39;.{filename.split(&#39;.&#39;)[-1]}&#39;.&#34;

    ext = filename.split(&#34;.&#34;)[-1].lower()
    if ext == &#34;det&#34;:
        with open(filename, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
            file.write(
               (f&#34;{self.set_calibration()[&#39;dd&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;xcen&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;ycen&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;xbet&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;xgam&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;pixelsize&#39;]}, &#34;
                f&#34;{self.get_images_shape()[0]}, &#34;
                f&#34;{self.get_images_shape()[1]}\n&#34;))
            file.write(&#34;Sample-Detector distance(IM), xO, yO, angle1, angle2, pixelsize, dim1, dim2\n&#34;)
            file.write(f&#34;{repr(self)}\n&#34;)
            file.write(f&#34;Calibration done at {time.asctime()}.\n&#34;)</code></pre>
</details>
</dd>
<dt id="laue.Experiment.set_calibration"><code class="name flex">
<span>def <span class="ident">set_calibration</span></span>(<span>self, *diagrams)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Calibration de la camera. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Ne nessecite aucune connaissances prealable sur le christal.</li>
<li>Il n'y a pas besoin d'avoir un diagramme bien calibre, il se debrouille tout seul.</li>
<li>Cette fonction peut parfois etre lente (plusieur minutes)!</li>
<li>Si vous connaissez les parametres, fournissez-les, ca ira plus vite!</li>
<li>Si cette methode a deja ete appelee une fois, elle retourne
immeditement le resultat sans refaire les calculs.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*diagrams</code></strong> :&ensp;<code>optional</code></dt>
<dd>Les ou le diagramme.s qui vont servir a faire la calibration.
Si aucun diagramme n'est precise, cette methode recherche par elle meme
les diagrammes qu'elle trouve convaincant parmis ceux qui sont disponibles.
Il doivent etre de type <code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict </code></dt>
<dd>Le dictionaire qui a chaque non de parametre, associe sa valeur numerique.
Les clefs sont les suivantes: "dd", "xcen", "ycen", "xbet", "xgam" and "pixelsize"</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>Si l'utilisateur n'a pas precise les parametres vraiment indispenssables.</dd>
<dt><code>ValueError</code></dt>
<dd>Si il y a des incoherences dans les parametres.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(image, dd_min=69.5, dd_max=71.5, xbet=0.008)
&gt;&gt;&gt; parameters = experiment.set_calibration()
&gt;&gt;&gt; sorted(parameters.keys())
['dd', 'pixelsize', 'xbet', 'xcen', 'xgam', 'ycen']
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_calibration(self, *diagrams):
    &#34;&#34;&#34;
    ** Calibration de la camera. **

    Notes
    -----
    * Ne nessecite aucune connaissances prealable sur le christal.
    * Il n&#39;y a pas besoin d&#39;avoir un diagramme bien calibre, il se debrouille tout seul.
    * Cette fonction peut parfois etre lente (plusieur minutes)!
    * Si vous connaissez les parametres, fournissez-les, ca ira plus vite!
    * Si cette methode a deja ete appelee une fois, elle retourne
        immeditement le resultat sans refaire les calculs.

    Parameters
    ----------
    *diagrams : optional
        Les ou le diagramme.s qui vont servir a faire la calibration.
        Si aucun diagramme n&#39;est precise, cette methode recherche par elle meme
        les diagrammes qu&#39;elle trouve convaincant parmis ceux qui sont disponibles.
        Il doivent etre de type ``laue.diagram.LaueDiagram``.

    Returns
    -------
    dict 
        Le dictionaire qui a chaque non de parametre, associe sa valeur numerique.
        Les clefs sont les suivantes: &#34;dd&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;xbet&#34;, &#34;xgam&#34; and &#34;pixelsize&#34;

    Raises
    ------
    KeyError
        Si l&#39;utilisateur n&#39;a pas precise les parametres vraiment indispenssables.
    ValueError
        Si il y a des incoherences dans les parametres.

    Example
    -------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(image, dd_min=69.5, dd_max=71.5, xbet=0.008)
    &gt;&gt;&gt; parameters = experiment.set_calibration()
    &gt;&gt;&gt; sorted(parameters.keys())
    [&#39;dd&#39;, &#39;pixelsize&#39;, &#39;xbet&#39;, &#39;xcen&#39;, &#39;xgam&#39;, &#39;ycen&#39;]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if self._calibration_parameters is not None: # Si on peut retourner directement,
        return self._calibration_parameters # on ne s&#39;en prive pas.

    assert all(isinstance(diag, LaueDiagram) for diag in diagrams), \
        &#34;Tous les diagrammes doivent etre de type &#39;LaueDiagram&#39;. Or ce n&#39;est pas le cas.&#34;

    if self.verbose:
        print(&#34;Calibration...&#34;)
        if self.verbose &gt;= 2:
            print(&#34;\tPrise en compte des parametres fournis...&#34;)

    # Constantes.
    PIXELSIZE_REF = {(2048, 2048): 0.079856, # Taille des pixels fonction de la camera.
                     (2018, 2016): 0.0734,
                     (2594, 2748): 0.031}
    PARAM_SET = {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;} # Les parametres non deductibles.
    PARAM_MIN = {&#34;dd&#34;: 60.0, # Les bornes minimale par defaut.
                 &#34;xbet&#34;: -.9,
                 &#34;xgam&#34;: -.9,
                 &#34;xcen&#34;: self.get_images_shape()[0]/2 - 150,
                 &#34;ycen&#34;: self.get_images_shape()[0]/2 - 150}
    PARAM_MAX = {&#34;dd&#34;: 80.0, # Les bornes maximales par defaut.
                 &#34;xbet&#34;: .9,
                 &#34;xgam&#34;: .9,
                 &#34;xcen&#34;: self.get_images_shape()[0]/2 + 150,
                 &#34;ycen&#34;: self.get_images_shape()[1]/2 + 150}

    # Recuperation des parametres fournis et deductibles.
    from laue.utilities.parsing import extract_parameters
    given_parameters = extract_parameters(ignore_missing=True, **self.kwargs)
    if (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() in PIXELSIZE_REF):
        given_parameters[&#34;pixelsize&#34;] = PIXELSIZE_REF[self.get_images_shape()]
    
    elif (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() not in PIXELSIZE_REF):
        raise KeyError(&#34;Vous devez fournir le parametre &#39;pixelsize&#39;.\n&#34;
            f&#34;Les images font {self.get_images_shape()} pxl**2. &#34;
            f&#34;Or, seul les &#39;pixelsize&#39; des images {&#39; et &#39;.join(map(str, PIXELSIZE_REF))} sont connus.&#34;)

    # Recuperation des bornes.
    given_min = extract_parameters(ignore_missing=True, **{
        param[:-4]: value
        for param, value in self.kwargs.items()
        if param.endswith(&#34;_min&#34;) and len(param) &gt; 4})
    given_max = extract_parameters(ignore_missing=True, **{
        param[:-4]: value
        for param, value in self.kwargs.items()
        if param.endswith(&#34;_max&#34;) and len(param) &gt; 4})
    parameters_min = {param: given_min.get(param, PARAM_MIN[param]) for param in PARAM_SET}
    parameters_max = {param: given_max.get(param, PARAM_MAX[param]) for param in PARAM_SET}
    
    for param in PARAM_SET: # Verification de la coherence des bornes.
        if parameters_min[param] &gt;= parameters_max[param]:
            raise ValueError(f&#34;Les bornes du parametre {repr(param)} sont inversees, &#34;
                f&#34;{param}_min={parameters_min[param]} et {param}_max={parameters_max[param]}.&#34;)

    # Valeur de departs des parametres.
    initial_parameters = { # Ce sont les parametres initiaux pour la descente de gradient.
        par: given_parameters.get(par,
            .5*(parameters_min[par] + parameters_max[par]))
        for par in PARAM_SET}
   
    for par, val in initial_parameters.items(): # Verification.
        if par in given_parameters and par in given_min:
            if given_parameters[par] &lt; given_min[par]:
                raise ValueError(f&#34;Vous avez imposes {par}_min={given_min[par]} &#34;
                    f&#34;et en meme temp vous avez donnes {par}={val}!&#34;)
        if par in given_parameters and par in given_max:
            if given_parameters[par] &gt; given_max[par]:
                raise ValueError(f&#34;Vous avez imposes {par}_max={given_max[par]} &#34;
                    f&#34;et en meme temps vous avez donnes {par}={val}!&#34;)

    # Parametres restants.
    unknown_parameters = PARAM_SET - set(given_parameters)
    if not unknown_parameters: # Si Il n&#39;y a rien a calculer.
        self._calibration_parameters = given_parameters
        self.transformer.compile(self._calibration_parameters) # Juste pour l&#39;optimisation.
        if self.verbose:
            if self.verbose &gt;= 2:
                print(&#34;\t\tOK: Tout est fournis, il n&#39;y a rien a faire.&#34;)
            print(f&#34;\tOK: Calibration terminee: {given_parameters}&#34;)
        return self._calibration_parameters

    # Extraction d&#39;un diagramme interressant.
    if self.verbose &gt;= 2:
        print(&#34;\tRecuperation des diagrammes interressants...&#34;)
    if not diagrams: # Si l&#39;utilisateur ne nous aide pas a trouver les bons diagrammes.
        diagrams = []
        for i, dia in enumerate(self):
            if i &gt; 60: # On ne s&#39;interesse qu&#39;a la premiere minute.
                break
            diagrams.append(dia)
        best_diagrams = [sorted(diagrams, key=lambda dia: dia.get_quality(), reverse=True).pop()]
    else: # Si l&#39;utilisateur nous en fournit.
        best_diagrams = diagrams # C&#39;est un tuple et non pas une liste mais c&#39;est pas genant.
    if self.verbose &gt;= 2:
        for dia in best_diagrams:
            print(f&#34;\t\t{dia.get_id()}&#34;)

    # Vectorisation des donnees pour de bonnes perfs.
    min_size = min(
        200,
        min(len(dia) for dia in best_diagrams)
        ) # Le plus petit nombre de points.
    spots_position = np.array(
        [dia.get_positions(n=min_size, sort=&#34;quality&#34;)
         for dia in best_diagrams],
        dtype=np.float32)
    spots_position = np.swapaxes(spots_position, 0, 1) # shape: (2, n_diagrams, nbr_spots)

    # Perparations des parametres pour la suite.
    vect_labels = tuple(unknown_parameters) # On recupere les nom des parametres inconus seulement.
    bounds = [(parameters_min[name], parameters_max[name]) for name in vect_labels] # Les limites des variables.
    args = (given_parameters, vect_labels, spots_position) # Les arguments en plus de la fonction de cout.
    if self.verbose &gt;= 2:
        print(f&#34;\tcalibration des parametres {vect_labels}&#34;)
        print(f&#34;\tbornes min: {tuple(b_min for b_min, _ in bounds)}&#34;)
        print(f&#34;\tbornes max: {tuple(b_max for _, b_max in bounds)}&#34;)
    
    # Recherche rapide d&#39;un minimum par descente de gradient.
    from scipy import optimize # On ne l&#39;importe que ici car on est pas sur de s&#39;en servir.
    if self.verbose &gt;= 2:
        print(&#34;\tOptimsation globale, algo genetique...&#34;)
    
    if multiprocessing.current_process().name == &#34;MainProcess&#34; and os.cpu_count() &gt; 4:
        attrs = [&#34;transformer&#34;, &#34;verbose&#34;]
        self_bis = collections.namedtuple(&#34;PartialExperiment&#34;, attrs, defaults=[getattr(self, attr) for attr in attrs])()
        opt_res = optimize.differential_evolution(
            _Picklable(cloudpickle.dumps(self_bis), Experiment._calibration_cost,
                {name: val for name, val in zip((&#34;known_params&#34;, &#34;vect_labels&#34;, &#34;spots_position&#34;), args)}
                ),
            updating=&#34;deferred&#34;,
            bounds=bounds,
            disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
            polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
            popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
            workers=-1) # Pour utiliser tous les cpus.
    else:
        opt_res = optimize.differential_evolution(
            self._calibration_cost,
            bounds=bounds,
            args=args,
            disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
            polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
            popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
            workers=1) # Pour ne pas creer de sous processus.
            # C&#39;est plus rapide de ne pas creer de sous processus que d&#39;en faire... car cloudpickle est lent!
    if self.verbose &gt;= 2:
        print(f&#34;\t\tOk: cout final = {opt_res[&#39;fun&#39;]}&#34;)
    fit_parameters_vect = opt_res[&#34;x&#34;]
    
    # Mise en forme du resultat.
    fit_parameters = {name: fit_parameters_vect[i] for i, name in enumerate(vect_labels)}
    self._calibration_parameters = {**given_parameters, **fit_parameters}
    self.transformer.compile(self._calibration_parameters) # Juste pour l&#39;optimisation.
    if self.verbose:
        print(f&#34;\tOK: set_calibration terminee: {self._calibration_parameters}&#34;)
    return self._calibration_parameters</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="laue.Transformer"><code class="flex name class">
<span>class <span class="ident">Transformer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Permet d'effectuer des transformations geometrique comme jongler
entre l'espace de la camera et l'espace gnomonique ou encore
s'ammuser avec la transformee de Hough.</p>
<p>Genere le dictionaire a protee globale.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transformer(Compilator):
    &#34;&#34;&#34;
    Permet d&#39;effectuer des transformations geometrique comme jongler
    entre l&#39;espace de la camera et l&#39;espace gnomonique ou encore
    s&#39;ammuser avec la transformee de Hough.
    &#34;&#34;&#34;
    def __init__(self):
        Compilator.__init__(self) # Globalisation des expressions.

        # Les memoires tampon.
        self._fcts_cam_to_gnomonic = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(x_cam, y_cam), les parametres sont deja remplaces.
        self._fcts_gnomonic_to_cam = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(x_gnom, y_gnom), les parametres sont deja remplaces.
        self._fcts_cam_to_thetachi = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(x_cam, y_cam), les parametres sont deja remplaces.
        self._fcts_thetachi_to_cam = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(theta, chi), les paremetres sont deja remplaces.
        self._parameters_memory = {} # Permet d&#39;eviter de relire le dictionaire des parametres a chaque fois.

    def compile(self, parameters=None):
        &#34;&#34;&#34;
        ** Precalcul toutes les equations. **

        Parameters
        ----------
        parameters : dict, optional
            Les parametres donnes par la fonction ``laue.utilities.parsing.extract_parameters``.
            Si ils sont fourni, l&#39;expression est encore un peu
            plus optimisee.
        &#34;&#34;&#34;
        super().compile()

        if parameters is not None:
            assert isinstance(parameters, dict), (&#34;Les parametres doivent founis &#34;
                f&#34;dans un dictionaire, pas dans un {type(parameters).__name__}&#34;)
            assert set(parameters) == {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;pixelsize&#34;}, \
                (&#34;Les clefs doivent etres &#39;dd&#39;, &#39;xbet&#39;, &#39;xgam&#39;, &#39;xcen&#39;, &#39;ycen&#39; et &#39;pixelsize&#39;. &#34;
                f&#34;Or les clefs sont {set(parameters)}.&#34;)
            assert all(isinstance(v, numbers.Number) for v in parameters.values()), \
                &#34;La valeurs des parametres doivent toutes etre des nombres.&#34;

            hash_param = self._hash_parameters(parameters)
            constants = {self.dd: parameters[&#34;dd&#34;], # C&#39;est qu&#39;il est tant de faire de l&#39;optimisation.
                         self.xcen: parameters[&#34;xcen&#34;],
                         self.ycen: parameters[&#34;ycen&#34;],
                         self.xbet: parameters[&#34;xbet&#34;],
                         self.xgam: parameters[&#34;xgam&#34;],
                         self.pixelsize: parameters[&#34;pixelsize&#34;]}
            # Dans le cas ou l&#39;expression est deserialise, les pointeurs ne sont plus les memes.
            constants = {str(var): value for var, value in constants.items()}
            for transform, args in {
                    &#34;cam_to_gnomonic&#34;: (self.x_cam, self.y_cam),
                    &#34;gnomonic_to_cam&#34;: (self.x_gnom, self.y_gnom),
                    &#34;cam_to_thetachi&#34;: (self.x_cam, self.y_cam),
                    &#34;thetachi_to_cam&#34;: (self.theta, self.chi)
                    }.items():
                formal_expr = getattr(self, f&#34;get_fct_{transform}&#34;)()()
                subs = {symbol: constants[str(symbol)]
                    for symbol in set.union(*(e.free_symbols for e in formal_expr))
                    if str(symbol) in constants}
                getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param] = lambdify.Lambdify(
                    args=args,
                    expr=lambdify.subs(formal_expr, subs))

        self.save() # On enregistre pour gagner du temps les prochaines fois.

    def cam_to_gnomonic(self, pxl_x, pxl_y, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points de la camera dans un plan gnomonic. **

        Parameters
        ----------
        pxl_x : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe x dans le repere de la camera. (en pxl)
        pxl_y : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe y dans le repere de la camera. (en pxl)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic eprimee.s en mm.
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.cam_to_gnomonic(x_cam, y_cam, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters, dtype=np.float64), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.cam_to_gnomonic(0.0, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
        ...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.cam_to_gnomonic(x_cam, y_cam, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;cam_to_gnomonic&#34;, pxl_x, pxl_y,
            parameters=parameters, dtype=dtype)

    def cam_to_thetachi(self, pxl_x, pxl_y, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points de la camera vers la representation theta et chi. **

        Parameters
        ----------
        pxl_x : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe x dans le repere de la camera. (en pxl)
        pxl_y : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe y dans le repere de la camera. (en pxl)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s theta puis chi du.des point.s. (en deg)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
        array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
               [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters, dtype=np.float64))
        array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
               [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.cam_to_thetachi(0.0, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
        ...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.cam_to_thetachi(x_cam, y_cam, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;cam_to_thetachi&#34;, pxl_x, pxl_y,
            parameters=parameters, dtype=dtype)

    def dist_line(self, theta_vect, dist_vect, x_vect, y_vect, *, dtype=np.float64):
        &#34;&#34;&#34;
        ** Calcul les distances projetees des points sur une droite. **

        Notes
        -----
        Pour des raisons de performances, travail avec des float32.

        Parameters
        ----------
        theta_vect : np.ndarray
            Les angles des droites normales aux droites principales.
            shape = ``(*nbr_droites)``
        dist_vect : np.ndarray
            Les distances entre les droites et l&#39;origine.
            shape = ``(*nbr_droites)``
        x_vect : np.ndarray
            L&#39;ensemble des coordonnees x des points.
            shape = ``(*nbr_points)``
        y_vect : np.ndarray
            L&#39;ensemble des coordonnees y des points.
            shape = ``(*nbr_points)``
        dtype : type, optional
            La representation machine des nombres.
            Attention pour les calcul en float32 et moins
            risque d&#39;y avoir des arrondis qui engendrent:
            ``RuntimeWarning: invalid value encountered in sqrt``.

        Returns
        -------
        np.ndarray
            Les distances des projetees des points sur chacunes des droites.
            shape = ``(*nbr_droites, *nbr_points)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt;
        &gt;&gt;&gt; lines = (np.array([0, np.pi/2]), np.array([1, 1])) # Horizontale et verticale passant par (1, 1)
        &gt;&gt;&gt; points = (np.array([0, 1, 3, 0]), np.array([0, 1, 3, 1])) # Le points (0, 1), ...
        &gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points))
        array([[1., 0., 2., 1.],
               [1., 0., 2., 0.]])
        &gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points, dtype=np.float32))
        array([[1., 0., 2., 1.],
               [1., 0., 2., 0.]], dtype=float32)
        &gt;&gt;&gt;
        &gt;&gt;&gt; theta_vect, dist_vect = np.random.normal(size=(1, 2)), np.random.normal(size=(1, 2))
        &gt;&gt;&gt; x_vect, y_vect = np.random.normal(size=(3, 4, 5)), np.random.normal(size=(3, 4, 5))
        &gt;&gt;&gt; transformer.dist_line(theta_vect, dist_vect, x_vect, y_vect).shape
        (1, 2, 3, 4, 5)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(theta_vect, np.ndarray), \
            f&#34;&#39;theta_vect&#39; has to be of type np.ndarray, not {type(theta_vect).__name__}.&#34;
        assert isinstance(dist_vect, np.ndarray), \
            f&#34;&#39;dist_vect&#39; has to be of type np.ndarray, not {type(dist_vect).__name__}.&#34;
        assert theta_vect.shape == dist_vect.shape, \
            f&#34;Les 2 parametres de droite doivent avoir la meme taille: {theta_vect.shape} vs {dist_vect.shape}.&#34;
        assert isinstance(x_vect, np.ndarray), \
            f&#34;&#39;x_vect&#39; has to be of type np.ndarray, not {type(x_vect).__name__}.&#34;
        assert isinstance(y_vect, np.ndarray), \
            f&#34;&#39;y_vect&#39; has to be of type np.ndarray, not {type(y_vect).__name__}.&#34;
        assert x_vect.shape == y_vect.shape, \
            f&#34;Les 2 coordonnees des points doivent avoir la meme shape: {x_vect.shape} vs {y_vect.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        theta_vect, dist_vect = theta_vect.astype(dtype, copy=False), dist_vect.astype(dtype, copy=False)
        x_vect, y_vect = x_vect.astype(dtype, copy=False), y_vect.astype(dtype, copy=False)

        nbr_droites = theta_vect.shape
        nbr_points = x_vect.shape

        # Ca ne vaut pas le coup de paralleliser car c&#39;est tres rapide.
        func = self.get_fct_dist_line()
        result = np.array([func(theta, dist, x_vect, y_vect)
                           for theta, dist
                           in zip(theta_vect.ravel(), dist_vect.ravel())
                          ], dtype=dtype).reshape((*nbr_droites, *nbr_points))
        return np.nan_to_num(result, copy=False, nan=0.0)

    def gnomonic_to_cam(self, gnom_x, gnom_y, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points du plan gnomonic vers la camera. **

        Parameters
        ----------
        gnom_x : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe x du repere du plan gnomonic. (en mm)
        gnom_y : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe y du repere du plan gnomonic. (en mm)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        coords : np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
        ...                              0.09978235,  0.17156848,  0.13417314 ],
        ...                            [ 0.40283853,  0.31846303,  0.14362221, 
        ...                             -0.18308422, -0.58226374, -0.93854752 ]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters, dtype=np.float64))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.gnomonic_to_cam(0.0, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
        ...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.gnomonic_to_cam(x_cam, y_cam, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;gnomonic_to_cam&#34;, gnom_x, gnom_y,
            parameters=parameters, dtype=dtype)

    def gnomonic_to_thetachi(self, gnom_x, gnom_y, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points du plan gnomonic vers theta et chi. **

        Parameters
        ----------
        gnom_x : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe x du repere du plan gnomonic. (en mm)
        gnom_y : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe y du repere du plan gnomonic. (en mm)
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s theta puis chi du.des point.s. (en deg)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
        ...                              0.09978235,  0.17156848,  0.13417314 ],
        ...                            [ 0.40283853,  0.31846303,  0.14362221, 
        ...                             -0.18308422, -0.58226374, -0.93854752 ]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
        array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
               [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom, dtype=np.float64))
        array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
               [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.gnomonic_to_thetachi(0.0, 0.0).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
        ...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.gnomonic_to_thetachi(x_cam, y_cam).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;gnomonic_to_thetachi&#34;, gnom_x, gnom_y,
            parameters=None, dtype=dtype)

    def hough(self, x_vect, y_vect, *, dtype=np.float64):
        r&#34;&#34;&#34;
        ** Transformee de hough avec des droites. **

        Note
        ----
        * Pour des raisons de performances, les calculs se font sur des float32.
        * Les indices sont agences selon l&#39;ordre defini par la fonction ``comb2ind``.

        Parameters
        ----------
        x_vect : np.ndarray
            L&#39;ensemble des coordonnees x des points de shape: (*over_dims, nbr_points)
        y_vect : np.ndarray
            L&#39;ensemble des coordonnees y des points de shape: (*over_dims, nbr_points)
        dtype : type, optional
            La representation machine des nombres.
            Attention pour les calculs en float32 et moins
            risque d&#39;y avoir des arrondis qui engendrent:
            ``RuntimeWarning: invalid value encountered in sqrt``.

        Returns
        -------
        np.ndarray
            * theta : np.ndarray
                * Les angles au sens trigomometrique des vecteurs reliant l&#39;origine
                ``O`` (0, 0) au point ``P`` appartenant a la droite tel que ``||OP||``
                soit la plus petite possible.
                * theta € [-pi, pi]
                * shape = ``(*over_dims, n*(n-1)/2)``
            * dist : np.ndarray
                * Ce sont les normes des vecteur ``OP``.
                * dist € [0, +oo].
                * shape = ``(*over_dims, n*(n-1)/2)``
            * Ces 2 grandeurs sont concatenees dans une seule array de
        shape = ``(2, *over_dims, n*(n-1)/2)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry import transformer
        &gt;&gt;&gt; transformer = transformer.Transformer()
        &gt;&gt;&gt; x, y = np.random.normal(size=(2, 6))
        &gt;&gt;&gt; transformer.hough(x, y).shape
        (2, 15)
        &gt;&gt;&gt;
        &gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
        &gt;&gt;&gt; transformer.hough(x, y).shape
        (2, 4, 5, 15)
        &gt;&gt;&gt; 
        &#34;&#34;&#34;
        assert isinstance(x_vect, np.ndarray), \
            f&#34;&#39;x_vect&#39; has to be of type np.ndarray, not {type(x_vect).__name__}.&#34;
        assert isinstance(y_vect, np.ndarray), \
            f&#34;&#39;y_vect&#39; has to be of type np.ndarray, not {type(y_vect).__name__}.&#34;
        assert x_vect.shape == y_vect.shape, \
            f&#34;Les 2 entrees doivent avoir la meme taille: {x_vect.shape} vs {y_vect.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        n = x_vect.shape[-1]
        if n == 1:
            over_dims = x_vect.shape[:-1]
            clusters = np.empty(np.prod(over_dims, dtype=int), dtype=object)
            clusters[:] = [[] for _ in range(clusters.size)]
            clusters = clusters.reshape(over_dims)
            return clusters
        
        x_vect, y_vect = x_vect.astype(dtype, copy=False), y_vect.astype(dtype, copy=False)

        xa = np.concatenate([np.repeat(x_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        ya = np.concatenate([np.repeat(y_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        xb = np.concatenate([x_vect[..., i+1:] for i in range(n-1)], axis=-1)
        yb = np.concatenate([y_vect[..., i+1:] for i in range(n-1)], axis=-1)

        return np.nan_to_num(
            np.stack(self.get_fct_hough()(xa, ya, xb, yb)),
            copy=False,
            nan=0.0)

    def hough_reduce(self, theta_vect, dist_vect, *, nbr=4, tol=0.018, dtype=np.float32):
        &#34;&#34;&#34;
        ** Regroupe des droites ressemblantes. **

        Notes
        -----
        * Cette methode est concue pour traiter les donnees issues de ``laue.core.geometry.transformer.Transformer.hough``.
        * La metrique utilise est la distance euclidiene sur un cylindre ferme sur theta.
        * En raison de performance et de memoire, les calculs se font sur des float32.

        Parameters
        ----------
        theta_vect : np.ndarray
            * Vecteur des angles compris entre [-pi, pi].
            * shape = ``(*over_dims, nbr_inter)``
        dist_vect : np.ndarray
            * Vecteur des distances des droites a l&#39;origine comprises [0, +oo].
            * shape = ``(*over_dims, nbr_inter)``
        tol : float
            La distance maximal separant 2 points dans l&#39;espace de hough reduit,
            (ie la difference entre 2 droites dans l&#39;espace spacial) tel que les points
            se retrouvent dans le meme cluster. Plus ce nombre est petit, plus les points
            doivent etre bien alignes. C&#39;est une sorte de tolerance sur l&#39;alignement.
        nbr : int
            C&#39;est le nombre minimum de points presque alignes pour que
            l&#39;on puisse considerer la droite qui passe par ces points.
            Par defaut, les droites qui ne passent que par 4 points et plus sont retenues.
        dtype : type, optional
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64``.
            ``np.float128`` est interdit car c&#39;est un peu over-kill pour cette methode!

        Returns
        -------
        np.ndarray(dtype=float), np.ndarray(dtype=object)
            * Ce sont les centres des clusters pour chaque &#39;nuages de points&#39;. Cela correspond
            aux angles et aux distances qui caracterisent chaque droites.
            * Si les parametres d&#39;entres sont des vecteurs 1d, le resultat sera une array
            numpy contenant les **angles** puis les **distances**. Donc de shape = ``(2, nbr_clusters)``
            * Si les parametres d&#39;entres sont en plusieur dimensions, (representes plusieur
            nuages de points indepandant), alors le resultat sera une array d&#39;objet de
            shape = ``(*over_dims)``. Chaque objet est lui meme un array, resultat recursif
            de l&#39;appel de cette fonction sur le nuage de points unique correspondant.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry import transformer
        &gt;&gt;&gt; transformer = transformer.Transformer()

        Type de retour ``float`` vs ``object``.
        &gt;&gt;&gt; x, y = (np.array([ 1.,  2.,  3.,  0., -1.]),
        ...         np.array([ 0.,  1.,  1., -1.,  1.]))
        &gt;&gt;&gt; theta, dist = transformer.hough(x, y)
        &gt;&gt;&gt; np.round(transformer.hough_reduce(theta, dist, nbr=3), 2)
        array([[-0.79,  1.57],
               [ 0.71,  1.  ]], dtype=float32)
        &gt;&gt;&gt; res = transformer.hough_reduce(theta.reshape((1, -1)), dist.reshape((1, -1)), nbr=3)
        &gt;&gt;&gt; res.dtype
        dtype(&#39;O&#39;)
        &gt;&gt;&gt; res.shape
        (1,)
        &gt;&gt;&gt; np.round(res[0], 2)
        array([[-0.79,  1.57],
               [ 0.71,  1.  ]], dtype=float32)
        &gt;&gt;&gt;

        Les dimensions de retour.
        &gt;&gt;&gt; x, y = (np.random.normal(size=(6, 5, 4)),
        ...         np.random.normal(size=(6, 5, 4)))
        &gt;&gt;&gt; theta, dist = transformer.hough(x, y)
        &gt;&gt;&gt; transformer.hough_reduce(theta, dist).shape
        (6, 5)
        &gt;&gt;&gt; 
        &#34;&#34;&#34;
        assert isinstance(theta_vect, np.ndarray), \
            f&#34;&#39;theta_vect&#39; has to be of type np.ndarray, not {type(theta_vect).__name__}.&#34;
        assert isinstance(dist_vect, np.ndarray), \
            f&#34;&#39;dist_vect&#39; has to be of type np.ndarray, not {type(dist_vect).__name__}.&#34;
        assert theta_vect.shape == dist_vect.shape, \
            f&#34;Les 2 entrees doivent avoir la meme taille: {theta_vect.shape} vs {dist_vect.shape}.&#34;
        assert theta_vect.ndim &gt;= 1, &#34;La matrice ne doit pas etre vide.&#34;
        assert isinstance(tol, float), f&#34;&#39;tol&#39; has to be a float, not a {type(tol).__name__}.&#34;
        assert 0.0 &lt; tol &lt;= 0.5, (&#34;Les valeurs coherentes de &#39;tol&#39; se trouvent entre &#34;
            f&#34;]0, 1/2], or tol vaut {tol}, ce qui sort de cet intervalle.&#34;)
        assert isinstance(nbr, int), f&#34;&#39;nbr&#39; has to be an integer, not a {type(nbr).__name__}.&#34;
        assert 2 &lt; nbr, f&#34;2 points sont toujours alignes! Vous ne pouvez pas choisir nbr={nbr}.&#34;
        assert dtype in {np.float16, np.float32, np.float64}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64. Pas {dtype}.&#34;

        # On fait la conversion des le debut pour un gain de temps.
        theta_vect, dist_vect = theta_vect.astype(dtype, copy=False), dist_vect.astype(dtype, copy=False)

        *over_dims, nbr_inter = theta_vect.shape # Recuperation des dimensions.
        nbr = (nbr*(nbr-1))/2 # On converti le nombre de points alignes en nbr de segments.

        # On commence par travailler avec les donnees reduites.
        theta_theo_std = math.pi / math.sqrt(3) # Variance theorique = (math.pi - -math.pi)**2 / 12
        dist_std = np.nanstd(dist_vect, axis=-1) # Ecart type non biaise (sum(*over_dims)/N), shape: (*over_dims)
        dist_vect = (dist_vect * theta_theo_std
            / np.repeat(dist_std[..., np.newaxis], nbr_inter, axis=-1)) # Les distances quasi reduites.
        
        # Extraction des clusters.
        if not len(over_dims): # Cas des tableaux 1d.
            return self._clustering_1d(theta_vect, dist_vect, dist_std, tol, nbr)

        clusters = np.empty(np.prod(over_dims, dtype=int), dtype=object) # On doit d&#39;abord creer un tableau d&#39;objet 1d.
        if multiprocessing.current_process().name == &#34;MainProcess&#34; and np.prod(over_dims) &gt;= os.cpu_count(): # Si ca vaut le coup de parraleliser:
            ser_self = cloudpickle.dumps(self) # Strategie car &#39;pickle&#39; ne sais pas faire ca.
            from laue.utilities.multi_core import pickleable_method
            with multiprocessing.Pool() as pool:
                clusters[:] = pool.map(
                    pickleable_method, # Car si il y a autant de cluster dans chaque image,
                    (                   # numpy aurait envi de faire un tableau 2d plutot qu&#39;un vecteur de listes.
                        (
                            Transformer._clustering_1d,
                            ser_self,
                            {&#34;theta_vect_1d&#34;:theta, &#34;dist_vect_1d&#34;:dist, &#34;std&#34;:std, &#34;tol&#34;:tol, &#34;nbr&#34;:nbr}
                        )
                        for theta, dist, std
                        in zip(
                            theta_vect.reshape((-1, nbr_inter)),
                            dist_vect.reshape((-1, nbr_inter)),
                            np.nditer(dist_std)
                        )
                    )
                )
        else:
            clusters[:] = [self._clustering_1d(theta, dist, std, tol, nbr)
                           for theta, dist, std in zip(
                                    theta_vect.reshape((-1, nbr_inter)),
                                    dist_vect.reshape((-1, nbr_inter)),
                                    np.nditer(dist_std))] 
        clusters = clusters.reshape(over_dims) # On redimensione a la fin de sorte a garentir les dimensions.

        return clusters

    def inter_lines(self, theta_vect, dist_vect, *, dtype=np.float32):
        r&#34;&#34;&#34;
        ** Calcul les points d&#39;intersection entre les droites. **

        Notes
        -----
        * Cette methode est concue pour traiter les donnees issues de ``laue.core.geometry.transformer.Transformer.hough``.
        * En raison de performance et de memoire, les calculs se font sur des float32.
        * Les indices sont agences selon l&#39;ordre defini par la fonction ``comb2ind``.

        Parameters
        ----------
        theta_vect : np.ndarray
            * Vecteur des angles compris entre [-pi, pi].
            * shape = (*over_dims, nbr_droites)
        dist_vect : np.ndarray
            * Vecteur des distances des droites a l&#39;origine comprises [0, +oo].
            * shape = (*over_dims, nbr_droites)
        dtype : type, optional
            La representation machine des nombres. Par defaut
            ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser
            ``np.float64`` ou ``(getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)``.

        Returns
        -------
        np.ndarray
            * Dans le dommaine spatial et non pas le domaine de hough, cherche
            les intersections des droites. Il y a ``n*(n-1)/2`` intersections, n etant
            le nombre de droites. donc la complexite de cette methode est en ``o(n**2)``.
            * Si les vecteurs d&#39;entre sont des vecteurs 1d (ie ``*over_dims == ()``), 
            Seront retournes le vecteur d&#39;intersection selon l&#39;axe x et le vecteur
            des intersections selon l&#39;axe y. Ces 2 vecteurs de meme taille sont concatenes
            sous la forme d&#39;une matrice de shape = ``(2, n*(n-1)/2)``.
            * Si les vecteurs d&#39;entre sont en plusieurs dimensions, seul les droites de la
            derniere dimensions se retrouvent dans la meme famille. Tous comme pour les
            vecteurs 1d, on trouve d&#39;abord les intersections selon x puis en suite selon y.
            La shape du tenseur final est donc: ** shape = ``(2, *over_dims, n*(n-1)/2)`` **.

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; np.random.seed(0)
        &gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
        &gt;&gt;&gt; theta, dist = transformer.hough(x, y)
        &gt;&gt;&gt; theta.shape
        (4, 5, 15)
        &gt;&gt;&gt; transformer.inter_lines(theta, dist).shape
        (2, 4, 5, 105)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(theta_vect, np.ndarray), \
            f&#34;&#39;theta_vect&#39; has to be of type np.ndarray, not {type(theta_vect).__name__}.&#34;
        assert isinstance(dist_vect, np.ndarray), \
            f&#34;&#39;dist_vect&#39; has to be of type np.ndarray, not {type(dist_vect).__name__}.&#34;
        assert theta_vect.shape == dist_vect.shape, \
            f&#34;Les 2 entrees doivent avoir la meme taille: {theta_vect.shape} vs {dist_vect.shape}.&#34;
        assert theta_vect.ndim &gt;= 1, &#34;La matrice ne doit pas etre vide.&#34;
        assert theta_vect.shape[-1] &gt;= 2, \
            f&#34;Il doit y avoir au moins 2 droites par famille, pas {theta_vect.shape[-1]}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        theta_vect, dist_vect = theta_vect.astype(dtype, copy=False), dist_vect.astype(dtype, copy=False)
        n = theta_vect.shape[-1]

        theta_1 = np.concatenate([np.repeat(theta_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        dist_1 = np.concatenate([np.repeat(dist_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        theta_2 = np.concatenate([theta_vect[..., i+1:] for i in range(n-1)], axis=-1)
        dist_2 = np.concatenate([dist_vect[..., i+1:] for i in range(n-1)], axis=-1)

        return np.stack(self.get_fct_inter_line()(theta_1, dist_1, theta_2, dist_2))

    def thetachi_to_cam(self, theta, chi, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe de la representation theta et chi vers la camera. **

        Parameters
        ----------
        theta : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de y. (en deg)
        chi : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de x. (en deg)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        coords : np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; theta, chi = np.array([[ 1.1101143, 1.0456189, 0.8965300,
        ...                          0.6727613, 0.5244697, 0.4603832],
        ...                        [ 0.8622506, 0.6103422, 0.2279670,
        ...                         -0.2312180,-0.6126410,-0.8636999]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.thetachi_to_cam(theta, chi, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters, dtype=np.float64))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.thetachi_to_cam(np.pi/4, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
        ...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.thetachi_to_cam(theta, chi, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;thetachi_to_cam&#34;, theta, chi,
            parameters=parameters, dtype=dtype)

    def thetachi_to_gnomonic(self, theta, chi, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe de la representation theta et chi vers une projection gnomonique. **

        Parameters
        ----------
        theta : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de y. (en deg)
        chi : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de x. (en deg)
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic eprimee.s en mm.
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; theta, chi = np.array([[ 1.1101143, 1.0456189, 0.8965300,
        ...                          0.6727613, 0.5244697, 0.4603832],
        ...                        [ 0.8622506, 0.6103422, 0.2279670,
        ...                         -0.2312180,-0.6126410,-0.8636999]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.thetachi_to_gnomonic(theta, chi))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi, dtype=np.float64), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.thetachi_to_gnomonic(np.pi/4, 0.0).shape
        (2,)
        &gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
        ...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.thetachi_to_gnomonic(theta, chi).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;thetachi_to_gnomonic&#34;, theta, chi,
            parameters=None, dtype=dtype)

    def _clustering_1d(self, theta_vect_1d, dist_vect_1d, std, tol, nbr):
        &#34;&#34;&#34;
        ** Help for hough_reduce. **

        * Permet de trouver les clusters d&#39;un nuage de points.
        * La projection 3d, bien que moins realiste, est 20% plus rapide que la distance reele.
        &#34;&#34;&#34;
        from sklearn.cluster import DBSCAN

        dtype_catser = theta_vect_1d.dtype.type
        THETA_STD = dtype_catser(math.pi / math.sqrt(3))
        WEIGHT = 0.65 # 0 =&gt; tres souple sur les angles, 1=&gt; tres souple sur les distances.

        # On retire les droites aberantes.
        mask_to_keep = np.isfinite(theta_vect_1d) &amp; np.isfinite(dist_vect_1d)
        if not mask_to_keep.any(): # Si il ne reste plus rien.
            return np.array([], dtype=dtype_catser)
        theta_vect_1d, dist_vect_1d = theta_vect_1d[mask_to_keep], dist_vect_1d[mask_to_keep]

        # On passe dans un autre repere de facon a ce que -pi et pi se retrouvent a cote.
        if numexpr is not None:
            theta_x = numexpr.evaluate(&#34;2*WEIGHT*cos(theta_vect_1d)&#34;)
            theta_y = numexpr.evaluate(&#34;2*WEIGHT*sin(theta_vect_1d)&#34;)
        else:
            theta_x, theta_y = 2*WEIGHT*np.cos(theta_vect_1d), 2*WEIGHT*np.sin(theta_vect_1d)

        # Recherche des clusters.
        n_jobs = -1 if multiprocessing.current_process().name == &#34;MainProcess&#34; else 1
        db_res = DBSCAN(eps=tol, min_samples=nbr, n_jobs=n_jobs).fit(
            np.vstack((theta_x, theta_y, 2*(1-WEIGHT)*dist_vect_1d)).transpose())

        # Mise en forme des clusters.
        clusters_dict = collections.defaultdict(lambda: [])
        keep = db_res.labels_ != -1 # Les indices des clusters a garder.
        for x_cyl, y_cyl, dist, group in zip(
                theta_x[keep], theta_y[keep], dist_vect_1d[keep], db_res.labels_[keep]):
            clusters_dict[group].append((x_cyl, y_cyl, dist))

        theta = np.array([np.arccos(cluster[:, 0].mean()/(2*WEIGHT))*np.sign(cluster[:, 1].sum())
                    for cluster in map(np.array, clusters_dict.values())],
                    dtype=dtype_catser)
        dist = np.array([cluster[:, 2].mean()
                        for cluster in map(np.array, clusters_dict.values())],
                    dtype=dtype_catser) * std / THETA_STD
        return np.array([theta, dist], dtype=dtype_catser)

    def _generic_transformation(self, transform, data1, data2, *, parameters, dtype):
        &#34;&#34;&#34;
        ** Passe d&#39;un espace de representation a un autre. **

        Help for ``Transformer.truc_to_machin``.

        Notes
        -----
        Fait les verifications.
        &#34;&#34;&#34;
        assert isinstance(data1, (float, int, np.ndarray)), \
            f&#34;&#39;data1&#39; can not be of type {type(data1).__name__}.&#34;
        assert isinstance(data2, (float, int, np.ndarray)), \
            f&#34;&#39;data2&#39; can not be of type {type(data2).__name__}.&#34;
        assert type(data1) == type(data2), \
            f&#34;Les 2 types sont differents: {type(data1).__name__} vs {type(data2).__name__}.&#34;
        if isinstance(data1, np.ndarray):
            assert data1.shape == data2.shape, \
                f&#34;Ils n&#39;ont pas le meme taille: {data1.shape} vs {data2.shape}.&#34;
        if parameters is not None:
            assert isinstance(parameters, dict), (&#34;Les parametres doivent founis &#34;
                f&#34;dans un dictionaire, pas dans un {type(parameters).__name__}&#34;)
            assert set(parameters) == {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;pixelsize&#34;}, \
                (&#34;Les clefs doivent etres &#39;dd&#39;, &#39;xbet&#39;, &#39;xgam&#39;, &#39;xcen&#39;, &#39;ycen&#39; et &#39;pixelsize&#39;. &#34;
                f&#34;Or les clefs sont {set(parameters)}.&#34;)
            assert all(isinstance(v, numbers.Number) for v in parameters.values()), \
                &#34;La valeurs des parametres doivent toutes etre des nombres.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        if isinstance(data1, np.ndarray):
            data1, data2 = data1.astype(dtype, copy=False), data2.astype(dtype, copy=False)
        else:
            data1, data2 = dtype(data1), dtype(data2)
        
        if parameters is not None:
            parameters = {k: dtype(v) for k, v in parameters.items()} # Pour eviter par la suite de mauvais casts.
            hash_param = self._hash_parameters(parameters) # Recuperation de la &#39;signature&#39; des parametres.
            optimized_func = getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param] # On regarde si il y a une fonction deja optimisee.

            if isinstance(optimized_func, int): # Si il n&#39;y a pas de fonction optimisee.
                nbr_access = optimized_func # Ce qui est enregistre et le nombre de fois que l&#39;on a chercher a y acceder.
                getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param] += 1 # Comme on cherche a y acceder actuelement, on peut incrementer le compteur.
                if nbr_access + 1 == 4: # Si c&#39;est la 4 eme fois qu&#39;on accede a la fonction.
                    self.compile(parameters) # On optimise la fonction.
                else: # Si ce n&#39;est pas encore le moment de perdre du temps a optimiser.
                    return np.stack(getattr(self, f&#34;get_fct_{transform}&#34;)()(
                        data1, data2,
                        parameters[&#34;dd&#34;], parameters[&#34;xcen&#34;], parameters[&#34;ycen&#34;],
                        parameters[&#34;xbet&#34;], parameters[&#34;xgam&#34;], parameters[&#34;pixelsize&#34;]))

            return np.stack(getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param](data1, data2))

        return np.stack(getattr(self, f&#34;get_fct_{transform}&#34;)()(data1, data2))

    def _hash_parameters(self, parameters):
        &#34;&#34;&#34;
        ** Hache le dictionaire des parametres. **

        * Il n&#39;y a pas de verification pour des histoires de performances.

        Parameters
        ----------
        parameters : dict
            Dictionaire des parametres issues de ``laue.utilities.parsing.extract_parameters``.

        Returns
        -------
        int
            Un identifiant tq 2 dictionaires identiques renvoient le meme id.
        &#34;&#34;&#34;
        return hash(( # Il faut imperativement garantir l&#39;ordre.
            parameters[&#34;dd&#34;],
            parameters[&#34;xcen&#34;],
            parameters[&#34;ycen&#34;],
            parameters[&#34;xbet&#34;],
            parameters[&#34;xgam&#34;],
            parameters[&#34;pixelsize&#34;]))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="laue.core.geometry.symbolic.Compilator" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator">Compilator</a></li>
<li><a title="laue.core.geometry.symbolic.Equations" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations">Equations</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laue.Transformer.cam_to_gnomonic"><code class="name flex">
<span>def <span class="ident">cam_to_gnomonic</span></span>(<span>self, pxl_x, pxl_y, parameters, *, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Passe des points de la camera dans un plan gnomonic. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pxl_x</code></strong> :&ensp;<code>float, int ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des pxl.s selon l'axe x dans le repere de la camera. (en pxl)</dd>
<dt><strong><code>pxl_y</code></strong> :&ensp;<code>float, int ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des pxl.s selon l'axe y dans le repere de la camera. (en pxl)</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>Le dictionaire issue de la fonction <code><a title="laue.utilities.parsing.extract_parameters" href="utilities/parsing.html#laue.utilities.parsing.extract_parameters">extract_parameters()</a></code>.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>Si l'entree est un nombre et non pas une array numpy. Les calculs sont fait en <code>float</code>.
La representation machine des nombres. Par defaut <code>np.float32</code> permet des calculs rapide
mais peu precis. Pour la presision il faut utiliser <code>np.float64</code> ou <code>np.float128</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float ou np.ndarray</code></dt>
<dd>
<ul>
<li>Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic eprimee.s en mm.</li>
<li>shape = (2, *shape_d_entree)</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
&gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
&gt;&gt;&gt;
</code></pre>
<p>Output type</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; type(transformer.cam_to_gnomonic(x_cam, y_cam, parameters))
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters), 2)
array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
       [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
&gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters, dtype=np.float64), 2)
array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
       [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
&gt;&gt;&gt;
</code></pre>
<p>Output shape</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; transformer.cam_to_gnomonic(0.0, 0.0, parameters).shape
(2,)
&gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
&gt;&gt;&gt; transformer.cam_to_gnomonic(x_cam, y_cam, parameters).shape
(2, 1, 2, 3)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cam_to_gnomonic(self, pxl_x, pxl_y, parameters, *, dtype=np.float32):
    &#34;&#34;&#34;
    ** Passe des points de la camera dans un plan gnomonic. **

    Parameters
    ----------
    pxl_x : float, int ou np.ndarray
        Coordonnee.s du.des pxl.s selon l&#39;axe x dans le repere de la camera. (en pxl)
    pxl_y : float, int ou np.ndarray
        Coordonnee.s du.des pxl.s selon l&#39;axe y dans le repere de la camera. (en pxl)
    parameters : dict
        Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
    dtype : type, optional
        Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
        La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
        mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

    Returns
    -------
    float ou np.ndarray
        * Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic eprimee.s en mm.
        * shape = (2, *shape_d_entree)

    Examples
    -------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
    &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
    &gt;&gt;&gt;

    Output type
    &gt;&gt;&gt; type(transformer.cam_to_gnomonic(x_cam, y_cam, parameters))
    &lt;class &#39;numpy.ndarray&#39;&gt;
    &gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters), 2)
    array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
           [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
    &gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters, dtype=np.float64), 2)
    array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
           [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
    &gt;&gt;&gt;
    
    Output shape
    &gt;&gt;&gt; transformer.cam_to_gnomonic(0.0, 0.0, parameters).shape
    (2,)
    &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
    ...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
    &gt;&gt;&gt; transformer.cam_to_gnomonic(x_cam, y_cam, parameters).shape
    (2, 1, 2, 3)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return self._generic_transformation(&#34;cam_to_gnomonic&#34;, pxl_x, pxl_y,
        parameters=parameters, dtype=dtype)</code></pre>
</details>
</dd>
<dt id="laue.Transformer.cam_to_thetachi"><code class="name flex">
<span>def <span class="ident">cam_to_thetachi</span></span>(<span>self, pxl_x, pxl_y, parameters, *, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Passe des points de la camera vers la representation theta et chi. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pxl_x</code></strong> :&ensp;<code>float, int ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des pxl.s selon l'axe x dans le repere de la camera. (en pxl)</dd>
<dt><strong><code>pxl_y</code></strong> :&ensp;<code>float, int ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des pxl.s selon l'axe y dans le repere de la camera. (en pxl)</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>Le dictionaire issue de la fonction <code><a title="laue.utilities.parsing.extract_parameters" href="utilities/parsing.html#laue.utilities.parsing.extract_parameters">extract_parameters()</a></code>.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>Si l'entree est un nombre et non pas une array numpy. Les calculs sont fait en <code>float</code>.
La representation machine des nombres. Par defaut <code>np.float32</code> permet des calculs rapide
mais peu precis. Pour la presision il faut utiliser <code>np.float64</code> ou <code>np.float128</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float ou np.ndarray</code></dt>
<dd>
<ul>
<li>Le.s coordonnee.s theta puis chi du.des point.s. (en deg)</li>
<li>shape = (2, *shape_d_entree)</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
&gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
&gt;&gt;&gt;
</code></pre>
<p>Output type</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; type(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
       [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]], dtype=float32)
&gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters, dtype=np.float64))
array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
       [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]])
&gt;&gt;&gt;
</code></pre>
<p>Output shape</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; transformer.cam_to_thetachi(0.0, 0.0, parameters).shape
(2,)
&gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
&gt;&gt;&gt; transformer.cam_to_thetachi(x_cam, y_cam, parameters).shape
(2, 1, 2, 3)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cam_to_thetachi(self, pxl_x, pxl_y, parameters, *, dtype=np.float32):
    &#34;&#34;&#34;
    ** Passe des points de la camera vers la representation theta et chi. **

    Parameters
    ----------
    pxl_x : float, int ou np.ndarray
        Coordonnee.s du.des pxl.s selon l&#39;axe x dans le repere de la camera. (en pxl)
    pxl_y : float, int ou np.ndarray
        Coordonnee.s du.des pxl.s selon l&#39;axe y dans le repere de la camera. (en pxl)
    parameters : dict
        Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
    dtype : type, optional
        Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
        La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
        mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

    Returns
    -------
    float ou np.ndarray
        * Le.s coordonnee.s theta puis chi du.des point.s. (en deg)
        * shape = (2, *shape_d_entree)

    Examples
    -------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
    &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
    &gt;&gt;&gt;

    Output type
    &gt;&gt;&gt; type(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
    &lt;class &#39;numpy.ndarray&#39;&gt;
    &gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
    array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
           [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]], dtype=float32)
    &gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters, dtype=np.float64))
    array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
           [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]])
    &gt;&gt;&gt;
    
    Output shape
    &gt;&gt;&gt; transformer.cam_to_thetachi(0.0, 0.0, parameters).shape
    (2,)
    &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
    ...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
    &gt;&gt;&gt; transformer.cam_to_thetachi(x_cam, y_cam, parameters).shape
    (2, 1, 2, 3)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return self._generic_transformation(&#34;cam_to_thetachi&#34;, pxl_x, pxl_y,
        parameters=parameters, dtype=dtype)</code></pre>
</details>
</dd>
<dt id="laue.Transformer.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self, parameters=None)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Precalcul toutes les equations. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parameters</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Les parametres donnes par la fonction <code><a title="laue.utilities.parsing.extract_parameters" href="utilities/parsing.html#laue.utilities.parsing.extract_parameters">extract_parameters()</a></code>.
Si ils sont fourni, l'expression est encore un peu
plus optimisee.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(self, parameters=None):
    &#34;&#34;&#34;
    ** Precalcul toutes les equations. **

    Parameters
    ----------
    parameters : dict, optional
        Les parametres donnes par la fonction ``laue.utilities.parsing.extract_parameters``.
        Si ils sont fourni, l&#39;expression est encore un peu
        plus optimisee.
    &#34;&#34;&#34;
    super().compile()

    if parameters is not None:
        assert isinstance(parameters, dict), (&#34;Les parametres doivent founis &#34;
            f&#34;dans un dictionaire, pas dans un {type(parameters).__name__}&#34;)
        assert set(parameters) == {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;pixelsize&#34;}, \
            (&#34;Les clefs doivent etres &#39;dd&#39;, &#39;xbet&#39;, &#39;xgam&#39;, &#39;xcen&#39;, &#39;ycen&#39; et &#39;pixelsize&#39;. &#34;
            f&#34;Or les clefs sont {set(parameters)}.&#34;)
        assert all(isinstance(v, numbers.Number) for v in parameters.values()), \
            &#34;La valeurs des parametres doivent toutes etre des nombres.&#34;

        hash_param = self._hash_parameters(parameters)
        constants = {self.dd: parameters[&#34;dd&#34;], # C&#39;est qu&#39;il est tant de faire de l&#39;optimisation.
                     self.xcen: parameters[&#34;xcen&#34;],
                     self.ycen: parameters[&#34;ycen&#34;],
                     self.xbet: parameters[&#34;xbet&#34;],
                     self.xgam: parameters[&#34;xgam&#34;],
                     self.pixelsize: parameters[&#34;pixelsize&#34;]}
        # Dans le cas ou l&#39;expression est deserialise, les pointeurs ne sont plus les memes.
        constants = {str(var): value for var, value in constants.items()}
        for transform, args in {
                &#34;cam_to_gnomonic&#34;: (self.x_cam, self.y_cam),
                &#34;gnomonic_to_cam&#34;: (self.x_gnom, self.y_gnom),
                &#34;cam_to_thetachi&#34;: (self.x_cam, self.y_cam),
                &#34;thetachi_to_cam&#34;: (self.theta, self.chi)
                }.items():
            formal_expr = getattr(self, f&#34;get_fct_{transform}&#34;)()()
            subs = {symbol: constants[str(symbol)]
                for symbol in set.union(*(e.free_symbols for e in formal_expr))
                if str(symbol) in constants}
            getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param] = lambdify.Lambdify(
                args=args,
                expr=lambdify.subs(formal_expr, subs))

    self.save() # On enregistre pour gagner du temps les prochaines fois.</code></pre>
</details>
</dd>
<dt id="laue.Transformer.dist_line"><code class="name flex">
<span>def <span class="ident">dist_line</span></span>(<span>self, theta_vect, dist_vect, x_vect, y_vect, *, dtype=numpy.float64)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Calcul les distances projetees des points sur une droite. </strong></p>
<h2 id="notes">Notes</h2>
<p>Pour des raisons de performances, travail avec des float32.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Les angles des droites normales aux droites principales.
shape = <code>(*nbr_droites)</code></dd>
<dt><strong><code>dist_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Les distances entre les droites et l'origine.
shape = <code>(*nbr_droites)</code></dd>
<dt><strong><code>x_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>L'ensemble des coordonnees x des points.
shape = <code>(*nbr_points)</code></dd>
<dt><strong><code>y_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>L'ensemble des coordonnees y des points.
shape = <code>(*nbr_points)</code></dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>La representation machine des nombres.
Attention pour les calcul en float32 et moins
risque d'y avoir des arrondis qui engendrent:
<code>RuntimeWarning: invalid value encountered in sqrt</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Les distances des projetees des points sur chacunes des droites.
shape = <code>(*nbr_droites, *nbr_points)</code></dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
&gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt;
&gt;&gt;&gt; lines = (np.array([0, np.pi/2]), np.array([1, 1])) # Horizontale et verticale passant par (1, 1)
&gt;&gt;&gt; points = (np.array([0, 1, 3, 0]), np.array([0, 1, 3, 1])) # Le points (0, 1), ...
&gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points))
array([[1., 0., 2., 1.],
       [1., 0., 2., 0.]])
&gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points, dtype=np.float32))
array([[1., 0., 2., 1.],
       [1., 0., 2., 0.]], dtype=float32)
&gt;&gt;&gt;
&gt;&gt;&gt; theta_vect, dist_vect = np.random.normal(size=(1, 2)), np.random.normal(size=(1, 2))
&gt;&gt;&gt; x_vect, y_vect = np.random.normal(size=(3, 4, 5)), np.random.normal(size=(3, 4, 5))
&gt;&gt;&gt; transformer.dist_line(theta_vect, dist_vect, x_vect, y_vect).shape
(1, 2, 3, 4, 5)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist_line(self, theta_vect, dist_vect, x_vect, y_vect, *, dtype=np.float64):
    &#34;&#34;&#34;
    ** Calcul les distances projetees des points sur une droite. **

    Notes
    -----
    Pour des raisons de performances, travail avec des float32.

    Parameters
    ----------
    theta_vect : np.ndarray
        Les angles des droites normales aux droites principales.
        shape = ``(*nbr_droites)``
    dist_vect : np.ndarray
        Les distances entre les droites et l&#39;origine.
        shape = ``(*nbr_droites)``
    x_vect : np.ndarray
        L&#39;ensemble des coordonnees x des points.
        shape = ``(*nbr_points)``
    y_vect : np.ndarray
        L&#39;ensemble des coordonnees y des points.
        shape = ``(*nbr_points)``
    dtype : type, optional
        La representation machine des nombres.
        Attention pour les calcul en float32 et moins
        risque d&#39;y avoir des arrondis qui engendrent:
        ``RuntimeWarning: invalid value encountered in sqrt``.

    Returns
    -------
    np.ndarray
        Les distances des projetees des points sur chacunes des droites.
        shape = ``(*nbr_droites, *nbr_points)``

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
    &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt;
    &gt;&gt;&gt; lines = (np.array([0, np.pi/2]), np.array([1, 1])) # Horizontale et verticale passant par (1, 1)
    &gt;&gt;&gt; points = (np.array([0, 1, 3, 0]), np.array([0, 1, 3, 1])) # Le points (0, 1), ...
    &gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points))
    array([[1., 0., 2., 1.],
           [1., 0., 2., 0.]])
    &gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points, dtype=np.float32))
    array([[1., 0., 2., 1.],
           [1., 0., 2., 0.]], dtype=float32)
    &gt;&gt;&gt;
    &gt;&gt;&gt; theta_vect, dist_vect = np.random.normal(size=(1, 2)), np.random.normal(size=(1, 2))
    &gt;&gt;&gt; x_vect, y_vect = np.random.normal(size=(3, 4, 5)), np.random.normal(size=(3, 4, 5))
    &gt;&gt;&gt; transformer.dist_line(theta_vect, dist_vect, x_vect, y_vect).shape
    (1, 2, 3, 4, 5)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(theta_vect, np.ndarray), \
        f&#34;&#39;theta_vect&#39; has to be of type np.ndarray, not {type(theta_vect).__name__}.&#34;
    assert isinstance(dist_vect, np.ndarray), \
        f&#34;&#39;dist_vect&#39; has to be of type np.ndarray, not {type(dist_vect).__name__}.&#34;
    assert theta_vect.shape == dist_vect.shape, \
        f&#34;Les 2 parametres de droite doivent avoir la meme taille: {theta_vect.shape} vs {dist_vect.shape}.&#34;
    assert isinstance(x_vect, np.ndarray), \
        f&#34;&#39;x_vect&#39; has to be of type np.ndarray, not {type(x_vect).__name__}.&#34;
    assert isinstance(y_vect, np.ndarray), \
        f&#34;&#39;y_vect&#39; has to be of type np.ndarray, not {type(y_vect).__name__}.&#34;
    assert x_vect.shape == y_vect.shape, \
        f&#34;Les 2 coordonnees des points doivent avoir la meme shape: {x_vect.shape} vs {y_vect.shape}.&#34;
    assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
        f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

    theta_vect, dist_vect = theta_vect.astype(dtype, copy=False), dist_vect.astype(dtype, copy=False)
    x_vect, y_vect = x_vect.astype(dtype, copy=False), y_vect.astype(dtype, copy=False)

    nbr_droites = theta_vect.shape
    nbr_points = x_vect.shape

    # Ca ne vaut pas le coup de paralleliser car c&#39;est tres rapide.
    func = self.get_fct_dist_line()
    result = np.array([func(theta, dist, x_vect, y_vect)
                       for theta, dist
                       in zip(theta_vect.ravel(), dist_vect.ravel())
                      ], dtype=dtype).reshape((*nbr_droites, *nbr_points))
    return np.nan_to_num(result, copy=False, nan=0.0)</code></pre>
</details>
</dd>
<dt id="laue.Transformer.gnomonic_to_cam"><code class="name flex">
<span>def <span class="ident">gnomonic_to_cam</span></span>(<span>self, gnom_x, gnom_y, parameters, *, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Passe des points du plan gnomonic vers la camera. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gnom_x</code></strong> :&ensp;<code>float ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des point.s selon l'axe x du repere du plan gnomonic. (en mm)</dd>
<dt><strong><code>gnom_y</code></strong> :&ensp;<code>float ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des point.s selon l'axe y du repere du plan gnomonic. (en mm)</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>Le dictionaire issue de la fonction <code><a title="laue.utilities.parsing.extract_parameters" href="utilities/parsing.html#laue.utilities.parsing.extract_parameters">extract_parameters()</a></code>.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>Si l'entree est un nombre et non pas une array numpy. Les calculs sont fait en <code>float</code>.
La representation machine des nombres. Par defaut <code>np.float32</code> permet des calculs rapide
mais peu precis. Pour la presision il faut utiliser <code>np.float64</code> ou <code>np.float128</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>
<ul>
<li>Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)</li>
<li>shape = (2, *shape_d_entree)</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
&gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
...                              0.09978235,  0.17156848,  0.13417314 ],
...                            [ 0.40283853,  0.31846303,  0.14362221, 
...                             -0.18308422, -0.58226374, -0.93854752 ]])
&gt;&gt;&gt;
</code></pre>
<p>Output type</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; type(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
array([[   3.,  412.,  821., 1230., 1639., 2048.],
       [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
&gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters, dtype=np.float64))
array([[   3.,  412.,  821., 1230., 1639., 2048.],
       [   3.,  412.,  821., 1230., 1639., 2048.]])
&gt;&gt;&gt;
</code></pre>
<p>Output shape</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; transformer.gnomonic_to_cam(0.0, 0.0, parameters).shape
(2,)
&gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
&gt;&gt;&gt; transformer.gnomonic_to_cam(x_cam, y_cam, parameters).shape
(2, 1, 2, 3)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gnomonic_to_cam(self, gnom_x, gnom_y, parameters, *, dtype=np.float32):
    &#34;&#34;&#34;
    ** Passe des points du plan gnomonic vers la camera. **

    Parameters
    ----------
    gnom_x : float ou np.ndarray
        Coordonnee.s du.des point.s selon l&#39;axe x du repere du plan gnomonic. (en mm)
    gnom_y : float ou np.ndarray
        Coordonnee.s du.des point.s selon l&#39;axe y du repere du plan gnomonic. (en mm)
    parameters : dict
        Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
    dtype : type, optional
        Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
        La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
        mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

    Returns
    -------
    coords : np.ndarray
        * Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)
        * shape = (2, *shape_d_entree)

    Examples
    -------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
    &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
    ...                              0.09978235,  0.17156848,  0.13417314 ],
    ...                            [ 0.40283853,  0.31846303,  0.14362221, 
    ...                             -0.18308422, -0.58226374, -0.93854752 ]])
    &gt;&gt;&gt;

    Output type
    &gt;&gt;&gt; type(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
    &lt;class &#39;numpy.ndarray&#39;&gt;
    &gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
    array([[   3.,  412.,  821., 1230., 1639., 2048.],
           [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
    &gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters, dtype=np.float64))
    array([[   3.,  412.,  821., 1230., 1639., 2048.],
           [   3.,  412.,  821., 1230., 1639., 2048.]])
    &gt;&gt;&gt;
    
    Output shape
    &gt;&gt;&gt; transformer.gnomonic_to_cam(0.0, 0.0, parameters).shape
    (2,)
    &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
    ...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
    &gt;&gt;&gt; transformer.gnomonic_to_cam(x_cam, y_cam, parameters).shape
    (2, 1, 2, 3)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return self._generic_transformation(&#34;gnomonic_to_cam&#34;, gnom_x, gnom_y,
        parameters=parameters, dtype=dtype)</code></pre>
</details>
</dd>
<dt id="laue.Transformer.gnomonic_to_thetachi"><code class="name flex">
<span>def <span class="ident">gnomonic_to_thetachi</span></span>(<span>self, gnom_x, gnom_y, *, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Passe des points du plan gnomonic vers theta et chi. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>gnom_x</code></strong> :&ensp;<code>float ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des point.s selon l'axe x du repere du plan gnomonic. (en mm)</dd>
<dt><strong><code>gnom_y</code></strong> :&ensp;<code>float ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des point.s selon l'axe y du repere du plan gnomonic. (en mm)</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>Si l'entree est un nombre et non pas une array numpy. Les calculs sont fait en <code>float</code>.
La representation machine des nombres. Par defaut <code>np.float32</code> permet des calculs rapide
mais peu precis. Pour la presision il faut utiliser <code>np.float64</code> ou <code>np.float128</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float ou np.ndarray</code></dt>
<dd>
<ul>
<li>Le.s coordonnee.s theta puis chi du.des point.s. (en deg)</li>
<li>shape = (2, *shape_d_entree)</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
...                              0.09978235,  0.17156848,  0.13417314 ],
...                            [ 0.40283853,  0.31846303,  0.14362221, 
...                             -0.18308422, -0.58226374, -0.93854752 ]])
&gt;&gt;&gt;
</code></pre>
<p>Output type</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; type(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
       [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]], dtype=float32)
&gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom, dtype=np.float64))
array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
       [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]])
&gt;&gt;&gt;
</code></pre>
<p>Output shape</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; transformer.gnomonic_to_thetachi(0.0, 0.0).shape
(2,)
&gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
&gt;&gt;&gt; transformer.gnomonic_to_thetachi(x_cam, y_cam).shape
(2, 1, 2, 3)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gnomonic_to_thetachi(self, gnom_x, gnom_y, *, dtype=np.float32):
    &#34;&#34;&#34;
    ** Passe des points du plan gnomonic vers theta et chi. **

    Parameters
    ----------
    gnom_x : float ou np.ndarray
        Coordonnee.s du.des point.s selon l&#39;axe x du repere du plan gnomonic. (en mm)
    gnom_y : float ou np.ndarray
        Coordonnee.s du.des point.s selon l&#39;axe y du repere du plan gnomonic. (en mm)
    dtype : type, optional
        Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
        La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
        mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

    Returns
    -------
    float ou np.ndarray
        * Le.s coordonnee.s theta puis chi du.des point.s. (en deg)
        * shape = (2, *shape_d_entree)

    Examples
    -------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
    ...                              0.09978235,  0.17156848,  0.13417314 ],
    ...                            [ 0.40283853,  0.31846303,  0.14362221, 
    ...                             -0.18308422, -0.58226374, -0.93854752 ]])
    &gt;&gt;&gt;

    Output type
    &gt;&gt;&gt; type(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
    &lt;class &#39;numpy.ndarray&#39;&gt;
    &gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
    array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
           [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]], dtype=float32)
    &gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom, dtype=np.float64))
    array([[ 1.11,  1.05,  0.9 ,  0.67,  0.52,  0.46],
           [ 0.86,  0.61,  0.23, -0.23, -0.61, -0.86]])
    &gt;&gt;&gt;
    
    Output shape
    &gt;&gt;&gt; transformer.gnomonic_to_thetachi(0.0, 0.0).shape
    (2,)
    &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
    ...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
    &gt;&gt;&gt; transformer.gnomonic_to_thetachi(x_cam, y_cam).shape
    (2, 1, 2, 3)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return self._generic_transformation(&#34;gnomonic_to_thetachi&#34;, gnom_x, gnom_y,
        parameters=None, dtype=dtype)</code></pre>
</details>
</dd>
<dt id="laue.Transformer.hough"><code class="name flex">
<span>def <span class="ident">hough</span></span>(<span>self, x_vect, y_vect, *, dtype=numpy.float64)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Transformee de hough avec des droites. </strong></p>
<h2 id="note">Note</h2>
<ul>
<li>Pour des raisons de performances, les calculs se font sur des float32.</li>
<li>Les indices sont agences selon l'ordre defini par la fonction <code>comb2ind</code>.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>L'ensemble des coordonnees x des points de shape: (*over_dims, nbr_points)</dd>
<dt><strong><code>y_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>L'ensemble des coordonnees y des points de shape: (*over_dims, nbr_points)</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>La representation machine des nombres.
Attention pour les calculs en float32 et moins
risque d'y avoir des arrondis qui engendrent:
<code>RuntimeWarning: invalid value encountered in sqrt</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>
<ul>
<li>theta : np.ndarray<ul>
<li>Les angles au sens trigomometrique des vecteurs reliant l'origine
<code>O</code> (0, 0) au point <code>P</code> appartenant a la droite tel que <code>||OP||</code>
soit la plus petite possible.</li>
<li>theta € [-pi, pi]</li>
<li>shape = <code>(*over_dims, n*(n-1)/2)</code></li>
</ul>
</li>
<li>dist : np.ndarray<ul>
<li>Ce sont les normes des vecteur <code>OP</code>.</li>
<li>dist € [0, +oo].</li>
<li>shape = <code>(*over_dims, n*(n-1)/2)</code></li>
</ul>
</li>
<li>Ces 2 grandeurs sont concatenees dans une seule array de</li>
</ul>
</dd>
</dl>
<p>shape = <code>(2, *over_dims, n*(n-1)/2)</code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue.core.geometry import transformer
&gt;&gt;&gt; transformer = transformer.Transformer()
&gt;&gt;&gt; x, y = np.random.normal(size=(2, 6))
&gt;&gt;&gt; transformer.hough(x, y).shape
(2, 15)
&gt;&gt;&gt;
&gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
&gt;&gt;&gt; transformer.hough(x, y).shape
(2, 4, 5, 15)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hough(self, x_vect, y_vect, *, dtype=np.float64):
    r&#34;&#34;&#34;
    ** Transformee de hough avec des droites. **

    Note
    ----
    * Pour des raisons de performances, les calculs se font sur des float32.
    * Les indices sont agences selon l&#39;ordre defini par la fonction ``comb2ind``.

    Parameters
    ----------
    x_vect : np.ndarray
        L&#39;ensemble des coordonnees x des points de shape: (*over_dims, nbr_points)
    y_vect : np.ndarray
        L&#39;ensemble des coordonnees y des points de shape: (*over_dims, nbr_points)
    dtype : type, optional
        La representation machine des nombres.
        Attention pour les calculs en float32 et moins
        risque d&#39;y avoir des arrondis qui engendrent:
        ``RuntimeWarning: invalid value encountered in sqrt``.

    Returns
    -------
    np.ndarray
        * theta : np.ndarray
            * Les angles au sens trigomometrique des vecteurs reliant l&#39;origine
            ``O`` (0, 0) au point ``P`` appartenant a la droite tel que ``||OP||``
            soit la plus petite possible.
            * theta € [-pi, pi]
            * shape = ``(*over_dims, n*(n-1)/2)``
        * dist : np.ndarray
            * Ce sont les normes des vecteur ``OP``.
            * dist € [0, +oo].
            * shape = ``(*over_dims, n*(n-1)/2)``
        * Ces 2 grandeurs sont concatenees dans une seule array de
    shape = ``(2, *over_dims, n*(n-1)/2)``

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue.core.geometry import transformer
    &gt;&gt;&gt; transformer = transformer.Transformer()
    &gt;&gt;&gt; x, y = np.random.normal(size=(2, 6))
    &gt;&gt;&gt; transformer.hough(x, y).shape
    (2, 15)
    &gt;&gt;&gt;
    &gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
    &gt;&gt;&gt; transformer.hough(x, y).shape
    (2, 4, 5, 15)
    &gt;&gt;&gt; 
    &#34;&#34;&#34;
    assert isinstance(x_vect, np.ndarray), \
        f&#34;&#39;x_vect&#39; has to be of type np.ndarray, not {type(x_vect).__name__}.&#34;
    assert isinstance(y_vect, np.ndarray), \
        f&#34;&#39;y_vect&#39; has to be of type np.ndarray, not {type(y_vect).__name__}.&#34;
    assert x_vect.shape == y_vect.shape, \
        f&#34;Les 2 entrees doivent avoir la meme taille: {x_vect.shape} vs {y_vect.shape}.&#34;
    assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
        f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

    n = x_vect.shape[-1]
    if n == 1:
        over_dims = x_vect.shape[:-1]
        clusters = np.empty(np.prod(over_dims, dtype=int), dtype=object)
        clusters[:] = [[] for _ in range(clusters.size)]
        clusters = clusters.reshape(over_dims)
        return clusters
    
    x_vect, y_vect = x_vect.astype(dtype, copy=False), y_vect.astype(dtype, copy=False)

    xa = np.concatenate([np.repeat(x_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
    ya = np.concatenate([np.repeat(y_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
    xb = np.concatenate([x_vect[..., i+1:] for i in range(n-1)], axis=-1)
    yb = np.concatenate([y_vect[..., i+1:] for i in range(n-1)], axis=-1)

    return np.nan_to_num(
        np.stack(self.get_fct_hough()(xa, ya, xb, yb)),
        copy=False,
        nan=0.0)</code></pre>
</details>
</dd>
<dt id="laue.Transformer.hough_reduce"><code class="name flex">
<span>def <span class="ident">hough_reduce</span></span>(<span>self, theta_vect, dist_vect, *, nbr=4, tol=0.018, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Regroupe des droites ressemblantes. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Cette methode est concue pour traiter les donnees issues de <code><a title="laue.core.geometry.transformer.Transformer.hough" href="core/geometry/transformer.html#laue.core.geometry.transformer.Transformer.hough">Transformer.hough()</a></code>.</li>
<li>La metrique utilise est la distance euclidiene sur un cylindre ferme sur theta.</li>
<li>En raison de performance et de memoire, les calculs se font sur des float32.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>
<ul>
<li>Vecteur des angles compris entre [-pi, pi].</li>
<li>shape = <code>(*over_dims, nbr_inter)</code></li>
</ul>
</dd>
<dt><strong><code>dist_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>
<ul>
<li>Vecteur des distances des droites a l'origine comprises [0, +oo].</li>
<li>shape = <code>(*over_dims, nbr_inter)</code></li>
</ul>
</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code></dt>
<dd>La distance maximal separant 2 points dans l'espace de hough reduit,
(ie la difference entre 2 droites dans l'espace spacial) tel que les points
se retrouvent dans le meme cluster. Plus ce nombre est petit, plus les points
doivent etre bien alignes. C'est une sorte de tolerance sur l'alignement.</dd>
<dt><strong><code>nbr</code></strong> :&ensp;<code>int</code></dt>
<dd>C'est le nombre minimum de points presque alignes pour que
l'on puisse considerer la droite qui passe par ces points.
Par defaut, les droites qui ne passent que par 4 points et plus sont retenues.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>La representation machine des nombres. Par defaut <code>np.float32</code> permet des calculs rapide
mais peu precis. Pour la presision il faut utiliser <code>np.float64</code>.
<code>np.float128</code> est interdit car c'est un peu over-kill pour cette methode!</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray(dtype=float), np.ndarray(dtype=object)</code></dt>
<dd>
<ul>
<li>Ce sont les centres des clusters pour chaque 'nuages de points'. Cela correspond
aux angles et aux distances qui caracterisent chaque droites.</li>
<li>Si les parametres d'entres sont des vecteurs 1d, le resultat sera une array
numpy contenant les <strong>angles</strong> puis les <strong>distances</strong>. Donc de shape = <code>(2, nbr_clusters)</code></li>
<li>Si les parametres d'entres sont en plusieur dimensions, (representes plusieur
nuages de points indepandant), alors le resultat sera une array d'objet de
shape = <code>(*over_dims)</code>. Chaque objet est lui meme un array, resultat recursif
de l'appel de cette fonction sur le nuage de points unique correspondant.</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue.core.geometry import transformer
&gt;&gt;&gt; transformer = transformer.Transformer()
</code></pre>
<p>Type de retour <code>float</code> vs <code>object</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; x, y = (np.array([ 1.,  2.,  3.,  0., -1.]),
...         np.array([ 0.,  1.,  1., -1.,  1.]))
&gt;&gt;&gt; theta, dist = transformer.hough(x, y)
&gt;&gt;&gt; np.round(transformer.hough_reduce(theta, dist, nbr=3), 2)
array([[-0.79,  1.57],
       [ 0.71,  1.  ]], dtype=float32)
&gt;&gt;&gt; res = transformer.hough_reduce(theta.reshape((1, -1)), dist.reshape((1, -1)), nbr=3)
&gt;&gt;&gt; res.dtype
dtype('O')
&gt;&gt;&gt; res.shape
(1,)
&gt;&gt;&gt; np.round(res[0], 2)
array([[-0.79,  1.57],
       [ 0.71,  1.  ]], dtype=float32)
&gt;&gt;&gt;
</code></pre>
<p>Les dimensions de retour.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; x, y = (np.random.normal(size=(6, 5, 4)),
...         np.random.normal(size=(6, 5, 4)))
&gt;&gt;&gt; theta, dist = transformer.hough(x, y)
&gt;&gt;&gt; transformer.hough_reduce(theta, dist).shape
(6, 5)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hough_reduce(self, theta_vect, dist_vect, *, nbr=4, tol=0.018, dtype=np.float32):
    &#34;&#34;&#34;
    ** Regroupe des droites ressemblantes. **

    Notes
    -----
    * Cette methode est concue pour traiter les donnees issues de ``laue.core.geometry.transformer.Transformer.hough``.
    * La metrique utilise est la distance euclidiene sur un cylindre ferme sur theta.
    * En raison de performance et de memoire, les calculs se font sur des float32.

    Parameters
    ----------
    theta_vect : np.ndarray
        * Vecteur des angles compris entre [-pi, pi].
        * shape = ``(*over_dims, nbr_inter)``
    dist_vect : np.ndarray
        * Vecteur des distances des droites a l&#39;origine comprises [0, +oo].
        * shape = ``(*over_dims, nbr_inter)``
    tol : float
        La distance maximal separant 2 points dans l&#39;espace de hough reduit,
        (ie la difference entre 2 droites dans l&#39;espace spacial) tel que les points
        se retrouvent dans le meme cluster. Plus ce nombre est petit, plus les points
        doivent etre bien alignes. C&#39;est une sorte de tolerance sur l&#39;alignement.
    nbr : int
        C&#39;est le nombre minimum de points presque alignes pour que
        l&#39;on puisse considerer la droite qui passe par ces points.
        Par defaut, les droites qui ne passent que par 4 points et plus sont retenues.
    dtype : type, optional
        La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
        mais peu precis. Pour la presision il faut utiliser ``np.float64``.
        ``np.float128`` est interdit car c&#39;est un peu over-kill pour cette methode!

    Returns
    -------
    np.ndarray(dtype=float), np.ndarray(dtype=object)
        * Ce sont les centres des clusters pour chaque &#39;nuages de points&#39;. Cela correspond
        aux angles et aux distances qui caracterisent chaque droites.
        * Si les parametres d&#39;entres sont des vecteurs 1d, le resultat sera une array
        numpy contenant les **angles** puis les **distances**. Donc de shape = ``(2, nbr_clusters)``
        * Si les parametres d&#39;entres sont en plusieur dimensions, (representes plusieur
        nuages de points indepandant), alors le resultat sera une array d&#39;objet de
        shape = ``(*over_dims)``. Chaque objet est lui meme un array, resultat recursif
        de l&#39;appel de cette fonction sur le nuage de points unique correspondant.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue.core.geometry import transformer
    &gt;&gt;&gt; transformer = transformer.Transformer()

    Type de retour ``float`` vs ``object``.
    &gt;&gt;&gt; x, y = (np.array([ 1.,  2.,  3.,  0., -1.]),
    ...         np.array([ 0.,  1.,  1., -1.,  1.]))
    &gt;&gt;&gt; theta, dist = transformer.hough(x, y)
    &gt;&gt;&gt; np.round(transformer.hough_reduce(theta, dist, nbr=3), 2)
    array([[-0.79,  1.57],
           [ 0.71,  1.  ]], dtype=float32)
    &gt;&gt;&gt; res = transformer.hough_reduce(theta.reshape((1, -1)), dist.reshape((1, -1)), nbr=3)
    &gt;&gt;&gt; res.dtype
    dtype(&#39;O&#39;)
    &gt;&gt;&gt; res.shape
    (1,)
    &gt;&gt;&gt; np.round(res[0], 2)
    array([[-0.79,  1.57],
           [ 0.71,  1.  ]], dtype=float32)
    &gt;&gt;&gt;

    Les dimensions de retour.
    &gt;&gt;&gt; x, y = (np.random.normal(size=(6, 5, 4)),
    ...         np.random.normal(size=(6, 5, 4)))
    &gt;&gt;&gt; theta, dist = transformer.hough(x, y)
    &gt;&gt;&gt; transformer.hough_reduce(theta, dist).shape
    (6, 5)
    &gt;&gt;&gt; 
    &#34;&#34;&#34;
    assert isinstance(theta_vect, np.ndarray), \
        f&#34;&#39;theta_vect&#39; has to be of type np.ndarray, not {type(theta_vect).__name__}.&#34;
    assert isinstance(dist_vect, np.ndarray), \
        f&#34;&#39;dist_vect&#39; has to be of type np.ndarray, not {type(dist_vect).__name__}.&#34;
    assert theta_vect.shape == dist_vect.shape, \
        f&#34;Les 2 entrees doivent avoir la meme taille: {theta_vect.shape} vs {dist_vect.shape}.&#34;
    assert theta_vect.ndim &gt;= 1, &#34;La matrice ne doit pas etre vide.&#34;
    assert isinstance(tol, float), f&#34;&#39;tol&#39; has to be a float, not a {type(tol).__name__}.&#34;
    assert 0.0 &lt; tol &lt;= 0.5, (&#34;Les valeurs coherentes de &#39;tol&#39; se trouvent entre &#34;
        f&#34;]0, 1/2], or tol vaut {tol}, ce qui sort de cet intervalle.&#34;)
    assert isinstance(nbr, int), f&#34;&#39;nbr&#39; has to be an integer, not a {type(nbr).__name__}.&#34;
    assert 2 &lt; nbr, f&#34;2 points sont toujours alignes! Vous ne pouvez pas choisir nbr={nbr}.&#34;
    assert dtype in {np.float16, np.float32, np.float64}, \
        f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64. Pas {dtype}.&#34;

    # On fait la conversion des le debut pour un gain de temps.
    theta_vect, dist_vect = theta_vect.astype(dtype, copy=False), dist_vect.astype(dtype, copy=False)

    *over_dims, nbr_inter = theta_vect.shape # Recuperation des dimensions.
    nbr = (nbr*(nbr-1))/2 # On converti le nombre de points alignes en nbr de segments.

    # On commence par travailler avec les donnees reduites.
    theta_theo_std = math.pi / math.sqrt(3) # Variance theorique = (math.pi - -math.pi)**2 / 12
    dist_std = np.nanstd(dist_vect, axis=-1) # Ecart type non biaise (sum(*over_dims)/N), shape: (*over_dims)
    dist_vect = (dist_vect * theta_theo_std
        / np.repeat(dist_std[..., np.newaxis], nbr_inter, axis=-1)) # Les distances quasi reduites.
    
    # Extraction des clusters.
    if not len(over_dims): # Cas des tableaux 1d.
        return self._clustering_1d(theta_vect, dist_vect, dist_std, tol, nbr)

    clusters = np.empty(np.prod(over_dims, dtype=int), dtype=object) # On doit d&#39;abord creer un tableau d&#39;objet 1d.
    if multiprocessing.current_process().name == &#34;MainProcess&#34; and np.prod(over_dims) &gt;= os.cpu_count(): # Si ca vaut le coup de parraleliser:
        ser_self = cloudpickle.dumps(self) # Strategie car &#39;pickle&#39; ne sais pas faire ca.
        from laue.utilities.multi_core import pickleable_method
        with multiprocessing.Pool() as pool:
            clusters[:] = pool.map(
                pickleable_method, # Car si il y a autant de cluster dans chaque image,
                (                   # numpy aurait envi de faire un tableau 2d plutot qu&#39;un vecteur de listes.
                    (
                        Transformer._clustering_1d,
                        ser_self,
                        {&#34;theta_vect_1d&#34;:theta, &#34;dist_vect_1d&#34;:dist, &#34;std&#34;:std, &#34;tol&#34;:tol, &#34;nbr&#34;:nbr}
                    )
                    for theta, dist, std
                    in zip(
                        theta_vect.reshape((-1, nbr_inter)),
                        dist_vect.reshape((-1, nbr_inter)),
                        np.nditer(dist_std)
                    )
                )
            )
    else:
        clusters[:] = [self._clustering_1d(theta, dist, std, tol, nbr)
                       for theta, dist, std in zip(
                                theta_vect.reshape((-1, nbr_inter)),
                                dist_vect.reshape((-1, nbr_inter)),
                                np.nditer(dist_std))] 
    clusters = clusters.reshape(over_dims) # On redimensione a la fin de sorte a garentir les dimensions.

    return clusters</code></pre>
</details>
</dd>
<dt id="laue.Transformer.inter_lines"><code class="name flex">
<span>def <span class="ident">inter_lines</span></span>(<span>self, theta_vect, dist_vect, *, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Calcul les points d'intersection entre les droites. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Cette methode est concue pour traiter les donnees issues de <code><a title="laue.core.geometry.transformer.Transformer.hough" href="core/geometry/transformer.html#laue.core.geometry.transformer.Transformer.hough">Transformer.hough()</a></code>.</li>
<li>En raison de performance et de memoire, les calculs se font sur des float32.</li>
<li>Les indices sont agences selon l'ordre defini par la fonction <code>comb2ind</code>.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>
<ul>
<li>Vecteur des angles compris entre [-pi, pi].</li>
<li>shape = (*over_dims, nbr_droites)</li>
</ul>
</dd>
<dt><strong><code>dist_vect</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>
<ul>
<li>Vecteur des distances des droites a l'origine comprises [0, +oo].</li>
<li>shape = (*over_dims, nbr_droites)</li>
</ul>
</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>La representation machine des nombres. Par defaut
<code>np.float32</code> permet des calculs rapide
mais peu precis. Pour la presision il faut utiliser
<code>np.float64</code> ou <code>(getattr(np, "float128") if hasattr(np, "float128") else np.float64)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>
<ul>
<li>Dans le dommaine spatial et non pas le domaine de hough, cherche
les intersections des droites. Il y a <code>n*(n-1)/2</code> intersections, n etant
le nombre de droites. donc la complexite de cette methode est en <code>o(n**2)</code>.</li>
<li>Si les vecteurs d'entre sont des vecteurs 1d (ie <code>*over_dims == ()</code>),
Seront retournes le vecteur d'intersection selon l'axe x et le vecteur
des intersections selon l'axe y. Ces 2 vecteurs de meme taille sont concatenes
sous la forme d'une matrice de shape = <code>(2, n*(n-1)/2)</code>.</li>
<li>Si les vecteurs d'entre sont en plusieurs dimensions, seul les droites de la
derniere dimensions se retrouvent dans la meme famille. Tous comme pour les
vecteurs 1d, on trouve d'abord les intersections selon x puis en suite selon y.
La shape du tenseur final est donc: <strong> shape = <code>(2, *over_dims, n*(n-1)/2)</code> </strong>.</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
&gt;&gt;&gt; theta, dist = transformer.hough(x, y)
&gt;&gt;&gt; theta.shape
(4, 5, 15)
&gt;&gt;&gt; transformer.inter_lines(theta, dist).shape
(2, 4, 5, 105)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inter_lines(self, theta_vect, dist_vect, *, dtype=np.float32):
    r&#34;&#34;&#34;
    ** Calcul les points d&#39;intersection entre les droites. **

    Notes
    -----
    * Cette methode est concue pour traiter les donnees issues de ``laue.core.geometry.transformer.Transformer.hough``.
    * En raison de performance et de memoire, les calculs se font sur des float32.
    * Les indices sont agences selon l&#39;ordre defini par la fonction ``comb2ind``.

    Parameters
    ----------
    theta_vect : np.ndarray
        * Vecteur des angles compris entre [-pi, pi].
        * shape = (*over_dims, nbr_droites)
    dist_vect : np.ndarray
        * Vecteur des distances des droites a l&#39;origine comprises [0, +oo].
        * shape = (*over_dims, nbr_droites)
    dtype : type, optional
        La representation machine des nombres. Par defaut
        ``np.float32`` permet des calculs rapide
        mais peu precis. Pour la presision il faut utiliser
        ``np.float64`` ou ``(getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)``.

    Returns
    -------
    np.ndarray
        * Dans le dommaine spatial et non pas le domaine de hough, cherche
        les intersections des droites. Il y a ``n*(n-1)/2`` intersections, n etant
        le nombre de droites. donc la complexite de cette methode est en ``o(n**2)``.
        * Si les vecteurs d&#39;entre sont des vecteurs 1d (ie ``*over_dims == ()``), 
        Seront retournes le vecteur d&#39;intersection selon l&#39;axe x et le vecteur
        des intersections selon l&#39;axe y. Ces 2 vecteurs de meme taille sont concatenes
        sous la forme d&#39;une matrice de shape = ``(2, n*(n-1)/2)``.
        * Si les vecteurs d&#39;entre sont en plusieurs dimensions, seul les droites de la
        derniere dimensions se retrouvent dans la meme famille. Tous comme pour les
        vecteurs 1d, on trouve d&#39;abord les intersections selon x puis en suite selon y.
        La shape du tenseur final est donc: ** shape = ``(2, *over_dims, n*(n-1)/2)`` **.

    Examples
    -------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; np.random.seed(0)
    &gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
    &gt;&gt;&gt; theta, dist = transformer.hough(x, y)
    &gt;&gt;&gt; theta.shape
    (4, 5, 15)
    &gt;&gt;&gt; transformer.inter_lines(theta, dist).shape
    (2, 4, 5, 105)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(theta_vect, np.ndarray), \
        f&#34;&#39;theta_vect&#39; has to be of type np.ndarray, not {type(theta_vect).__name__}.&#34;
    assert isinstance(dist_vect, np.ndarray), \
        f&#34;&#39;dist_vect&#39; has to be of type np.ndarray, not {type(dist_vect).__name__}.&#34;
    assert theta_vect.shape == dist_vect.shape, \
        f&#34;Les 2 entrees doivent avoir la meme taille: {theta_vect.shape} vs {dist_vect.shape}.&#34;
    assert theta_vect.ndim &gt;= 1, &#34;La matrice ne doit pas etre vide.&#34;
    assert theta_vect.shape[-1] &gt;= 2, \
        f&#34;Il doit y avoir au moins 2 droites par famille, pas {theta_vect.shape[-1]}.&#34;
    assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
        f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

    theta_vect, dist_vect = theta_vect.astype(dtype, copy=False), dist_vect.astype(dtype, copy=False)
    n = theta_vect.shape[-1]

    theta_1 = np.concatenate([np.repeat(theta_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
    dist_1 = np.concatenate([np.repeat(dist_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
    theta_2 = np.concatenate([theta_vect[..., i+1:] for i in range(n-1)], axis=-1)
    dist_2 = np.concatenate([dist_vect[..., i+1:] for i in range(n-1)], axis=-1)

    return np.stack(self.get_fct_inter_line()(theta_1, dist_1, theta_2, dist_2))</code></pre>
</details>
</dd>
<dt id="laue.Transformer.thetachi_to_cam"><code class="name flex">
<span>def <span class="ident">thetachi_to_cam</span></span>(<span>self, theta, chi, parameters, *, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Passe de la representation theta et chi vers la camera. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des angle.s de rotation autour de y. (en deg)</dd>
<dt><strong><code>chi</code></strong> :&ensp;<code>float ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des angle.s de rotation autour de x. (en deg)</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>Le dictionaire issue de la fonction <code><a title="laue.utilities.parsing.extract_parameters" href="utilities/parsing.html#laue.utilities.parsing.extract_parameters">extract_parameters()</a></code>.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>Si l'entree est un nombre et non pas une array numpy. Les calculs sont fait en <code>float</code>.
La representation machine des nombres. Par defaut <code>np.float32</code> permet des calculs rapide
mais peu precis. Pour la presision il faut utiliser <code>np.float64</code> ou <code>np.float128</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>coords</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>
<ul>
<li>Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)</li>
<li>shape = (2, *shape_d_entree)</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
&gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; theta, chi = np.array([[ 1.1101143, 1.0456189, 0.8965300,
...                          0.6727613, 0.5244697, 0.4603832],
...                        [ 0.8622506, 0.6103422, 0.2279670,
...                         -0.2312180,-0.6126410,-0.8636999]])
&gt;&gt;&gt;
</code></pre>
<p>Output type</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; type(transformer.thetachi_to_cam(theta, chi, parameters))
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters))
array([[   3.,  412.,  821., 1230., 1639., 2048.],
       [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
&gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters, dtype=np.float64))
array([[   3.,  412.,  821., 1230., 1639., 2048.],
       [   3.,  412.,  821., 1230., 1639., 2048.]])
&gt;&gt;&gt;
</code></pre>
<p>Output shape</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; transformer.thetachi_to_cam(np.pi/4, 0.0, parameters).shape
(2,)
&gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
&gt;&gt;&gt; transformer.thetachi_to_cam(theta, chi, parameters).shape
(2, 1, 2, 3)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thetachi_to_cam(self, theta, chi, parameters, *, dtype=np.float32):
    &#34;&#34;&#34;
    ** Passe de la representation theta et chi vers la camera. **

    Parameters
    ----------
    theta : float ou np.ndarray
        Coordonnee.s du.des angle.s de rotation autour de y. (en deg)
    chi : float ou np.ndarray
        Coordonnee.s du.des angle.s de rotation autour de x. (en deg)
    parameters : dict
        Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
    dtype : type, optional
        Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
        La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
        mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

    Returns
    -------
    coords : np.ndarray
        * Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)
        * shape = (2, *shape_d_entree)

    Examples
    -------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
    &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; theta, chi = np.array([[ 1.1101143, 1.0456189, 0.8965300,
    ...                          0.6727613, 0.5244697, 0.4603832],
    ...                        [ 0.8622506, 0.6103422, 0.2279670,
    ...                         -0.2312180,-0.6126410,-0.8636999]])
    &gt;&gt;&gt;

    Output type
    &gt;&gt;&gt; type(transformer.thetachi_to_cam(theta, chi, parameters))
    &lt;class &#39;numpy.ndarray&#39;&gt;
    &gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters))
    array([[   3.,  412.,  821., 1230., 1639., 2048.],
           [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
    &gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters, dtype=np.float64))
    array([[   3.,  412.,  821., 1230., 1639., 2048.],
           [   3.,  412.,  821., 1230., 1639., 2048.]])
    &gt;&gt;&gt;
    
    Output shape
    &gt;&gt;&gt; transformer.thetachi_to_cam(np.pi/4, 0.0, parameters).shape
    (2,)
    &gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
    ...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
    &gt;&gt;&gt; transformer.thetachi_to_cam(theta, chi, parameters).shape
    (2, 1, 2, 3)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return self._generic_transformation(&#34;thetachi_to_cam&#34;, theta, chi,
        parameters=parameters, dtype=dtype)</code></pre>
</details>
</dd>
<dt id="laue.Transformer.thetachi_to_gnomonic"><code class="name flex">
<span>def <span class="ident">thetachi_to_gnomonic</span></span>(<span>self, theta, chi, *, dtype=numpy.float32)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Passe de la representation theta et chi vers une projection gnomonique. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>float ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des angle.s de rotation autour de y. (en deg)</dd>
<dt><strong><code>chi</code></strong> :&ensp;<code>float ou np.ndarray</code></dt>
<dd>Coordonnee.s du.des angle.s de rotation autour de x. (en deg)</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>type</code>, optional</dt>
<dd>Si l'entree est un nombre et non pas une array numpy. Les calculs sont fait en <code>float</code>.
La representation machine des nombres. Par defaut <code>np.float32</code> permet des calculs rapide
mais peu precis. Pour la presision il faut utiliser <code>np.float64</code> ou <code>np.float128</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float ou np.ndarray</code></dt>
<dd>
<ul>
<li>Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic eprimee.s en mm.</li>
<li>shape = (2, *shape_d_entree)</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from laue import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; theta, chi = np.array([[ 1.1101143, 1.0456189, 0.8965300,
...                          0.6727613, 0.5244697, 0.4603832],
...                        [ 0.8622506, 0.6103422, 0.2279670,
...                         -0.2312180,-0.6126410,-0.8636999]])
&gt;&gt;&gt;
</code></pre>
<p>Output type</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; type(transformer.thetachi_to_gnomonic(theta, chi))
&lt;class 'numpy.ndarray'&gt;
&gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi), 2)
array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
       [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
&gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi, dtype=np.float64), 2)
array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
       [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
&gt;&gt;&gt;
</code></pre>
<p>Output shape</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; transformer.thetachi_to_gnomonic(np.pi/4, 0.0).shape
(2,)
&gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
&gt;&gt;&gt; transformer.thetachi_to_gnomonic(theta, chi).shape
(2, 1, 2, 3)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thetachi_to_gnomonic(self, theta, chi, *, dtype=np.float32):
    &#34;&#34;&#34;
    ** Passe de la representation theta et chi vers une projection gnomonique. **

    Parameters
    ----------
    theta : float ou np.ndarray
        Coordonnee.s du.des angle.s de rotation autour de y. (en deg)
    chi : float ou np.ndarray
        Coordonnee.s du.des angle.s de rotation autour de x. (en deg)
    dtype : type, optional
        Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
        La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
        mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

    Returns
    -------
    float ou np.ndarray
        * Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic eprimee.s en mm.
        * shape = (2, *shape_d_entree)

    Examples
    -------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; theta, chi = np.array([[ 1.1101143, 1.0456189, 0.8965300,
    ...                          0.6727613, 0.5244697, 0.4603832],
    ...                        [ 0.8622506, 0.6103422, 0.2279670,
    ...                         -0.2312180,-0.6126410,-0.8636999]])
    &gt;&gt;&gt;

    Output type
    &gt;&gt;&gt; type(transformer.thetachi_to_gnomonic(theta, chi))
    &lt;class &#39;numpy.ndarray&#39;&gt;
    &gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi), 2)
    array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
           [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
    &gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi, dtype=np.float64), 2)
    array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
           [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
    &gt;&gt;&gt;
    
    Output shape
    &gt;&gt;&gt; transformer.thetachi_to_gnomonic(np.pi/4, 0.0).shape
    (2,)
    &gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
    ...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
    &gt;&gt;&gt; transformer.thetachi_to_gnomonic(theta, chi).shape
    (2, 1, 2, 3)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    return self._generic_transformation(&#34;thetachi_to_gnomonic&#34;, theta, chi,
        parameters=None, dtype=dtype)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="laue.core.geometry.symbolic.Compilator" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator">Compilator</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_cam_to_uf" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_cam_to_uf">get_expr_cam_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_gnomonic_to_uq" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_gnomonic_to_uq">get_expr_gnomonic_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_thetachi_to_uf" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_thetachi_to_uf">get_expr_thetachi_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uf_to_cam" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uf_to_cam">get_expr_uf_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uf_to_thetachi" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uf_to_thetachi">get_expr_uf_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uf_to_uq" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uf_to_uq">get_expr_uf_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uq_to_gnomonic" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uq_to_gnomonic">get_expr_uq_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uq_to_uf" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uq_to_uf">get_expr_uq_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_gnomonic" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_cam_to_gnomonic">get_fct_cam_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_thetachi" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_cam_to_thetachi">get_fct_cam_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_dist_line" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_dist_line">get_fct_dist_line</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_cam" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_cam">get_fct_gnomonic_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_thetachi" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_thetachi">get_fct_gnomonic_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_hough" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_hough">get_fct_hough</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_inter_line" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_inter_line">get_fct_inter_line</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_cam" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_cam">get_fct_thetachi_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_gnomonic" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_gnomonic">get_fct_thetachi_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.load" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.load">load</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.save" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#permet-de-manipuler-un-lot-de-diagrammes-de-laue">Permet de manipuler un lot de diagrammes de laue.</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="laue.core" href="core/index.html">laue.core</a></code></li>
<li><code><a title="laue.diagram" href="diagram.html">laue.diagram</a></code></li>
<li><code><a title="laue.experiment" href="experiment/index.html">laue.experiment</a></code></li>
<li><code><a title="laue.spot" href="spot.html">laue.spot</a></code></li>
<li><code><a title="laue.utilities" href="utilities/index.html">laue.utilities</a></code></li>
<li><code><a title="laue.zone_axis" href="zone_axis.html">laue.zone_axis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laue.atomic_find_subsets" href="#laue.atomic_find_subsets">atomic_find_subsets</a></code></li>
<li><code><a title="laue.atomic_find_zone_axes" href="#laue.atomic_find_zone_axes">atomic_find_zone_axes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code></h4>
<ul class="two-column">
<li><code><a title="laue.Experiment.__getitem__" href="#laue.Experiment.__getitem__">__getitem__</a></code></li>
<li><code><a title="laue.Experiment.__iter__" href="#laue.Experiment.__iter__">__iter__</a></code></li>
<li><code><a title="laue.Experiment.__len__" href="#laue.Experiment.__len__">__len__</a></code></li>
<li><code><a title="laue.Experiment.find_subsets" href="#laue.Experiment.find_subsets">find_subsets</a></code></li>
<li><code><a title="laue.Experiment.find_zone_axes" href="#laue.Experiment.find_zone_axes">find_zone_axes</a></code></li>
<li><code><a title="laue.Experiment.get_diagrams" href="#laue.Experiment.get_diagrams">get_diagrams</a></code></li>
<li><code><a title="laue.Experiment.get_images_shape" href="#laue.Experiment.get_images_shape">get_images_shape</a></code></li>
<li><code><a title="laue.Experiment.get_mean" href="#laue.Experiment.get_mean">get_mean</a></code></li>
<li><code><a title="laue.Experiment.read_images" href="#laue.Experiment.read_images">read_images</a></code></li>
<li><code><a title="laue.Experiment.save_file" href="#laue.Experiment.save_file">save_file</a></code></li>
<li><code><a title="laue.Experiment.set_calibration" href="#laue.Experiment.set_calibration">set_calibration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="laue.Transformer" href="#laue.Transformer">Transformer</a></code></h4>
<ul class="">
<li><code><a title="laue.Transformer.cam_to_gnomonic" href="#laue.Transformer.cam_to_gnomonic">cam_to_gnomonic</a></code></li>
<li><code><a title="laue.Transformer.cam_to_thetachi" href="#laue.Transformer.cam_to_thetachi">cam_to_thetachi</a></code></li>
<li><code><a title="laue.Transformer.compile" href="#laue.Transformer.compile">compile</a></code></li>
<li><code><a title="laue.Transformer.dist_line" href="#laue.Transformer.dist_line">dist_line</a></code></li>
<li><code><a title="laue.Transformer.gnomonic_to_cam" href="#laue.Transformer.gnomonic_to_cam">gnomonic_to_cam</a></code></li>
<li><code><a title="laue.Transformer.gnomonic_to_thetachi" href="#laue.Transformer.gnomonic_to_thetachi">gnomonic_to_thetachi</a></code></li>
<li><code><a title="laue.Transformer.hough" href="#laue.Transformer.hough">hough</a></code></li>
<li><code><a title="laue.Transformer.hough_reduce" href="#laue.Transformer.hough_reduce">hough_reduce</a></code></li>
<li><code><a title="laue.Transformer.inter_lines" href="#laue.Transformer.inter_lines">inter_lines</a></code></li>
<li><code><a title="laue.Transformer.thetachi_to_cam" href="#laue.Transformer.thetachi_to_cam">thetachi_to_cam</a></code></li>
<li><code><a title="laue.Transformer.thetachi_to_gnomonic" href="#laue.Transformer.thetachi_to_gnomonic">thetachi_to_gnomonic</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>