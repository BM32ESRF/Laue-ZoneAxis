<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>laue API documentation</title>
<meta name="description" content="** Permet de manipuler un lot de diagrammes de laue. **
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>laue</code></h1>
</header>
<section id="section-intro">
<h2 id="permet-de-manipuler-un-lot-de-diagrammes-de-laue"><strong> Permet de manipuler un lot de diagrammes de laue. </strong></h2>
<p>Les classes principales sont organisees de la facon suivante:</p>
<p><img alt="" src="/home/robin/documents/stages/esrf/laue_code/uml.png"></p>
<p>Toutes les conventions et noms de variables respectent la figure suivante:</p>
<p><img alt="" src="/home/robin/documents/stages/esrf/laue_code/geometry.jpg"></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Pour effectuer les bancs de tests, il faut installer le module <code>pip install pytest</code>.
Il faut ensuite saisir la commande suivante:<ul>
<li><code>clear &amp;&amp; python -m pytest --doctest-modules laue/
&amp;&amp; python -m pytest -vv --exitfirst laue/tests.py &amp;&amp; cat tests_results.txt</code></li>
</ul>
</li>
<li>Pour generer la documentation, il faut installer le module <code>pip install pdoc3</code>.
Il faut ensuite saisir la commande suivante:<ul>
<li><code>pdoc3 laue/ -c latex_math=True --force --html</code></li>
</ul>
</li>
<li>Pour generer le graphe UML, il faut installee le module <code>pip install pylint</code>
Il faut ensuite saisir la commande suivante:<ul>
<li><code>cd laue/</code></li>
<li><code>pyreverse -A -f OTHER -o png ./experiment/ordered_experiment.py
./diagram.py ./spot.py ./zone_axis.py ./core/geometry/transformer.py</code></li>
</ul>
</li>
<li>A la premiere execution, les equations sont compilees, ce qui peut metre
plusieurs disaines de minutes. Soyez patients!</li>
</ul>
<h2 id="examples">Examples</h2>
<p>utilisation minimaliste</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(image)
&gt;&gt;&gt;
&gt;&gt;&gt; experiment
Experiment('laue/examples')
&gt;&gt;&gt;
&gt;&gt;&gt; for diag in experiment:
...     print(type(diag))
...
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt;
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
** Permet de manipuler un lot de diagrammes de laue. **
-------------------------------------------------------

Les classes principales sont organisees de la facon suivante:

.. figure:: /home/robin/documents/stages/esrf/laue_code/uml.png

Toutes les conventions et noms de variables respectent la figure suivante:

.. figure:: /home/robin/documents/stages/esrf/laue_code/geometry.jpg

Notes
-----
* Pour effectuer les bancs de tests, il faut installer le module ``pip install pytest``.
    Il faut ensuite saisir la commande suivante:
    * ``clear &amp;&amp; python -m pytest --doctest-modules laue/
        &amp;&amp; python -m pytest -vv --exitfirst laue/tests.py &amp;&amp; cat tests_results.txt``
* Pour generer la documentation, il faut installer le module ``pip install pdoc3``.
    Il faut ensuite saisir la commande suivante:
    * ``pdoc3 laue/ -c latex_math=True --force --html``
* Pour generer le graphe UML, il faut installee le module ``pip install pylint``
    Il faut ensuite saisir la commande suivante:
    * ``cd laue/``
    * ``pyreverse -A -f OTHER -o png ./experiment/ordered_experiment.py
        ./diagram.py ./spot.py ./zone_axis.py ./core/geometry/transformer.py``
* A la premiere execution, les equations sont compilees, ce qui peut metre
    plusieurs disaines de minutes. Soyez patients!

Examples
--------

utilisation minimaliste
&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
&gt;&gt;&gt; experiment = laue.Experiment(image)
&gt;&gt;&gt;
&gt;&gt;&gt; experiment
Experiment(&#39;laue/examples&#39;)
&gt;&gt;&gt;
&gt;&gt;&gt; for diag in experiment:
...     print(type(diag))
...
&lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
&gt;&gt;&gt;
&#34;&#34;&#34;

import inspect

from .core import (cam_to_gnomonic, cam_to_thetachi,
    dist_cosine, dist_euclidian, dist_line, gnomonic_to_cam,
    gnomonic_to_thetachi, hough, hough_reduce, inter_lines,
    thetachi_to_cam, thetachi_to_gnomonic, Transformer,
    comb2ind, ind2comb, atomic_pic_search, atomic_find_subsets,
    atomic_find_zone_axes)
from .experiment import Experiment, OrderedExperiment
from .utilities import (Recordable, read_image, create_image,
    images_to_iter, TimeCost, Lambdify, limited_imap,
    pickleable_method, prevent_generator_size, reduce_object,
    NestablePool, RecallingIterator, extract_parameters)

__all__ = [
    # laue.core
    &#34;cam_to_gnomonic&#34;, &#34;cam_to_thetachi&#34;, &#34;dist_cosine&#34;, &#34;dist_euclidian&#34;,
    &#34;dist_line&#34;, &#34;gnomonic_to_cam&#34;, &#34;gnomonic_to_thetachi&#34;, &#34;hough&#34;,
    &#34;hough_reduce&#34;, &#34;inter_lines&#34;, &#34;thetachi_to_cam&#34;, &#34;thetachi_to_gnomonic&#34;,
    &#34;Transformer&#34;, &#34;comb2ind&#34;, &#34;ind2comb&#34;,
    &#34;atomic_pic_search&#34;, &#34;atomic_find_subsets&#34;, &#34;atomic_find_zone_axes&#34;,

    # laue.experiment
    &#34;Experiment&#34;, &#34;OrderedExperiment&#34;,

    # laue.utilities
    &#34;Recordable&#34;, &#34;read_image&#34;, &#34;create_image&#34;,
    &#34;images_to_iter&#34;, &#34;TimeCost&#34;, &#34;Lambdify&#34;, &#34;limited_imap&#34;,
    &#34;pickleable_method&#34;, &#34;prevent_generator_size&#34;, &#34;reduce_object&#34;,
    &#34;NestablePool&#34;, &#34;RecallingIterator&#34;, &#34;extract_parameters&#34;,
   ]


__pdoc__ = {obj: (&#34;Alias vers ``laue.&#34;
                  f&#34;{inspect.getsourcefile(globals()[obj]).split(&#39;laue/&#39;)[-1][:-3].replace(&#39;/&#39;, &#39;.&#39;).replace(&#39;.__init__&#39;, &#39;&#39;)}&#34;
                  f&#34;.{obj}``&#34;)
            for obj in __all__}
__pdoc__ = {**__pdoc__, **{f&#34;{cl}.{meth}&#34;: False
            for cl in __all__ if globals()[cl].__class__.__name__ == &#34;type&#34;
            for meth in globals()[cl].__dict__ if not meth.startswith(&#34;_&#34;)}}
__pdoc__[&#34;tests&#34;] = False
__pdoc__[&#34;data&#34;] = False</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="laue.core" href="core/index.html">laue.core</a></code></dt>
<dd>
<div class="desc"><p><strong> Calculs de base de la separation de grains. </strong>
â€¦</p></div>
</dd>
<dt><code class="name"><a title="laue.diagram" href="diagram.html">laue.diagram</a></code></dt>
<dd>
<div class="desc"><p><strong> Permet de manipuler un diagramme de Laue unique. </strong>
â€¦</p></div>
</dd>
<dt><code class="name"><a title="laue.experiment" href="experiment/index.html">laue.experiment</a></code></dt>
<dd>
<div class="desc"><p><strong> Implemente les classes mere abstraite, point d'entree. </strong>
â€¦</p></div>
</dd>
<dt><code class="name"><a title="laue.spot" href="spot.html">laue.spot</a></code></dt>
<dd>
<div class="desc"><p><strong> Represente un spot dans un diagramme de Laue. </strong>
â€¦</p></div>
</dd>
<dt><code class="name"><a title="laue.utilities" href="utilities/index.html">laue.utilities</a></code></dt>
<dd>
<div class="desc"><p><strong> Outils en tout genre. </strong>
â€¦</p></div>
</dd>
<dt><code class="name"><a title="laue.zone_axis" href="zone_axis.html">laue.zone_axis</a></code></dt>
<dd>
<div class="desc"><p><strong> Represente un axe de zone. </strong>
â€¦</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laue.atomic_find_subsets"><code class="name flex">
<span>def <span class="ident">atomic_find_subsets</span></span>(<span>spots_dict, axes_dict, angle_max, spots_max, distance_max)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.subsets.atomic_find_subsets" href="core/subsets.html#laue.core.subsets.atomic_find_subsets">atomic_find_subsets()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_find_subsets(spots_dict, axes_dict, angle_max, spots_max, distance_max):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de separation de grains. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.experiment.base_experiment.Experiment.find_subsets``
    ou encore via ``laue.diagram.LaueDiagram.find_subsets`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.experiment.base_experiment.Experiment.find_subsets`` gere nativement le parallelisme.

    Parameters
    ----------
    spots_dict : dict
        Une representation des spots et des information minimales
        qui y sont raccrochees. Il doit prendre la forme suivante:
        ``{spot_ind: {&#34;gnom&#34;: (x_gnom, y_gnom), &#34;axes&#34;: {1, 3, ...}}, ...}``
    axes_dict : dict
        Une representations des axes de zone. Doit etre de la forme:
        ``{axe_ind: {&#34;polar&#34;: (theta, dist), &#34;quality&#34;: .7, &#34;spots&#34;: {1, 4, 5, 6}}, ...}``
    Pour les autres arguments, se referer a ``laue.core.subsets.Splitable.find_subsets``.

    Returns
    -------
    list
        Chaque element est un ensemble d&#39;indice de spot appartenant au meme grain.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; spots_dict = {0: {&#39;gnom&#39;: (0.3136510725564478, -0.44091934214920697), &#39;axes&#39;: set()},
    ...               1: {&#39;gnom&#39;: (0.3092269223801162, -0.3703963974694111), &#39;axes&#39;: {0}},
    ...               2: {&#39;gnom&#39;: (0.29464954430652696, 0.39670741889986955), &#39;axes&#39;: {1}},
    ...               3: {&#39;gnom&#39;: (0.30191318963902786, 0.011759364157261544), &#39;axes&#39;: {2}},
    ...               4: {&#39;gnom&#39;: (0.2656586060012433, -0.29892567761860783), &#39;axes&#39;: {0}},
    ...               5: {&#39;gnom&#39;: (0.2537441830952802, 0.32256757073867776), &#39;axes&#39;: {1}},
    ...               6: {&#39;gnom&#39;: (0.259687191990358, 0.011094867051531301), &#39;axes&#39;: {2}},
    ...               7: {&#39;gnom&#39;: (0.21447480004378858, -0.2150686716681864), &#39;axes&#39;: {0}},
    ...               8: {&#39;gnom&#39;: (0.2057015738443993, 0.2356420984106664), &#39;axes&#39;: {1}},
    ...               9: {&#39;gnom&#39;: (0.09095514707222462, -0.5356714822419564), &#39;axes&#39;: {3, 4}},
    ...               10: {&#39;gnom&#39;: (0.06846289051965272, 0.5548594993575858), &#39;axes&#39;: {3, 5}},
    ...               11: {&#39;gnom&#39;: (0.16685972592987006, -0.1362785647833782), &#39;axes&#39;: {0}},
    ...               12: {&#39;gnom&#39;: (0.16092652407854113, 0.15424696872260854), &#39;axes&#39;: {1}},
    ...               13: {&#39;gnom&#39;: (0.0880179013812851, -0.40043047804756454), &#39;axes&#39;: {3}},
    ...               14: {&#39;gnom&#39;: (0.07130573600458438, 0.4174843621463065), &#39;axes&#39;: {3}},
    ...               15: {&#39;gnom&#39;: (0.08639048300887514, -0.31911672107326594), &#39;axes&#39;: {3}},
    ...               16: {&#39;gnom&#39;: (0.07308383568548608, 0.3351760458933546), &#39;axes&#39;: {3}},
    ...               17: {&#39;gnom&#39;: (-0.016567440130016563, -0.5541568143935384), &#39;axes&#39;: {6}},
    ...               18: {&#39;gnom&#39;: (-0.04084781468303007, 0.5689448068249144), &#39;axes&#39;: {7}},
    ...               19: {&#39;gnom&#39;: (0.0011982188252073992, -0.45016007120047424), &#39;axes&#39;: set()},
    ...               20: {&#39;gnom&#39;: (-0.018154025485441625, 0.46402526754308027), &#39;axes&#39;: set()},
    ...               21: {&#39;gnom&#39;: (-0.07286049562681773, -0.5640133440412382), &#39;axes&#39;: set()},
    ...               22: {&#39;gnom&#39;: (0.0798366324753105, 0.007023938379407561), &#39;axes&#39;: {0, 1, 2, 3}},
    ...               23: {&#39;gnom&#39;: (-0.0026903259324252246, 0.3921879524265071), &#39;axes&#39;: {5}},
    ...               24: {&#39;gnom&#39;: (-0.09784778756977644, 0.5766271192972883), &#39;axes&#39;: set()},
    ...               25: {&#39;gnom&#39;: (0.008002458469782677, -0.12293574282766238), &#39;axes&#39;: {1}},
    ...               26: {&#39;gnom&#39;: (0.0027460490484708115, 0.13394781189060836), &#39;axes&#39;: {0}},
    ...               27: {&#39;gnom&#39;: (-0.00523750349077013, -0.1470394198008183), &#39;axes&#39;: {1}},
    ...               28: {&#39;gnom&#39;: (-0.011614516626281228, 0.15777148638160254), &#39;axes&#39;: {0}},
    ...               29: {&#39;gnom&#39;: (-0.02477598980567221, -0.1823836791494654), &#39;axes&#39;: {1}},
    ...               30: {&#39;gnom&#39;: (-0.03264505249777272, 0.19229497060446735), &#39;axes&#39;: {0}},
    ...               31: {&#39;gnom&#39;: (-0.05554717740227801, -0.23832176191125093), &#39;axes&#39;: {1, 4}},
    ...               32: {&#39;gnom&#39;: (-0.06606796372263056, 0.24757266647939288), &#39;axes&#39;: {0, 5}},
    ...               33: {&#39;gnom&#39;: (-0.07907768658950604, -0.28096918114364355), &#39;axes&#39;: {1}},
    ...               34: {&#39;gnom&#39;: (-0.09156428823859053, 0.2893970244445073), &#39;axes&#39;: {0}},
    ...               35: {&#39;gnom&#39;: (-0.1126289846318788, -0.3416241560303849), &#39;axes&#39;: {1, 6}},
    ...               36: {&#39;gnom&#39;: (-0.060637577826655534, 0.0040391083212410655), &#39;axes&#39;: {2}},
    ...               37: {&#39;gnom&#39;: (-0.12787900102974828, 0.3491863530719953), &#39;axes&#39;: {0, 7}},
    ...               38: {&#39;gnom&#39;: (-0.1638208798822865, -0.4347286698438957), &#39;axes&#39;: {1}},
    ...               39: {&#39;gnom&#39;: (-0.18763951100210385, -0.4776573606384503), &#39;axes&#39;: {1}},
    ...               40: {&#39;gnom&#39;: (-0.1835787305562983, 0.4411739247300923), &#39;axes&#39;: {0}},
    ...               41: {&#39;gnom&#39;: (-0.08524649743749545, 0.003436523504335945), &#39;axes&#39;: {2}},
    ...               42: {&#39;gnom&#39;: (-0.2523542667003644, -0.5949096601292776), &#39;axes&#39;: {8, 1}},
    ...               43: {&#39;gnom&#39;: (-0.20958039716029048, 0.4837711867805186), &#39;axes&#39;: {0}},
    ...               44: {&#39;gnom&#39;: (-0.11758167206566646, -0.1123768702642382), &#39;axes&#39;: {4}},
    ...               45: {&#39;gnom&#39;: (-0.12266805447587614, 0.11817207059217111), &#39;axes&#39;: {5}},
    ...               46: {&#39;gnom&#39;: (-0.17376685735949005, 0.0016472083664571353), &#39;axes&#39;: {2, 4, 5}},
    ...               47: {&#39;gnom&#39;: (-0.20724297206742168, -0.25150647771157364), &#39;axes&#39;: set()},
    ...               48: {&#39;gnom&#39;: (-0.19501092265693473, -0.15910834995174863), &#39;axes&#39;: {6}},
    ...               49: {&#39;gnom&#39;: (-0.21870028043714163, 0.25404867230414246), &#39;axes&#39;: set()},
    ...               50: {&#39;gnom&#39;: (-0.2022799134764107, 0.16163477331619278), &#39;axes&#39;: {7}},
    ...               51: {&#39;gnom&#39;: (-0.2581018757728966, -0.3579924435989167), &#39;axes&#39;: {8}},
    ...               52: {&#39;gnom&#39;: (-0.2748170617964089, 0.3596407013965223), &#39;axes&#39;: {8}},
    ...               53: {&#39;gnom&#39;: (-0.21290266125204668, 0.0008346770568725252), &#39;axes&#39;: {2}},
    ...               54: {&#39;gnom&#39;: (-0.21986841578944072, -0.10369811043407293), &#39;axes&#39;: {5, 6}},
    ...               55: {&#39;gnom&#39;: (-0.224622744015843, 0.10503684334781563), &#39;axes&#39;: {4, 7}},
    ...               56: {&#39;gnom&#39;: (-0.25955409478645797, -0.29848728294016463), &#39;axes&#39;: {8}},
    ...               57: {&#39;gnom&#39;: (-0.27338619051240226, 0.299389601118816), &#39;axes&#39;: {8}},
    ...               58: {&#39;gnom&#39;: (-0.3156632165624574, -0.4202358686963255), &#39;axes&#39;: set()},
    ...               59: {&#39;gnom&#39;: (-0.2618304221414466, -0.19929059589121062), &#39;axes&#39;: {8, 5}},
    ...               60: {&#39;gnom&#39;: (-0.2711073666720387, 0.1994839074523256), &#39;axes&#39;: {8, 4}},
    ...               61: {&#39;gnom&#39;: (-0.2637120677768278, -0.11984479170021081), &#39;axes&#39;: {8}},
    ...               62: {&#39;gnom&#39;: (-0.26934469418071083, 0.11943958616023759), &#39;axes&#39;: {8}},
    ...               63: {&#39;gnom&#39;: (-0.26653796331705015, -0.00040349411462381246), &#39;axes&#39;: {8, 2, 6, 7}},
    ...               64: {&#39;gnom&#39;: (-0.3351088299984176, -0.36661822106768144), &#39;axes&#39;: {5}},
    ...               65: {&#39;gnom&#39;: (-0.30919293226499917, -0.22782988778598667), &#39;axes&#39;: set()},
    ...               66: {&#39;gnom&#39;: (-0.3524825023650732, 0.3647641920521141), &#39;axes&#39;: {4}},
    ...               67: {&#39;gnom&#39;: (-0.31990969642322137, 0.22611752961083748), &#39;axes&#39;: set()},
    ...               68: {&#39;gnom&#39;: (-0.3144023520521512, -0.0013698968940222644), &#39;axes&#39;: {2}},
    ...               69: {&#39;gnom&#39;: (-0.3223772542169661, -0.14153279317889217), &#39;axes&#39;: {7}},
    ...               70: {&#39;gnom&#39;: (-0.3290872223583307, 0.13867490378055763), &#39;axes&#39;: {6}},
    ...               71: {&#39;gnom&#39;: (-0.34380505280556134, -0.0019232844125064402), &#39;axes&#39;: {2}},
    ...               72: {&#39;gnom&#39;: (-0.3716527272451695, -0.2655541496297943), &#39;axes&#39;: {7}},
    ...               73: {&#39;gnom&#39;: (-0.384382394518522, 0.26137948985364423), &#39;axes&#39;: {6}},
    ...               74: {&#39;gnom&#39;: (-0.4150393355485816, -0.37556396956837046), &#39;axes&#39;: {7}},
    ...               75: {&#39;gnom&#39;: (-0.4213116259525938, -0.1277995546595711), &#39;axes&#39;: set()},
    ...               76: {&#39;gnom&#39;: (-0.42743697409652126, 0.12091462467337603), &#39;axes&#39;: set()},
    ...               77: {&#39;gnom&#39;: (-0.4305672928685682, -0.10207732996277492), &#39;axes&#39;: set()}}
    &gt;&gt;&gt; axes_dict = {0: {&#39;polar&#39;: (0.5456325, 0.07189146), &#39;quality&#39;: 0.7786729549943984, &#39;spots&#39;: {32, 1, 34, 4, 37, 7, 40, 11, 43, 22, 26, 28, 30}},
    ...              1: {&#39;polar&#39;: (-0.50404394, 0.066435024), &#39;quality&#39;: 0.8495679649229442, &#39;spots&#39;: {33, 2, 35, 5, 38, 39, 8, 42, 12, 22, 25, 27, 29, 31}},
    ...              2: {&#39;polar&#39;: (1.5920126, 0.0053436677), &#39;quality&#39;: 0.5048333500772214, &#39;spots&#39;: {3, 36, 68, 6, 71, 41, 46, 53, 22, 63}},
    ...              3: {&#39;polar&#39;: (0.020630987, 0.07989738), &#39;quality&#39;: 0.32446216058045907, &#39;spots&#39;: {9, 10, 13, 14, 15, 16, 22}},
    ...              4: {&#39;polar&#39;: (-2.6840417, 0.15513226), &#39;quality&#39;: 0.32470155528405464, &#39;spots&#39;: {66, 9, 44, 46, 55, 60, 31}},
    ...              5: {&#39;polar&#39;: (2.7287471, 0.15980783), &#39;quality&#39;: 0.36693478788694234, &#39;spots&#39;: {32, 64, 10, 45, 46, 54, 23, 59}},
    ...              6: {&#39;polar&#39;: (-2.7180853, 0.24310948), &#39;quality&#39;: 0.324204821510315, &#39;spots&#39;: {35, 70, 73, 48, 17, 54, 63}},
    ...              7: {&#39;polar&#39;: (2.7643242, 0.24759501), &#39;quality&#39;: 0.3668147624332471, &#39;spots&#39;: {69, 37, 72, 74, 18, 50, 55, 63}},
    ...              8: {&#39;polar&#39;: (-3.118213, 0.26645306), &#39;quality&#39;: 0.5046664108258551, &#39;spots&#39;: {42, 51, 52, 56, 57, 59, 60, 61, 62, 63}}}
    &gt;&gt;&gt; kwargs = {&#39;angle_max&#39;: 0.1308996938995747, &#39;spots_max&#39;: 20, &#39;distance_max&#39;: 0.08}
    &gt;&gt;&gt; laue.atomic_find_subsets(spots_dict, axes_dict, **kwargs)
    [{9, 10, 22}]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.zone_axis import distance as distance_axis
    from laue.spot import distance as distance_pic
    import networkx

    def count_variant_axis(spot_id):
        &#34;&#34;&#34;
        Compte le nombre d&#39;axes de zone qui different beaucoup.
        (ie considere 2 axes proche comme un seul axe)
        &#34;&#34;&#34;
        axes_id = spots_dict[spot_id][&#34;axes&#34;]
        if len(axes_id) &lt;= 1:
            return len(axes_id)
        axes = [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes_id]
        nbr_near = (distance_axis(axes, axes, weight=1) &lt; angle_max).sum()
        nbr = len(axes) - (nbr_near-len(axes))//2
        return nbr

    def simul_remove_axis(graph, axis, excluded):
        &#34;&#34;&#34;
        Retire les aretes liees a cet axe, puis regarde ce que ca donne.
        &#34;&#34;&#34;
        graph_bis = graph.copy()
        for spot1, spot2, axis_found in graph.edges.data(&#34;axis&#34;):
            if axis_found is axis:
                graph_bis.remove_edge(spot1, spot2)
        excluded_bis = [edge for edge in excluded if networkx.algorithms.has_path(graph_bis, *edge)]
        return excluded_bis, graph_bis

    # Extraction des spots.
    spots_at_cross = sorted(spots_dict, key=count_variant_axis, reverse=True)[:spots_max]
    max_cross = count_variant_axis(spots_at_cross[0])
    limit = math.sqrt(max(2**2, max_cross)) # Permet d&#39;eviter &#39;ValueError: math domain error&#39;
    spots_at_cross = [spot_id for spot_id in spots_at_cross if count_variant_axis(spot_id) &gt;= limit]

    # Creation des noeuds du graphe.
    graph = networkx.Graph()
    graph.add_nodes_from(spots_at_cross)

    # Ajout grossier de certaine aretes.
    excluded = [] # La liste des noeuds appartenant a des grains differents.
    candidate_axes = set() # L&#39;ensemble des axes de zone consideres.
    for i, spot1 in enumerate(spots_at_cross[:-1]): # On faite toutes les combinaisons
        for spot2 in spots_at_cross[i+1:]: # de 2 sommets possibles.

            ## Exclusion des spots trop proches.
            if distance_pic(
                    spots_dict[spot1][&#34;gnom&#34;],
                    spots_dict[spot2][&#34;gnom&#34;],
                    space=&#34;gnomonic&#34;
                    ) &lt; distance_max:
                excluded.append((spot1, spot2))
                continue

            ## On ne relie pas les spots qui n&#39;ont pas d&#39;axe commun.
            common_axes = spots_dict[spot1][&#34;axes&#34;] &amp; spots_dict[spot2][&#34;axes&#34;]
            if not common_axes:
                continue

            ## Exclusion des spots ayant 2 axes de zone paralleles.
            axes1, axes2 = spots_dict[spot1][&#34;axes&#34;]-common_axes, spots_dict[spot2][&#34;axes&#34;]-common_axes
            if axes1 and axes2 and distance_axis(
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes1],
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes2],
                    weight=1).min() &lt; angle_max: # tolerance angulaire de pi/32
                excluded.append((spot1, spot2))
                continue

            ## Ajout dans le graphe.
            best_axis = sorted(common_axes, key=lambda axis_id: axes_dict[axis_id][&#34;quality&#34;])[-1]
            candidate_axes.add(best_axis)
            graph.add_edge(spot1, spot2, quality=axes_dict[best_axis][&#34;quality&#34;], axis=best_axis)

    # Suppression des aretes en trop afin de discosier les grains.
    excluded = [edge for edge in excluded if networkx.algorithms.has_path(graph, *edge)]
    while excluded:
        predictions = [(*simul_remove_axis(graph, axis_id, excluded), axis_id) for axis_id in candidate_axes]
        best_len = min(len(excluded_bis) for excluded_bis, _, _ in predictions)
        predictions = [p for p in predictions if len(p[0]) == best_len]
        costs = [axes_dict[axis_id][&#34;quality&#34;] for _, _, axis_id in predictions]
        min_quality = min(costs)
        predictions = [p for p in predictions if axes_dict[p[2]][&#34;quality&#34;] == min_quality]
        excluded, graph, axis_id = predictions.pop()
        candidate_axes.remove(axis_id)

    # Creation des clusters.
    subsets = list(networkx.algorithms.connected_components(graph))
    subsets = sorted(subsets, key=lambda con: len(con), reverse=True)
    subsets = [con for con in subsets if len(con) &gt;= 2]
    return subsets</code></pre>
</details>
</dd>
<dt id="laue.atomic_find_zone_axes"><code class="name flex">
<span>def <span class="ident">atomic_find_zone_axes</span></span>(<span>transformer, gnomonics, dmax, nbr, tol)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.zone_axes.atomic_find_zone_axes" href="core/zone_axes.html#laue.core.zone_axes.atomic_find_zone_axes">atomic_find_zone_axes()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_find_zone_axes(transformer, gnomonics, dmax, nbr, tol):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de recherche d&#39;axes de zonnes. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.experiment.base_experiment.Experiment.find_zone_axes``
    ou encore via ``laue.diagram.LaueDiagram.find_zone_axes`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.experiment.base_experiment.Experiment.find_zone_axes`` gere nativement le parallelisme.
    * La seule raison d&#39;utiliser cette fonction, c&#39;est si le pic_search
    utilise n&#39;est pas celui de ``laue.experiment.base_experiment.Experiment``. Sinon, l&#39;utilisation
    de cette fonction ne fera qu&#39;alourdir et ralentir votre code.

    Parameters
    ----------
    transformer : laue.core.geometry.transformer.Transformer
        Instance d&#39;un objet capable de gerer formellement
        la transformee de hough. (Cet argument n&#39;est pas present
        si on utilise les methodes ci dessus car il fait partie
        d&#39;une ``laue.experiment.base_experiment.Experiment``.)
    gnomonics : np.ndarray
        Les positions des spots en coordonnees gnomonic.
        Il faut que ``x_gnomonic = gnomonic[0]``
        et que ``y_gnomonic = gnomonic[1]``.
    dmax
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre n&#39;est pas factultatif.
    nbr
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre n&#39;est pas factultatif.
    tol
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre doit etre fixe par vous et ne peut
        pas prendre tous seulle une valeur optimale.

    Returns
    -------
    angles : iterable
        Vecteur des angles des droites. C&#39;est la premiere partie
        de la representation polaire des droites. (C&#39;est l&#39;angle
        algebrique entre l&#39;axe x et un vecteur normal a la droite.)
    dists : iterable
        Vecteur des distances des droites. C&#39;est la seconde partie
        de la representation polaire des droites. (C&#39;est la plus courte
        distance entre l&#39;origine et tous les points constituant la droite.)
    axes_spots_ind : list
        Vecteur des ensembles de spots lies a chaque droites.
        On a ``len(axes_spots_ind) == nbr_d_axe_de_zones``.
    spots_axes_ind : list
        Vecteur des indices des droites passant par chaque spot.
        On a ``len(spots_axes_ind) == nbr_de_spots``.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; gnomonics = np.array(
    ... [[ 3.13651353e-01,  3.09226930e-01,  2.94649661e-01,  3.01913261e-01,
    ...    2.65658647e-01,  2.53744185e-01,  2.59687364e-01,  2.14474797e-01,
    ...    2.05701679e-01,  9.09550861e-02,  6.84629381e-02,  1.66859716e-01,
    ...    1.60926506e-01,  8.80179554e-02,  7.13057593e-02,  8.63905624e-02,
    ...    7.30837137e-02, -1.65674724e-02, -4.08478454e-02,  1.19812461e-03,
    ...   -1.81540363e-02, -7.28605017e-02,  7.98366740e-02, -2.69038416e-03,
    ...   -9.78478342e-02,  8.00240133e-03,  2.74614431e-03, -5.23754954e-03,
    ...   -1.16145127e-02, -2.47761104e-02, -3.26450653e-02, -5.55472001e-02,
    ...   -6.60679415e-02, -7.90777430e-02, -9.15642828e-02, -1.12629071e-01,
    ...   -6.06376082e-02, -1.27878949e-01, -1.63820893e-01, -1.87639564e-01,
    ...   -1.83578789e-01, -8.52464810e-02, -2.52354264e-01, -2.09580392e-01,
    ...   -1.17581628e-01, -1.22668095e-01, -1.73766926e-01, -2.07243070e-01,
    ...   -1.95010900e-01, -2.18700320e-01, -2.02279896e-01, -2.58101851e-01,
    ...   -2.74817050e-01, -2.12902710e-01, -2.19868407e-01, -2.24622726e-01,
    ...   -2.59554148e-01, -2.73386180e-01, -3.15663189e-01, -2.61830509e-01,
    ...   -2.71107376e-01, -2.63712078e-01, -2.69344717e-01, -2.66537964e-01,
    ...   -3.35108876e-01, -3.09192955e-01, -3.52482527e-01, -3.19909692e-01,
    ...   -3.14402401e-01, -3.22377235e-01, -3.29087257e-01, -3.43805134e-01,
    ...   -3.71652663e-01, -3.84382367e-01, -4.15039361e-01, -4.21311647e-01,
    ...   -4.27436978e-01, -4.30567324e-01],
    ...  [-4.40919399e-01, -3.70396405e-01,  3.96707416e-01,  1.17593547e-02,
    ...   -2.98925638e-01,  3.22567523e-01,  1.10948607e-02, -2.15068594e-01,
    ...    2.35642120e-01, -5.35671413e-01,  5.54859519e-01, -1.36278614e-01,
    ...    1.54246926e-01, -4.00430471e-01,  4.17484373e-01, -3.19116771e-01,
    ...    3.35176021e-01, -5.54156780e-01,  5.68944812e-01, -4.50160027e-01,
    ...    4.64025259e-01, -5.64013302e-01,  7.02395430e-03,  3.92187923e-01,
    ...    5.76627076e-01, -1.22935735e-01,  1.33947819e-01, -1.47039399e-01,
    ...    1.57771528e-01, -1.82383612e-01,  1.92295000e-01, -2.38321751e-01,
    ...    2.47572735e-01, -2.80969173e-01,  2.89397061e-01, -3.41624111e-01,
    ...    4.03913576e-03,  3.49186361e-01, -4.34728622e-01, -4.77657378e-01,
    ...    4.41173941e-01,  3.43652675e-03, -5.94909608e-01,  4.83771175e-01,
    ...   -1.12376906e-01,  1.18172102e-01,  1.64722977e-03, -2.51506448e-01,
    ...   -1.59108326e-01,  2.54048705e-01,  1.61634743e-01, -3.57992381e-01,
    ...    3.59640747e-01,  8.34673643e-04, -1.03698038e-01,  1.05036855e-01,
    ...   -2.98487246e-01,  2.99389601e-01, -4.20235783e-01, -1.99290574e-01,
    ...    1.99483901e-01, -1.19844824e-01,  1.19439557e-01, -4.03501937e-04,
    ...   -3.66618216e-01, -2.27829859e-01,  3.64764214e-01,  2.26117536e-01,
    ...   -1.36989250e-03, -1.41532809e-01,  1.38674900e-01, -1.92326447e-03,
    ...   -2.65554100e-01,  2.61379480e-01, -3.75563949e-01, -1.27799526e-01,
    ...    1.20914638e-01, -1.02077320e-01]])
    &gt;&gt;&gt; dmax = 0.01086181640625
    &gt;&gt;&gt; nbr = 7
    &gt;&gt;&gt; tol = 0.01758723266
    &gt;&gt;&gt; angles, dists, axes_spots_ind, spots_axes_ind = laue.atomic_find_zone_axes(
    ...     transformer, gnomonics, dmax, nbr, tol)
    &gt;&gt;&gt; len(angles), len(dists)
    (9, 9)
    &gt;&gt;&gt; for spots in axes_spots_ind:
    ...     print(sorted(spots))
    ...
    [1, 4, 7, 11, 22, 26, 28, 30, 32, 34, 37, 40, 43]
    [2, 5, 8, 12, 22, 25, 27, 29, 31, 33, 35, 38, 39, 42]
    [3, 6, 22, 36, 41, 46, 53, 63, 68, 71]
    [9, 10, 13, 14, 15, 16, 22]
    [9, 31, 44, 46, 55, 60, 66]
    [10, 23, 32, 45, 46, 54, 59, 64]
    [17, 35, 48, 54, 63, 70, 73]
    [18, 37, 50, 55, 63, 69, 72, 74]
    [42, 51, 52, 56, 57, 59, 60, 61, 62, 63]
    &gt;&gt;&gt; spots_axes_ind[0]
    set()
    &gt;&gt;&gt; sorted(spots_axes_ind[22])
    [0, 1, 2, 3]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.core.geometry.transformer import ind2comb

    # Recherches des axes de zone.
    angles, dists = transformer.hough_reduce(
        *transformer.hough(*gnomonics),
        nbr=nbr, tol=tol) # Recuperation des axes.
    if len(angles) &lt;= 1: # Si on a pas trouve suffisement de choses.
        return (), (), (), ((),)*gnomonics.shape[-1]

    # Attribution des points aux droites.
    axes_spots_ind = [set() for _ in range(len(angles))] # A chaque droite, c&#39;est les spots qu&#39;elle possede.
    spots_axes_ind = [set() for _ in range(gnomonics.shape[-1])]
    x_inters, y_inters = transformer.inter_lines(angles, dists)
    xg_spots, yg_spots = gnomonics

    ## Recuperation des points aux intersections.
    
    ### Calcul des points les plus proche pour chaque intersections.
    used_memory = len(x_inters)*len(xg_spots)*8 # Taille de la matrice de distance en octet.
    if psutil is not None and psutil.virtual_memory().available &gt; 2*used_memory:
        xg_spots_mesh, x_inters_mesh = np.meshgrid(xg_spots, x_inters, copy=False)
        yg_spots_mesh, y_inters_mesh = np.meshgrid(yg_spots, y_inters, copy=False)
        if numexpr is not None: # d[inter, gnomo]
            distances = numexpr.evaluate(
                &#34;sqrt((xg_spots_mesh-x_inters_mesh)**2 + (yg_spots_mesh-y_inters_mesh)**2)&#34;)
        else:
            distances = np.sqrt((xg_spots_mesh-x_inters_mesh)**2 + (yg_spots_mesh-y_inters_mesh)**2)
        nearest_spots = np.argmin(distances, axis=1) # Pour chaque intersections, son spot le plus proche.
        del distances, xg_spots_mesh, x_inters_mesh, yg_spots_mesh, y_inters_mesh
    else: # Si il n&#39;y a pas suffisement de RAM.
        nearest_spots = np.array([ # attention &#39;numexpr&#39; est 7 fois plus lent.
            np.argmin(np.sqrt((xg_spots-x_inter)**2 + (yg_spots-y_inter)**2))
            for x_inter, y_inter in zip(x_inters, y_inters)], dtype=int)

    ### Selection des bons candidats.
    spots_left = [] # Les spots non references.
    for spot_ind, (xg_pic, yg_pic) in enumerate(zip(xg_spots, yg_spots)):
        inters_cand = np.argwhere(nearest_spots == spot_ind)
        adds_inter = inters_cand[
            (x_inters[inters_cand]-xg_pic)**2
          + (y_inters[inters_cand]-yg_pic)**2
          &lt; dmax**2]
        if adds_inter.any():
            _adds_axes_1, _adds_axes_2 = ind2comb(adds_inter, n=len(angles))
            adds_axes = set(_adds_axes_1) | set(_adds_axes_2)
            for add_axis in adds_axes:
                axes_spots_ind[add_axis].add(spot_ind)
            spots_axes_ind[spot_ind].update(adds_axes) # f&#34;le spot num {spot_ind} est l&#39;intersections des axes {adds_axes}.&#34;
        else:
            spots_left.append(spot_ind)

    ## Recuperation des points colles a un seul axe.
    spots_left = np.array(spots_left, dtype=int) # Les indices des spots restants.

    used_memory = len(spots_left)*len(angles)*8 # Taille memoire de la matrice de distances.
    if psutil is not None and psutil.virtual_memory().available &gt; 2*used_memory:
        distances = transformer.dist_line( # d[line, point]
            angles, dists, xg_spots[spots_left], yg_spots[spots_left])
        axis_ind = np.argmin(distances, axis=0) # A chaque points, indice de la droite la plus proche.
        close_spots = distances.min(axis=0) &lt; dmax # La matrice des points suffisement proches.
        del distances
        for axis_ind, spot_left in zip(axis_ind[close_spots], spots_left[close_spots]):
            axes_spots_ind[axis_ind].add(spot_left)
            spots_axes_ind[spot_left].add(axis_ind)   
    else: # Si il n&#39;y a pas suffisement de RAM.
        for spot_left, xg_pic, yg_pic in zip(spots_left, xg_spots[spots_left], yg_spots[spots_left]):
            xg_pic, yg_pic = np.array([xg_pic], dtype=np.float32), np.array([yg_pic], dtype=np.float32)
            distances = transformer.dist_line(angles, dists, xg_pic, yg_pic) # d[line, point]
            axis_ind = np.argmin(distances[:, 0])
            if distances[axis_ind] &lt; dmax:
                axes_spots_ind[axis_ind].add(spot_left)
                spots_axes_ind[spot_left].add(axis_ind)

    # Suppression des axes qui contiennent pas suffisement de points.
    mask_axes_to_keep = np.array([len(spots_ind) for spots_ind in axes_spots_ind]) &gt;= nbr
    ind_axes_to_keep = set(np.argwhere(mask_axes_to_keep)[:, 0])
    spots_axes_ind = [axes_ind &amp; ind_axes_to_keep for axes_ind in spots_axes_ind]
    axes_spots_ind = [spots_ind for axis_ind, spots_ind
                     in enumerate(axes_spots_ind)
                     if axis_ind in ind_axes_to_keep]
    angles, dists = angles[mask_axes_to_keep], dists[mask_axes_to_keep]

    # Changement des anciens par les nouveaux indices de droites.
    old_to_new = {
        old_axis_ind: new_axis_ind
        for new_axis_ind, old_axis_ind
        in enumerate(sorted(set.union(*spots_axes_ind)))}
    spots_axes_ind = [
        {old_to_new[old_axis_ind] for old_axis_ind in old_axes_ind}
        for old_axes_ind in spots_axes_ind]

    return angles, dists, axes_spots_ind, spots_axes_ind</code></pre>
</details>
</dd>
<dt id="laue.atomic_pic_search"><code class="name flex">
<span>def <span class="ident">atomic_pic_search</span></span>(<span>image, kernel_font, kernel_dilate, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.pic_search.atomic_pic_search" href="core/pic_search.html#laue.core.pic_search.atomic_pic_search">atomic_pic_search()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_pic_search(image, kernel_font, kernel_dilate, threshold):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau de pic search atomic serialisable. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers
    ``laue.experiment.base_experiment.Experiment.get_diagrams``
    ou encore via ``laue.experiment.base_experiment.Experiment.__iter__``
    car le context est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre les methodes
    de ``laue.experiment.base_experiment.Experiment`` gerent nativement le parallelisme.
    * L&#39;utilisation de cette fonction ne fera qu&#39;alourdir et ralentir votre code.

    Parameters
    ----------
    image : np.ndarray
        Image 2d en niveau de gris codee en np.uint16.
        C&#39;est l&#39;image brute, sans pre-traitement et avec le fond diffus.
    kernel_font : np.ndarray
        Le masque de l&#39;element structurant pour l&#39;estimation
        du fond par ouverture morphologique.
    kernel_dilate : np.ndarray
        Le masque de l&#39;element structurant pour la dilatation morphologique
        sur l&#39;image binarisee afin d&#39;aglomerer les grains proches.
    threshold : float
        Le niveau de seuillage relatif a la variance de l&#39;image.

    Returns
    -------
    list
        Une liste qui contient autant d&#39;elements de de pic trouves.
        Les element sont des dictionaires

    Examples
    --------
    &gt;&gt;&gt; import cv2
    &gt;&gt;&gt; from laue import atomic_pic_search
    &gt;&gt;&gt; from laue.utilities.image import read_image
    &gt;&gt;&gt; image_path = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt;
    &gt;&gt;&gt; image = read_image(image_path)
    &gt;&gt;&gt; kernel_font = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (21, 21))
    &gt;&gt;&gt; kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    &gt;&gt;&gt; threshold = 5.1
    &gt;&gt;&gt;
    &gt;&gt;&gt; res = atomic_pic_search(image, kernel_font, kernel_dilate, threshold)
    &gt;&gt;&gt; type(res)
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; len(res)
    78
    &gt;&gt;&gt; res[0][&#34;bbox&#34;]
    (1368, 1873, 6, 5)
    &gt;&gt;&gt; res[0][&#34;distortion&#34;]
    0.8471580534997302
    &gt;&gt;&gt; res[0][&#34;spot_im&#34;]
    array([[  8,  10,  16,  16,   8,   5],
           [ 11,  17,  67,  76,  13,   9],
           [  7,  19, 184, 229,  14,   6],
           [  9,   6,  12,  19,   8,   4],
           [  5,   3,   3,   9,  14,   7]], dtype=uint16)
    &gt;&gt;&gt; 
    &#34;&#34;&#34;
    # Binarisation de l&#39;image.
    bg_image = cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel_font, iterations=1)
    fg_image = image - bg_image
    thresh_image = (fg_image &gt; threshold*fg_image.std()).astype(np.uint8)
    dilated_image = cv2.dilate(thresh_image, kernel_dilate, iterations=1)

    # Detection des contours grossiers.
    outlines, _ = cv2.findContours(dilated_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    bbox = [cv2.boundingRect(outl) for outl in outlines]

    # Calcul des distortions.
    distortions_open = (2*np.sqrt(np.pi)) / np.array([
        cv2.arcLength(outl, True)/np.sqrt(cv2.contourArea(outl))
        for outl in outlines])

    # Preparation des arguments des spots.
    spots_args = [
        {
            &#34;bbox&#34;: (x, y, w, h),
            &#34;spot_im&#34;: fg_image[y:y+h, x:x+w],
            &#34;distortion&#34;: dis,
        }
        for dis, (x, y, w, h) in zip(distortions_open, bbox)]

    return spots_args</code></pre>
</details>
</dd>
<dt id="laue.cam_to_gnomonic"><code class="name flex">
<span>def <span class="ident">cam_to_gnomonic</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.cam_to_gnomonic" href="core/geometry/index.html#laue.core.geometry.cam_to_gnomonic">cam_to_gnomonic()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cam_to_gnomonic(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.cam_to_gnomonic``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;cam_to_gnomonic&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.cam_to_thetachi"><code class="name flex">
<span>def <span class="ident">cam_to_thetachi</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.cam_to_thetachi" href="core/geometry/index.html#laue.core.geometry.cam_to_thetachi">cam_to_thetachi()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cam_to_thetachi(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.cam_to_thetachi``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;cam_to_thetachi&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.comb2ind"><code class="name flex">
<span>def <span class="ident">comb2ind</span></span>(<span>ind1, ind2, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.transformer.comb2ind" href="core/geometry/transformer.html#laue.core.geometry.transformer.comb2ind">comb2ind()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comb2ind(ind1, ind2, n):
    &#34;&#34;&#34;
    ** Transforme 2 indices en un seul. **

    Note
    ----
    * Bijection de ``ind2comb``.
    * Peut etre utile pour les methodes ``laue.core.geometry.transformer.Transformer.hough``
    et ``laue.core.geometry.transformer.Transformer.inter_lines``.

    Parameters
    ----------
    ind1 : int ou np.ndarray(dtype=int)
        L&#39;indice du premier element: ``0 &lt;= ind1``.
    ind2 : int ou np.ndarray(dtype=int)
        L&#39;indice du second element: ``ind1 &lt; ind2``.
    n : int
        Le nombre de symboles : ``2 &lt;= n and ind2 &lt; n``.

    Returns
    -------
    int, np.ndarray(dtype=int)
        Le nombre de mots contenant exactement 2 symboles dans un
        alphabet de cardinal ``n``. Sachant que le deuxieme symbole
        est stricement superieur au premier, et que les mots sont
        generes avec le comptage naturel (representation des nombres
        en base n).

    Examples
    -------
    &gt;&gt;&gt; from laue.core.geometry.transformer import comb2ind
    &gt;&gt;&gt; comb2ind(0, 1, n=6)
    0
    &gt;&gt;&gt; comb2ind(0, 2, n=6)
    1
    &gt;&gt;&gt; comb2ind(0, 5, n=6)
    4
    &gt;&gt;&gt; comb2ind(1, 2, n=6)
    5
    &gt;&gt;&gt; comb2ind(4, 5, n=6)
    14
    &#34;&#34;&#34;
    assert isinstance(ind1, (int, np.ndarray)), \
        f&#34;&#39;ind1&#39; can not being of type {type(ind1).__name__}.&#34;
    assert isinstance(ind2, (int, np.ndarray)), \
        f&#34;&#39;ind2&#39; can not being of type {type(ind2).__name__}.&#34;
    assert isinstance(n, int), f&#34;&#39;n&#39; has to ba an integer, not a {type(n).__name__}.&#34;
    if isinstance(ind1, np.ndarray):
        assert ind1.dtype == int or issubclass(ind2.dtype.type, np.integer), \
            f&#34;&#39;ind1&#39; must be integer, not {str(ind1.dtype)}.&#34;
        assert (ind1 &gt;= 0).all(), &#34;Tous les indices doivent etres positifs.&#34;
    else:
        assert ind1 &gt;= 0, &#34;Les indices doivent etre positifs.&#34;
    if isinstance(ind2, np.ndarray):
        assert ind2.dtype == int or issubclass(ind2.dtype.type, np.integer), \
            f&#34;&#39;ind2&#39; must be integer, not {str(ind2.dtype)}.&#34;
        assert ind1.shape == ind2.shape, (&#34;Si les indices sont des arrays, elles doivent &#34;
            f&#34;toutes 2 avoir les memes dimensions. {ind1.shape} vs {ind2.shape}.&#34;)
        assert (ind2 &gt; ind1).all(), (&#34;Les 2ieme indices doivent &#34;
            &#34;etres strictement superieur aux premiers.&#34;)
        assert (ind2 &lt; n).all(), &#34;Vous aimez un peu trop les &#39;index out of range&#39;.&#34;
    else:
        assert ind2 &gt; ind1, (&#34;Le 2ieme indice doit etre strictement superieur au premier. &#34;
            f&#34;{ind1} vs {ind2}.&#34;)
        assert ind2 &lt; n, &#34;Vous aimez un peu trop les &#39;index out of range&#39;.&#34;

    return n*ind1 - (ind1**2 + 3*ind1)//2 + ind2 - 1</code></pre>
</details>
</dd>
<dt id="laue.create_image"><code class="name flex">
<span>def <span class="ident">create_image</span></span>(<span>positions, intensities=None, *, shape=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.image.create_image" href="utilities/image.html#laue.utilities.image.create_image">create_image()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_image(positions, intensities=None, *, shape=None):
    &#34;&#34;&#34;
    ** Genere syntetiquement une image de laue. **

    Paremeters
    ----------
    positions : iterable
        Les coordonnes x et y des spots en pxl dans le plan de la camera.
    intensities : iterable, optional
        L&#39;intensite de chaque spot.
    shape : tuple, optional
        Les dimensions x, y de l&#39;image de sortie. Par defaut, les
        valeurs maximales des positions sont utilisees.

    Returns
    -------
    image : np.ndarray
        L&#39;image en niveau de gris codee en uint16.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from laue.utilities.image import create_image
    &gt;&gt;&gt; np.random.seed(0)
    &gt;&gt;&gt;
    &gt;&gt;&gt; positions = np.random.uniform(0, 2048, size=(2, 600))
    &gt;&gt;&gt; create_image(positions)
    array([[    0,     0,     0, ...,     0,     0,     0],
           [    0,     0,     0, ...,     0,     0,     0],
           [    0,     0,     0, ...,     0,     0,     0],
           ...,
           [    0,     0,     0, ...,  6592,  6592,  6592],
           [    0,     0,     0, ..., 12128, 12128, 12128],
           [    0,     0,     0, ..., 12128, 12128, 12128]], dtype=uint16)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(positions, (np.ndarray, list, tuple)), \
        f&#34;&#39;positions&#39; doit etre un iterable ordonne, pas {positions}.&#34;
    assert intensities is None or isinstance(intensities, (np.ndarray, list, tuple)), \
        f&#34;&#39;intensities&#39; doit etre un iterable ordonne, pas {intensities}.&#34;
    assert shape is None or isinstance(shape, tuple), \
        f&#34;&#39;shape&#39; has to be a tuple, not a {type(shape).__name__}.&#34;
    positions = np.array(positions)
    assert positions.ndim == 2, f&#34;Les positions doivent etre une matrice 2d, pas {positions.ndim}d.&#34;
    if positions.shape[1] == 2 and positions.shape[0] != 2:
        positions = positions.transpose()
    intensities = np.ones(positions.shape[1]) if intensities is None else np.array(intensities)
    assert intensities.shape == (positions.shape[1],), (&#34;Les positions sous-entendent qu&#39;il y a &#34;
        f&#34;{positions.shape[1]} spots. Les intensites doivent donc etre de shape=({positions.shape[1]},) &#34;
        f&#34;et non pas {intensities.shape}.&#34;)
    shape = (int(positions[0].max()+1), int(positions[1].max()+1)) if shape is None else shape
    assert len(shape) == 2, f&#34;L&#39;image et en 2d, pas en {len(shape)}d.&#34;
    assert isinstance(shape[0], int) and isinstance(shape[1], int), \
        f&#34;Les dimensions de l&#39;image sont en pxl et donc doivent etre des entiers.&#34;

    image = np.zeros(shape=shape, dtype=np.uint16)
    intensities *= len(intensities)/intensities.mean()

    for x, y, lum in zip(*positions, intensities):
        l = int(lum) + 1
        x, y = int(round(x)), int(round(y))
        cost = int(100*lum)
        image[x-l:x+l, y-l:y+l] += cost

    return image</code></pre>
</details>
</dd>
<dt id="laue.dist_cosine"><code class="name flex">
<span>def <span class="ident">dist_cosine</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.dist_cosine" href="core/geometry/index.html#laue.core.geometry.dist_cosine">dist_cosine()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist_cosine(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.dist_cosine``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;dist_cosine&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.dist_euclidian"><code class="name flex">
<span>def <span class="ident">dist_euclidian</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.dist_euclidian" href="core/geometry/index.html#laue.core.geometry.dist_euclidian">dist_euclidian()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist_euclidian(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.dist_euclidian``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;dist_euclidian&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.dist_line"><code class="name flex">
<span>def <span class="ident">dist_line</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.dist_line" href="core/geometry/index.html#laue.core.geometry.dist_line">dist_line()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist_line(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.dist_line``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;dist_line&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.extract_parameters"><code class="name flex">
<span>def <span class="ident">extract_parameters</span></span>(<span>ignore_missing=False, **detector_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.parsing.extract_parameters" href="utilities/parsing.html#laue.utilities.parsing.extract_parameters">extract_parameters()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_parameters(ignore_missing=False, **detector_parameters):
    &#34;&#34;&#34;
    ** Extrait les parametres de la camera. **

    Notes
    -----
    * Permet une grande souplesse d&#39;utilisation.
    * Tous les parametres ne sont pas forcement a preciser.

    Parameters
    ----------
    ignore_missing : boolean, optional
        * Permet d&#39;imposer ou non, d&#39;avoir un retour exhaustif:
        * True =&gt; Retourne toutes les grandeurs extraites, meme si il en manque.
        * False =&gt; S&#39;assure que tous les parametres ont etes correctement extraits.
    config_file : str
        Chemin du fichier &#39;*.det&#39; qui contient tous ces parametres.

    dd, detect, distance : float, int
        Plus courte distance entre l&#39;origine du cristal et le plan de la camera.
        ||OO&#39;|| en mm
    xcen, x0 : float, int
        Distance entre l&#39;origine de la camera et le point d&#39;incidence normal projetee selon X_camera.
        &lt;O&#39;&#39;O&#39;, Ci&gt; en pxl
    ycen, y0 : float, int
        Distance entre l&#39;origine de la camera et le point d&#39;incidence normal projetee selon Y_camera.
        &lt;O&#39;&#39;O&#39;, Cj&gt; en pxl
    xbet, bet, beta, angle1 : float
        Rotation du repere de la camera autour de l&#39;axe Y_cristal dans le sens.
        axe (Y_cristal ou Ci) en degre
    xgam, gam, gamma, angle2 : float
        Rotation du repere de la camera autour de l&#39;axe Ck qui a deja subit la rotation de ``xbet``.
        axe (OO&#39; ou Ck) en degre
    pixelsize, size, pxlsize : float
        Dimension du cote des pixels carre du capteur.
        (taille capteur x / nbr pixels x == taille capteur y / nbr pixels y) en mm/pxl

    Returns
    -------
    dict
        Le dictionaire qui a chaque nom de parametre, associ ca valeur.
        Les clefs et les valeurs typique sont par example:
        ``{&#34;dd&#34;: 70.0, &#34;xcen&#34;: 1024, &#34;ycen&#34;: 1024, &#34;xbet&#34;: .0, &#34;xgam&#34;: .0, &#34;pixelsize&#34;: .080567}``

    Raises
    ------
    ValueError
        Si il y a des incoherences. (Par example si le meme parametre a 2 valeurs differentes)
    KeyError
        Si il manque des parametres.

    Examples
    --------
    &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
    &gt;&gt;&gt; output = lambda pars: &#34;, &#34;.join(f&#34;{repr(k)}: {round(pars[k], 2)}&#34; for k in sorted(pars))
    &gt;&gt;&gt;
    &gt;&gt;&gt; output(extract_parameters(config_file=&#34;laue/examples/ge_blanc.det&#34;))
    &#34;&#39;dd&#39;: 71.51, &#39;pixelsize&#39;: 0.08, &#39;xbet&#39;: 0.43, &#39;xcen&#39;: 939.83, &#39;xgam&#39;: -0.7, &#39;ycen&#39;: 1076.42&#34;
    &gt;&gt;&gt; output(extract_parameters(dd=70, bet=.0, gam=.0, pixelsize=.08, x0=1024, y0=1024))
    &#34;&#39;dd&#39;: 70, &#39;pixelsize&#39;: 0.08, &#39;xbet&#39;: 0.0, &#39;xcen&#39;: 1024, &#39;xgam&#39;: 0.0, &#39;ycen&#39;: 1024&#34;
    &gt;&gt;&gt; output(extract_parameters(distance=70, angle2=.0, angle1=.0, size=.08, x0=1024, y0=1024))
    &#34;&#39;dd&#39;: 70, &#39;pixelsize&#39;: 0.08, &#39;xbet&#39;: 0.0, &#39;xcen&#39;: 1024, &#39;xgam&#39;: 0.0, &#39;ycen&#39;: 1024&#34;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    # Verification de type et contenu.
    assert isinstance(ignore_missing, bool), \
        f&#34;&#39;ignore_missing&#39; has to be a boolean, not a {type(ignore_missing).__name__}.&#34;
    if &#34;config_file&#34; in detector_parameters:
        assert isinstance(detector_parameters[&#34;config_file&#34;], str), (&#34;&#39;file&#39; doit etre un chemin de &#34;
            f&#34;fichier de type str, pas {type(detector_parameters[&#39;config_file&#39;]).__name__}.&#34;)
        assert os.path.isfile(detector_parameters[&#34;config_file&#34;]), \
            f&#34;{repr(detector_parameters[&#39;config_file&#39;])} n&#39;est pas un fichier qui existe.&#34;
    for dist in (&#34;dd&#34;, &#34;detect&#34;, &#34;distance&#34;):
        if dist in detector_parameters:
            assert isinstance(detector_parameters[dist], numbers.Number), \
                f&#34;&#39;{dist}&#39; doit etre un nombre, pas un {type(detector_parameters[dist]).__name__}.&#34;
            assert detector_parameters[dist] &gt; 0, \
                f&#34;Toute distance doit etre positive, or elle vaut {detector_parameters[dist]}.&#34;
    for pos in (&#34;xcen&#34;, &#34;x0&#34;, &#34;ycen&#34;, &#34;y0&#34;):
        if pos in detector_parameters:
            assert isinstance(detector_parameters[pos], numbers.Number), \
                f&#34;&#39;{pos}&#39; doit etre un nombre, pas un {type(detector_parameters[pos]).__name__}.&#34;
    for angle in (&#34;xbet&#34;, &#34;bet&#34;, &#34;beta&#34;, &#34;angle1&#34;, &#34;xgam&#34;, &#34;gam&#34;, &#34;gamma&#34;, &#34;angle2&#34;):
        if angle in detector_parameters:
            assert isinstance(detector_parameters[angle], float), \
                f&#34;&#39;{angle}&#39; doit etre un flottant, pas un {type(detector_parameters[angle]).__name__}.&#34;
            assert -4.84 &lt; detector_parameters[angle] &lt; 4.84, (&#34;L&#39;angle de correction doit etre petit car &#34;
                &#34;un developement limite permet d&#39;accelerer les calculs. Seulement on autorise une erreur &#34;
                f&#34;de 1e-4 qui correpond a 4.84 degres, pas {detector_parameters[angle]}.&#34;)
    for size in (&#34;pixelsize&#34;, &#34;size&#34;, &#34;pxlsize&#34;):
        if size in detector_parameters:
            assert isinstance(detector_parameters[size], float), \
                f&#34;&#39;{size}&#39; doit etre un flottant, pas un {type(detector_parameters[size]).__name__}.&#34;
            assert detector_parameters[size] &gt; 0, \
                f&#34;La taille d&#39;un pixel doit etre positive, or elle vaut {detector_parameters[size]}.&#34;

    parameters = {} # C&#39;est le dictionaire des parametres extraits.

    # Extraction des informations du fichier.
    if &#34;config_file&#34; in detector_parameters:
        f_mod = re.compile(r&#34;&#34;&#34;(?:[+-]*
                (?:
                  \. [0-9]+ (?:_[0-9]+)*
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)* \. (?: [0-9]+ (?:_[0-9]+)* )?
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)*
                  e [+-]? [0-9]+ (?:_[0-9]+)*
                ))&#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE) # Model d&#39;un flottant.
        i_mod = re.compile(r&#34;&#34;&#34;(?:[+-]*
                    # entier normal
                    [0-9]+ (?:_[0-9]+)*
                | 0 (?:
                    # binary
                    b [01]+ (?:_[01]+)*
                  | # octal
                    o [0-7]+ (?:_[0-7]+)*
                  | # hexadecimal
                    x [0-9a-f]+ (?:_[0-9a-f]+)*
                )
                )&#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE) # Model d&#39;un entier.
        complete_model = re.compile(r&#34;&#34;&#34;^[\[\(]?\s*?(?:
                    (?P&lt;dd&gt;{f_mod}) [\s,]+
                    (?P&lt;xcen&gt;{f_mod}) [\s,]+
                    (?P&lt;ycen&gt;{f_mod}) [\s,]+
                    (?P&lt;xbet&gt;{f_mod}) [\s,]+
                    (?P&lt;xgam&gt;{f_mod})
                    (?: [\s,]+ (?P&lt;pixelsize&gt;{f_mod}))?
                )
                &#34;&#34;&#34;.format(f_mod=f_mod.pattern, i_mod=i_mod.pattern), re.VERBOSE | re.IGNORECASE)
        dd_model = re.compile(rf&#34;(?:dd|detect|distance)[\s:=]+(?P&lt;dd&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        xcen_model = re.compile(rf&#34;(?:xcen|x0)[\s:=]+(?P&lt;xcen&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        ycen_model = re.compile(rf&#34;(?:ycen|y0)[\s:=]+(?P&lt;ycen&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        xbet_model = re.compile(rf&#34;(?:xbet|bet|beta|angle1)[\s:=]+(?P&lt;xbet&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        xgam_model = re.compile(rf&#34;(?:xgam|gam|gamma|angle2)[\s:=]+(?P&lt;xgam&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        pixelsize_model = re.compile(rf&#34;(?:size|pixelsize|pxlsize)[\s:=]+(?P&lt;pixelsize&gt;{f_mod.pattern})&#34;,
            re.VERBOSE | re.IGNORECASE)
        keys = {&#34;dd&#34;: dd_model, &#34;xcen&#34;: xcen_model, &#34;ycen&#34;: ycen_model,
                &#34;xbet&#34;: xbet_model, &#34;xgam&#34;: xgam_model}

        with open(detector_parameters[&#34;config_file&#34;], &#34;r&#34;, encoding=&#34;utf-8&#34;, errors=&#34;ignore&#34;) as file:
            for line in file: # Pour chaque ligne du fichier, on tente d&#39;y recuperer les infos.

                # Recherche de la liste des parametres.
                complete_search = re.search(complete_model, line)
                if complete_search is not None:
                    for key in keys:
                        value = float(complete_search[key])
                        if parameters.get(key, value) != value:
                            raise ValueError(f&#34;&#39;{key}&#39; value is ambigous. Is it {parameters[key]} or {value}?&#34;)
                        parameters[key] = value
                    if complete_search[&#34;pixelsize&#34;] is not None:
                        pixelsize = float(complete_search[&#34;pixelsize&#34;])
                        if parameters.get(&#34;pixelsize&#34;, pixelsize) != pixelsize:
                            raise ValueError(&#34;&#39;pixelsize&#39; value is ambigous. &#34;
                                f&#34;Is it {parameters[&#39;pixelsize&#39;]} or {pixelsize}?&#34;)
                        parameters[&#34;pixelsize&#34;] = pixelsize

                # Recherches des parametres isoles.
                for key, model in {**keys, &#34;pixelsize&#34;: pixelsize_model}.items():
                    search = re.search(model, line)
                    if search is not None:
                        value = float(search[key])
                        if parameters.get(key, value) != value:
                            raise ValueError(f&#34;&#39;{key}&#39; value is ambigous. Is it {parameters[key]} or {value}?&#34;)
                        parameters[key] = value

    # 3 Extraction des informations expicites.
    for keys in [(&#34;dd&#34;, &#34;detect&#34;, &#34;distance&#34;),
                 (&#34;xcen&#34;, &#34;x0&#34;),
                 (&#34;ycen&#34;, &#34;y0&#34;),
                 (&#34;xbet&#34;, &#34;bet&#34;, &#34;beta&#34;, &#34;angle1&#34;),
                 (&#34;xgam&#34;, &#34;gam&#34;, &#34;gamma&#34;, &#34;angle2&#34;),
                 (&#34;pixelsize&#34;, &#34;size&#34;, &#34;pxlsize&#34;)]:
        for key in keys:
            if key in detector_parameters:
                value = detector_parameters[key]
                if parameters.get(keys[0], value) != value:
                    raise ValueError(f&#34;&#39;{keys[0]}&#39; value is ambigous. Is it {parameters[keys[0]]} or {value}?&#34;)
                parameters[keys[0]] = value

    # Ajout des valeurs manquantes.
    if not ignore_missing:
        keys = {&#34;dd&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;pixelsize&#34;}
        missing_keys = keys - set(parameters)
        if missing_keys:
            raise KeyError(f&#34;Il manque les parametres {&#39;, &#39;.join(missing_keys)}.&#34;)

    return parameters</code></pre>
</details>
</dd>
<dt id="laue.gnomonic_to_cam"><code class="name flex">
<span>def <span class="ident">gnomonic_to_cam</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.gnomonic_to_cam" href="core/geometry/index.html#laue.core.geometry.gnomonic_to_cam">gnomonic_to_cam()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gnomonic_to_cam(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.gnomonic_to_cam``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;gnomonic_to_cam&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.gnomonic_to_thetachi"><code class="name flex">
<span>def <span class="ident">gnomonic_to_thetachi</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.gnomonic_to_thetachi" href="core/geometry/index.html#laue.core.geometry.gnomonic_to_thetachi">gnomonic_to_thetachi()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gnomonic_to_thetachi(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.gnomonic_to_thetachi``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;gnomonic_to_thetachi&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.hough"><code class="name flex">
<span>def <span class="ident">hough</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.hough" href="core/geometry/index.html#laue.core.geometry.hough">hough()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hough(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.hough``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;hough&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.hough_reduce"><code class="name flex">
<span>def <span class="ident">hough_reduce</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.hough_reduce" href="core/geometry/index.html#laue.core.geometry.hough_reduce">hough_reduce()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hough_reduce(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.hough_reduce``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;hough_reduce&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.images_to_iter"><code class="name flex">
<span>def <span class="ident">images_to_iter</span></span>(<span>images)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.image.images_to_iter" href="utilities/image.html#laue.utilities.image.images_to_iter">images_to_iter()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def images_to_iter(images):
    &#34;&#34;&#34;
    ** Converti les images en un generateur d&#39;images. **

    Parameters
    ----------
    images
        Ce qui representes les images. Que ce soit le nom
        d&#39;un dossier, d&#39;une image elle meme, une glob expression,
        une liste d&#39;image ou bien un generateur.
    &#34;&#34;&#34;
    if isinstance(images, str): # Dans le cas ou une chaine de caractere
        if os.path.isdir(images): # decrit l&#39;ensemble des images.
            images = sorted(
                os.path.join(father, file)
                for father, _, files in os.walk(images)
                for file in files)
        else:
            from glob import iglob
            images = sorted(iglob(images, recursive=True))
    elif isinstance(images, (tuple, set)):
        images = list(images)

    assert hasattr(images, &#34;__iter__&#34;), (&#34;&#39;images&#39; must to be iterable. &#34;
        f&#34;It can not be of type {type(images).__name__}.&#34;)

    return images</code></pre>
</details>
</dd>
<dt id="laue.ind2comb"><code class="name flex">
<span>def <span class="ident">ind2comb</span></span>(<span>comb, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.transformer.ind2comb" href="core/geometry/transformer.html#laue.core.geometry.transformer.ind2comb">ind2comb()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ind2comb(comb, n):
    &#34;&#34;&#34;
    ** Eclate un rang en 2 indices **

    Notes
    -----
    * Bijection de ``comb2ind``.
    * Peut etre utile pour les methodes ``laue.core.geometry.transformer.Transformer.hough``
    et ``laue.core.geometry.transformer.Transformer.inter_lines``.
    * Risque de donner de faux resultats pour n trop grand.

    Parameters
    ----------
    comb : int ou np.ndarray(dtype=int)
        L&#39;indice, ie le (comb)ieme mot constitue 2 de symbols
        ajence comme decrit dans ``comb2ind``.
    n : int
        Le nombre de symboles.

    Returns
    -------
    int ou np.ndarray(dtype=int)
        Le premier des 2 indicices (``ind1``).
    int ou np.ndarray(dtype=int)
        Le second des 2 indicices (``ind2``). De sorte que ``comb2ind(ind1, ind2) == comb``.

    Examples
    --------
    &gt;&gt;&gt; from laue.core.geometry.transformer import ind2comb
    &gt;&gt;&gt; ind2comb(0, n=6)
    (0, 1)
    &gt;&gt;&gt; ind2comb(1, n=6)
    (0, 2)
    &gt;&gt;&gt; ind2comb(4, n=6)
    (0, 5)
    &gt;&gt;&gt; ind2comb(5, n=6)
    (1, 2)
    &gt;&gt;&gt; ind2comb(14, n=6)
    (4, 5)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(comb, (int, np.ndarray)), \
        f&#34;&#39;comb&#39; can not being of type {type(comb).__name__}.&#34;
    assert isinstance(n, int), f&#34;&#39;n&#39; has to ba an integer, not a {type(n).__name__}.&#34;
    if isinstance(comb, np.ndarray):
        assert comb.dtype == int or issubclass(comb.dtype.type, np.integer), f&#34;&#39;comb&#39; must be integer, not {str(comb.dtype)}.&#34;
        assert (comb &gt;= 0).all(), &#34;Tous les indices doivent etres positifs.&#34;
        assert (comb &lt; n*(n-1)/2).all(), (f&#34;Dans un alphabet a {n} symboles, il ne peut y a voir &#34;
            f&#34;que {n*(n-1)/2} mots. Le mot d&#39;indice {comb.max()} n&#39;existe donc pas!&#34;)
    else:
        assert comb &gt;= 0, &#34;Les indices doivent etre positifs.&#34;
        assert comb &lt; n*(n-1)/2, (f&#34;Dans un alphabet a {n} symboles, il ne peut y a voir &#34;
            f&#34;que {n*(n-1)/2} mots. Le mot d&#39;indice {comb} n&#39;existe donc pas!&#34;)

    homogeneous_int = lambda x: x.astype(int) if isinstance(x, np.ndarray) else int(x)
    ind1 = homogeneous_int(np.ceil(n - np.sqrt(-8*comb + 4*n**2 - 4*n - 7)/2 - 3/2))
    ind2 = comb + (ind1**2 + 3*ind1)//2 - ind1*n + 1
    return ind1, ind2</code></pre>
</details>
</dd>
<dt id="laue.inter_lines"><code class="name flex">
<span>def <span class="ident">inter_lines</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.inter_lines" href="core/geometry/index.html#laue.core.geometry.inter_lines">inter_lines()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inter_lines(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.inter_lines``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;inter_lines&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.limited_imap"><code class="name flex">
<span>def <span class="ident">limited_imap</span></span>(<span>pool, func, iterable, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.limited_imap" href="utilities/multi_core.html#laue.utilities.multi_core.limited_imap">limited_imap()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limited_imap(pool, func, iterable, **kwargs):
    &#34;&#34;&#34;
    ** Same as ``Pool.imap`` with limited buffer. **

    La fonction ``Pool.imap`` du module multiprocessing epuise
    tant qu&#39;elle peut l&#39;iterable d&#39;entree, et accumule les resultat
    dans une memoir tampon. Seulement, elle ne se preocupe
    pas de la memoire disponible ni des autres processus.
    Ici, les calcul sont fait en economisant les ressources
    disponible de facon a accroitre les peformances.

    Parameters
    ----------
    pool : multiprocessing.pool.Pool
        Pool de ``multiprocessing.Pool()``.
    func : callable
        La fonction serialisable avec pickle qui sera evaluee.
    iterable : iterable
        Cede sucessivement les argument a fournir a ``func``.
    **kwargs
        See ``multiprocessing.Pool().imap``.

    Yields
    ------
    result
        Cede peu a peu les resultats de la fonction ``func``.
    &#34;&#34;&#34;
    class Regulator:
        &#34;&#34;&#34;
        Permet de reguler le flot d&#39;un bloc.
        &#34;&#34;&#34;
        def __init__(self, pool, iterable):
            self.pool = pool
            self.iterable = iterable
            self.nbr_yields = 0 # Le nombre de resultats cedes.
            self.nbr_args = 0 # Le nombre d&#39;arguments pompes.
            self.max_tasks = 2*os.cpu_count() # Nombre de taches maximales en cours de calcul.

        def __iter__(self):
            &#34;&#34;&#34;
            Cede les arguments au compte gouttes.
            &#34;&#34;&#34;
            for args in self.iterable:
                while True: # Permet d&#39;attendre en cas de besoin.
                    buff_size = self.nbr_args - self.nbr_yields
                    if buff_size &lt; self.max_tasks:
                        break
                    if buff_size &gt; 10*self.max_tasks: # Si il y a suffisement de resultats en avance.
                        time.sleep(.1) # On fait une grande pause.
                        continue # Et on attend que ca se decante.
                    cpu = min(psutil.cpu_percent(interval=0.05, percpu=True))
                    mem = psutil.virtual_memory().percent
                    if cpu &lt; 50 and mem &lt; 75: # Si il y a suffisement de ressources.
                        break

                self.nbr_args += 1
                yield args

        def imap(self, func, **kwargs):
            &#34;&#34;&#34;
            Cede les resultats.
            &#34;&#34;&#34;
            for res in self.pool.imap(func, self, **kwargs):
                self.nbr_yields += 1
                yield res
    
    try:
        import psutil
    except ImportError:
        import logging
        logging.warn(&#34;&#39;psutil&#39; n&#39;est installer, il est impossible de &#34;
            &#34;gerer poprement les ressources.&#34;)
        psutil = None
    
    if psutil is None:
        yield from pool.imap(func, iterable, **kwargs)
    else:
        regulator = Regulator(pool, iterable)
        yield from regulator.imap(func, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.pickleable_method"><code class="name flex">
<span>def <span class="ident">pickleable_method</span></span>(<span>args, serialize=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.pickleable_method" href="utilities/multi_core.html#laue.utilities.multi_core.pickleable_method">pickleable_method()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pickleable_method(args, serialize=False):
    &#34;&#34;&#34;
    ** Permet de serialiser une methode. **

    Notes
    -----
    Comme l&#39;utilisateur ne doit pas utiliser cette fonction, il n&#39;y
    a pas de verifications sur les entree de facon a privilegier la performance.

    Parameters
    ----------
    args : tuple
        * args[0] =&gt; func, La fonction a executer. Si c&#39;est une methode, il est
        possible de fournir ``ClasseName.methode`` au lieu de ``self.methode``.
        * args[1] =&gt; self, Serialiser ou non, c&#39;est le premiers argument.
        * args[2] (facultativ) =&gt; kwargs, Le dictionaire des parametres nomes.
    serialize : bool
        Serialize le resultat (si True), sinon laisse implicitement
        pickle le faire (False). Si pickle est capable de le faire, il
        faut lui laisser gerer ca car c&#39;est plus efficace.
    &#34;&#34;&#34;
    if len(args) == 2:
        (func, self), kwargs = args, {}
    else:
        func, self, kwargs = args
    if isinstance(self, bytes):
        self = cloudpickle.loads(self)
    return (
                (lambda x: cloudpickle.dumps(x))
                if serialize else
                (lambda x: x)
            )(func(self, **kwargs))</code></pre>
</details>
</dd>
<dt id="laue.prevent_generator_size"><code class="name flex">
<span>def <span class="ident">prevent_generator_size</span></span>(<span>min_size=1, max_size=inf)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.prevent_generator_size" href="utilities/multi_core.html#laue.utilities.multi_core.prevent_generator_size">prevent_generator_size()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prevent_generator_size(min_size=1, max_size=math.inf):
    &#34;&#34;&#34;
    ** Controle que le generateur contient le bon nombre d&#39;elements. **

    C&#39;est un decorateur qui decore une fonction (generateur).

    Parameters
    ----------
    min_size : int
        Le nombre minimum d&#39;elements que doit ceder le generateur avant qu&#39;il ne soit epuise.
    max_size : int
        Le nombre maximum d&#39;elements cedes avant de lever l&#39;exception.

    Raises
    ------
    GeneratorExit
        Si les conditions ne sont pas respectees.
    &#34;&#34;&#34;
    assert isinstance(min_size, int), f&#34;&#39;min_size&#39; has to be int, not {type(min_size).__name__}.&#34;
    assert isinstance(max_size, int) or max_size == math.inf, \
        f&#34;&#39;max_size&#39; has to be int, not {type(max_size).__name__}.&#34;
    assert max_size &gt;= min_size, (&#34;&#39;max_size&#39; doit etre plus grand ou egal a &#39;min_size&#39;. &#34;
        f&#34;Or ils valent respectivement {max_size} et {min_size}.&#34;)
    assert min_size &gt;= 0, f&#34;&#39;min_size&#39; ne doit pas etre negatif ({min_size}).&#34;

    def decorator(func):
        def generator(*args, **kwargs):
            i = -1
            for i, element in enumerate(func(*args, **kwargs)):
                yield element
                if i &gt;= max_size:
                    raise GeneratorExit(f&#34;Le generateur {func} ne doit pas ceder plus de &#34;
                        f&#34;{max_size} elements. Or il tente d&#39;en ceder un {i+1}eme.&#34;)
            if i+1 &lt; min_size:
                raise GeneratorExit(f&#34;Le generateur {func} doit ceder au moins {min_size} &#34;
                    f&#34;elements. Or il n&#39;en a cede que {i+1}.&#34;)

        return generator
    return decorator</code></pre>
</details>
</dd>
<dt id="laue.read_image"><code class="name flex">
<span>def <span class="ident">read_image</span></span>(<span>image_path, *, ignore_errors=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.image.read_image" href="utilities/image.html#laue.utilities.image.read_image">read_image()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_image(image_path, *, ignore_errors=False):
    &#34;&#34;&#34;
    ** Lit une image sur le disque dur. **

    Parameters
    ----------
    image_path : str
        Nom de l&#39;image, chemin absolu ou relatif, peu importe.
    ignore_errors : boolean
        Same as ``laue.experiment.base_experiment.Experiment.__init__``.
        Permet de renvoyer ``None`` plutot que de lever une exeption.

    Returns
    -------
    np.ndarray
        L&#39;image en niveau de gris encodee en uint16.

    Raises
    ------
    FileNotFoundError
        Si l&#39;image n&#39;existe pas.
    ImportError
        Si il manque un module pour lire l&#39;image.
    ValueError
        Si le fichier n&#39;est pas lisible.

    Example
    -------
    &gt;&gt;&gt; from laue.utilities.image import read_image
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; read_image(image)
    array([[0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           ...,
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0]], dtype=uint16)
    &gt;&gt;&gt; read_image(image).shape
    (2048, 2048)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    assert isinstance(image_path, (str, bytes)), \
        f&#34;&#39;image_path&#39; has to be str or byte-like object. Not {type(image_path).__name__}.&#34;

    if not os.path.exists(image_path):
        message = f&#34;{repr(image_path)} n&#39;est pas un chemin existant.&#34;
        if not ignore_errors:
            raise FileNotFoundError(message)
        logging.warning(message)
        return None
    if not os.path.isfile(image_path):
        message = f&#34;{repr(image_path)} n&#39;est pas un fichier.&#34;
        if not ignore_errors:
            raise FileNotFoundError(message)
        logging.warning(message)
        return None
    image = cv2.imread(image_path, cv2.IMREAD_ANYDEPTH | cv2.IMREAD_GRAYSCALE)
    if image is None:
        try:
            import fabio # Pour lire les fichier .mccd
        except ImportError as err:
            raise ImportError(&#34;Pour lire les fichier &#39;.mccd&#39; ou &#39;.gz&#39;, &#34;
                &#34;il faut installer le module &#39;fabio&#39;.&#34;) from err
        try:
            image = fabio.open(image_path).data
        except (KeyError, OSError) as err:
            message = f&#34;Echec de lecture du fichier {repr(image_path)} comme une image.&#34;
            if not ignore_errors:
                raise ValueError(message) from err
            logging.warning(message)
            return None
    image = image.astype(np.uint16)
    return image</code></pre>
</details>
</dd>
<dt id="laue.reduce_object"><code class="name flex">
<span>def <span class="ident">reduce_object</span></span>(<span>obj, attrs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.reduce_object" href="utilities/multi_core.html#laue.utilities.multi_core.reduce_object">reduce_object()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_object(obj, attrs=None):
    &#34;&#34;&#34;
    ** Reconstitue un objet partiel. **

    Le but est de rendre un objet plus facilement serialisable et
    aussi de l&#39;alleger pour perdre moins de temps avec la
    serialisation puis la deserialisation.

    Parameters
    ----------
    obj : objet
        Instance de la classe que l&#39;on shouaite reduire.
    attrs : iterable
        Les noms des attributs qui resteront presents dans l&#39;objet final.
        Si il ne sont pas precise, seul les attributs serialisables sont gardes.

    Examples
    --------
    &gt;&gt;&gt; from laue.utilities.multi_core import reduce_object
    &gt;&gt;&gt;
    &gt;&gt;&gt; class Foo:
    ...     def __init__(self):
    ...         self.attr1 = 1
    ...         self.attr2 = 2
    ...     def meth(self):
    ...         pass
    ...
    &gt;&gt;&gt; obj = Foo()
    &gt;&gt;&gt;
    &gt;&gt;&gt; little_obj = reduce_object(obj, [&#34;attr1&#34;])
    &gt;&gt;&gt; hasattr(little_obj, &#34;attr1&#34;)
    True
    &gt;&gt;&gt; hasattr(little_obj, &#34;attr2&#34;)
    False
    &gt;&gt;&gt; hasattr(little_obj, &#34;meth&#34;)
    True
    &gt;&gt;&gt; little_obj.attr1
    1
    &gt;&gt;&gt; type(little_obj.meth)
    &lt;class &#39;method&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    class Partial(type(obj)):
        def __init__(self):
            pass

    if attrs is None:
        all_attrs = [attr for attr in dir(obj)
            if type(getattr(obj, attr)).__name__ != &#34;method&#34;
            and not attr.startswith(&#34;__&#34;)]
        attrs = []
        for attr in all_attrs:
            try:
                cloudpickle.dumps(getattr(obj, attr))
            except (TypeError, RuntimeError):
                continue
            else:
                attrs.append(attr)
        print(attrs)

    partial_obj = Partial()
    for attr in attrs:
        setattr(partial_obj, attr, getattr(obj, attr))
    return partial_obj

    # class Constructor:
    #     &#34;&#34;&#34;
    #     Methaclasse qui fabrique de nouvelle instances sur mesure.
    #     &#34;&#34;&#34;
    #     def __new__(cls, obj, attrs):
    #         name = f&#34;Partial{type(obj).__name__}&#34;
            
    #         # Separation des attributs et des methodes.
    #         meth_name = {attr for attr in attrs if type(getattr(obj, attr)).__name__ == &#34;method&#34;}
    #         attrs = set(attrs) - meth_name
            
    #         # Creation d&#39;un objet ayant que les methodes.
    #         empty_obj = NoAttrs()
    #         # for attr in attrs:
    #         #     setattr(emty_obj, attr, getattr(obj, attr))
    #         methodes = {name: getattr(empty_obj, name) for name in meth_name}

    #         # Ajout des attributs.
    #         partial_obj = type(name, (), methodes)
    #         for attr in attrs:
    #             setattr(partial_obj, attr, getattr(obj, attr))
    #         return partial_obj

    # return Constructor(obj, attrs)</code></pre>
</details>
</dd>
<dt id="laue.thetachi_to_cam"><code class="name flex">
<span>def <span class="ident">thetachi_to_cam</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.thetachi_to_cam" href="core/geometry/index.html#laue.core.geometry.thetachi_to_cam">thetachi_to_cam()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thetachi_to_cam(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.thetachi_to_cam``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;thetachi_to_cam&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="laue.thetachi_to_gnomonic"><code class="name flex">
<span>def <span class="ident">thetachi_to_gnomonic</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.thetachi_to_gnomonic" href="core/geometry/index.html#laue.core.geometry.thetachi_to_gnomonic">thetachi_to_gnomonic()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thetachi_to_gnomonic(*args, **kwargs):
    &#34;&#34;&#34; Accesseur vers la methode
    ``laue.core.geometry.transformer.Transformer.thetachi_to_gnomonic``
    d&#39;une instance globale de
    ``laue.core.geometry.transformer.Transformer``.&#34;&#34;&#34;
    return _global_transformer(&#34;thetachi_to_gnomonic&#34;, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laue.Experiment"><code class="flex name class">
<span>class <span class="ident">Experiment</span></span>
<span>(</span><span>images=(), *, config_file=None, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.experiment.base_experiment.Experiment" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment">Experiment</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Experiment(ExperimentPickleable, Recordable):
    &#34;&#34;&#34;
    ** Permet de travailler sur un lot d&#39;images. **
    &#34;&#34;&#34;
    def __init__(self, images=(), *, config_file=None, verbose=False, **kwargs):
        &#34;&#34;&#34;
        Parameters
        ----------
        images : str, iterable
            - Toutes les images qui constituent l&#39;experience.
            - Peut prendre plein de forme differentes:
                - Iterable d&#39;images. Chaque elements peut prendre 2 formes:
                    - Le chemin de l&#39;image (str) absolu ou relatif.
                    - L&#39;image elle meme, matrice 2d en uint16 (np.ndarray).
                        - Il vaut mieux donner le nom de l&#39;image que l&#39;image elle-meme
                        car la gestion de la RAM sera meilleur, surtout si il y a
                        un nombre important d&#39;images ce qui saturerait la memoire.
                - Repertoire. Nom du dossier qui contient recursivement les images.
                - Glob expression. Par example &#34;mon_dossier/*.tiff&#34;.
        verbose : int, optional
            * Permet d&#39;afficher ou non des informations suplementaires.
                - 0 or False =&gt; N&#39;affiche rien du tout, ne pollue pas l&#39;ecran.
                - 1 or True =&gt; Affiche seulement les etapes principales.
                - 2 =&gt; Affiche les resultats intermediaires.
                - 3 =&gt; Affiche vraiment beaucoup de choses (pas tres lisible).
                - 4 =&gt; Affiche aussi des choses graphiques en plus de
                    tous ce qui est dans le terminal.

        max_space : int, optional
            Le nombre minimum de pixels qui separent 2 taches.
            Quand des taches ne sont pas separes par cet intevalle,
            elles se retrouvent aglomerees. La valeur par defaut de 5
            permet d&#39;avoir une recherche tres hexaustive.
        threshold : float, optional
            - Seuil relatif par raport a l&#39;ecart type de l&#39;image sans fond.
            - Plus la valeur est grande, moins on capture de spots:
                - 3.5 =&gt; Prend enormement de spots, beaucoup de fausses detection.
                - 5.1 =&gt; Bon compromis, reste sensible sans trop capturer le fond.
                - 10 =&gt; Asser selectif, ne prend que les taches qui ressortent beaucoup.
        font_size : int, optional
            Diametre de l&#39;element structurant qui permet d&#39;evaluer le fond par
            une ouverture morphologique. La valeur par defaut est 21,
            normalement cette valeur est bien, il faut pas y toucher.
        ignore_errors : boolean, optional
            Permet d&#39;ignorer certaine erreurs qui ne sont pas critiques.
            La valeur par defaut et True.
        config_file : str, optional
            Alias vers ``**detector_parameters``.
        **detector_parameters : number
            Les parametres de set_calibration de la camera deja connus.
            Il servent dans la methode ``laue.experiment.base_experiment.Experiment.set_calibration``
            a accelerer la recherche ou a la rendre plus precise.
            Pour avoir le detail sur ces parametres, voir
            ``laue.utilities.parsing.extract_parameters``.
        **bbox : number
            Ce sont les limites min et max des parametres de set_calibration a ne pas depasser.
            Les bornes minimum doivent etre precedes de &#39;_min&#39; et les maximum de &#39;_max&#39;.
            Vous pouvez par example donner ``Experiment(dd_min=90.0, dd_max=100.0)``.
            Il sont utilises dans la methode ``laue.experiment.base_experiment.Experiment.set_calibration``.
            Les noms possibles des parametres sont les meme que ``**detector_parameters``
            a l&#39;exeption de ``pixelsize, size, pxlsize et config_file`` qui n&#39;admettent
            pas de bornes.
            Les valeur par defaut sont:

                dd   : 60.0 mm          ; 80.0 mm
                xbet : -0.9 degre       ; 0.9 degre
                xgam : -0.9 degre       ; 0.9 degre
                xcen : milieu - 150 pxl ; milieu + 150 pxl
                ycen : milieu - 150 pxl ; milieu + 150 pxl
        **save_params
            Les parametres fournis a l&#39;initialisateur de gestionaire d&#39;enregistrement.
            voir ``laue.utilities.data_consistency.Recordable.__init__``.
        &#34;&#34;&#34;
        assert isinstance(verbose, int), f&#34;&#39;verbose&#39; has to be int, not {type(verbose).__name__}.&#34;
        
        max_space = kwargs.get(&#34;max_space&#34;, 5)
        assert isinstance(max_space, int), &#34;&#39;max_space&#39; has to be an integer, not a %s.&#34; \
            % type(max_space).__name__
        assert max_space &gt;= 1, f&#34;&#39;max_space&#39; has to be positive. His value is &#39;{max_space}&#39;.&#34;
        threshold = kwargs.get(&#34;threshold&#34;, 5.1)
        assert isinstance(threshold, float), \
            f&#34;&#39;threshold&#39; has to be float, not a {type(threshold).__name__}.&#34;
        assert 2.0 &lt; threshold &lt; 80.0, \
            f&#34;Le seuil doit etre compris entre 2 et 50, il vaut &#39;{threshold}&#39;.&#34;
        font_size = kwargs.get(&#34;font_size&#34;, 21)
        assert isinstance(font_size, int), \
            f&#34;&#39;font_size&#39; has to be an integer, not a {type(font_size).__name__}.&#34;
        assert font_size &gt;= 2, (&#34;&#39;font_size&#39; doit etre superieur a 1. &#34;
            f&#34;Il ne peut pas valoir {font_size}.&#34;)
        ignore_errors = kwargs.get(&#34;ignore_errors&#34;, True)
        assert isinstance(ignore_errors, bool), \
            f&#34;&#39;ignore_errors&#39; has to be a boolean, not a {type(ignore_errors).__name__}.&#34;

        if config_file is not None:
            kwargs[&#34;config_file&#34;] = config_file

        from laue.utilities.image import images_to_iter
        self._images = images_to_iter(images)

        self.verbose = verbose
        self.max_space = max_space
        self.threshold = threshold
        self.font_size = font_size
        self.ignore_errors = ignore_errors
        self.kwargs = kwargs

        # Precalul des constantes.
        self.kernel_font = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (self.font_size, self.font_size))
        self.kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (self.max_space, self.max_space))
        self.transformer = transformer.Transformer(verbose=self.verbose) # Outil permetant de faire les transformations geometriques.
        self._predictors = {} # Predicteurs bases sur un reseau de neurones.

        # Declaration des attributs interne de memoire.
        self._len = None # Nombre de diagrames lues.
        self._buff_images = [] # La liste ordonnees des references d&#39;images.
        self._buff_diags = [] # La liste ordonnee des diagrames lus.

        self._mean_bg = None # Fond diffus estime par la moyenne de toutes les images.
        self._shape = None # Les dimensions des matrices des images xy.
        self._calibration_parameters = None # Le dictionaire des parametres geometrique de la camera.
        self._gnomonic_matrix = None # Les matrices de transformation.

        self._images_iterator = None # Iterateur unique des informations des images.
        self._diagrams_iterator = None # Iterateur unique qui genere les diagrammes.
        self._axes_iterator = None # Iterateur unique qui cede les axes de zonne de chaque diagramme.
        self._subsets_iterator = None # Iterateur unique qui cede les bouts de grains.

        Recordable.__init__(self, **kwargs) # Instancie le gestionaire d&#39;enregistrement.

    def set_calibration(self, *diagrams):
        &#34;&#34;&#34;
        ** Calibration de la camera. **

        Notes
        -----
        * Ne nessecite aucune connaissances prealable sur le christal.
        * Il n&#39;y a pas besoin d&#39;avoir un diagramme bien calibre, il se debrouille tout seul.
        * Cette fonction peut parfois etre lente (plusieur minutes)!
        * Si vous connaissez les parametres, fournissez-les, ca ira plus vite!
        * Si cette methode a deja ete appelee une fois, elle retourne
            immeditement le resultat sans refaire les calculs.

        Parameters
        ----------
        *diagrams : optional
            Les ou le diagramme.s qui vont servir a faire la calibration.
            Si aucun diagramme n&#39;est precise, cette methode recherche par elle meme
            les diagrammes qu&#39;elle trouve convaincant parmis ceux qui sont disponibles.
            Il doivent etre de type ``laue.diagram.LaueDiagram``.

        Returns
        -------
        dict 
            Le dictionaire qui a chaque non de parametre, associe sa valeur numerique.
            Les clefs sont les suivantes: &#34;dd&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;xbet&#34;, &#34;xgam&#34; and &#34;pixelsize&#34;

        Raises
        ------
        KeyError
            Si l&#39;utilisateur n&#39;a pas precise les parametres vraiment indispenssables.
        ValueError
            Si il y a des incoherences dans les parametres.

        Example
        -------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; experiment = laue.experiment.base_experiment.Experiment(image, dd_min=69.5, dd_max=71.5, xbet=0.008)
        &gt;&gt;&gt; parameters = experiment.set_calibration()
        &gt;&gt;&gt; sorted(parameters.keys())
        [&#39;dd&#39;, &#39;pixelsize&#39;, &#39;xbet&#39;, &#39;xcen&#39;, &#39;xgam&#39;, &#39;ycen&#39;]
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self._calibration_parameters is not None: # Si on peut retourner directement,
            return self._calibration_parameters # on ne s&#39;en prive pas.

        assert all(isinstance(diag, LaueDiagram) for diag in diagrams), \
            &#34;Tous les diagrammes doivent etre de type &#39;LaueDiagram&#39;. Or ce n&#39;est pas le cas.&#34;

        if self.verbose:
            print(&#34;Calibration...&#34;)
            if self.verbose &gt;= 2:
                print(&#34;    Prise en compte des parametres fournis...&#34;)

        # Constantes.
        PIXELSIZE_REF = {(2048, 2048): 0.079856, # Taille des pixels fonction de la camera.
                         (2018, 2016): 0.0734,
                         (2594, 2748): 0.031}
        PARAM_SET = {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;} # Les parametres non deductibles.
        PARAM_MIN = {&#34;dd&#34;: 60.0, # Les bornes minimale par defaut.
                     &#34;xbet&#34;: -.9,
                     &#34;xgam&#34;: -.9,
                     &#34;xcen&#34;: self.get_images_shape()[0]/2 - 150,
                     &#34;ycen&#34;: self.get_images_shape()[0]/2 - 150}
        PARAM_MAX = {&#34;dd&#34;: 80.0, # Les bornes maximales par defaut.
                     &#34;xbet&#34;: .9,
                     &#34;xgam&#34;: .9,
                     &#34;xcen&#34;: self.get_images_shape()[0]/2 + 150,
                     &#34;ycen&#34;: self.get_images_shape()[1]/2 + 150}

        # Recuperation des parametres fournis et deductibles.
        from laue.utilities.parsing import extract_parameters
        given_parameters = extract_parameters(ignore_missing=True, **self.kwargs)
        if (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() in PIXELSIZE_REF):
            given_parameters[&#34;pixelsize&#34;] = PIXELSIZE_REF[self.get_images_shape()]
        
        elif (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() not in PIXELSIZE_REF):
            raise KeyError(&#34;Vous devez fournir le parametre &#39;pixelsize&#39;.\n&#34;
                f&#34;Les images font {self.get_images_shape()} pxl**2. &#34;
                f&#34;Or, seul les &#39;pixelsize&#39; des images {&#39; et &#39;.join(map(str, PIXELSIZE_REF))} sont connus.&#34;)

        # Recuperation des bornes.
        given_min = extract_parameters(ignore_missing=True, **{
            param[:-4]: value
            for param, value in self.kwargs.items()
            if param.endswith(&#34;_min&#34;) and len(param) &gt; 4})
        given_max = extract_parameters(ignore_missing=True, **{
            param[:-4]: value
            for param, value in self.kwargs.items()
            if param.endswith(&#34;_max&#34;) and len(param) &gt; 4})
        parameters_min = {param: given_min.get(param, PARAM_MIN[param]) for param in PARAM_SET}
        parameters_max = {param: given_max.get(param, PARAM_MAX[param]) for param in PARAM_SET}
        
        for param in PARAM_SET: # Verification de la coherence des bornes.
            if parameters_min[param] &gt;= parameters_max[param]:
                raise ValueError(f&#34;Les bornes du parametre {repr(param)} sont inversees, &#34;
                    f&#34;{param}_min={parameters_min[param]} et {param}_max={parameters_max[param]}.&#34;)

        # Valeur de departs des parametres.
        initial_parameters = { # Ce sont les parametres initiaux pour la descente de gradient.
            par: given_parameters.get(par,
                .5*(parameters_min[par] + parameters_max[par]))
            for par in PARAM_SET}
       
        for par, val in initial_parameters.items(): # Verification.
            if par in given_parameters and par in given_min:
                if given_parameters[par] &lt; given_min[par]:
                    raise ValueError(f&#34;Vous avez imposes {par}_min={given_min[par]} &#34;
                        f&#34;et en meme temp vous avez donnes {par}={val}!&#34;)
            if par in given_parameters and par in given_max:
                if given_parameters[par] &gt; given_max[par]:
                    raise ValueError(f&#34;Vous avez imposes {par}_max={given_max[par]} &#34;
                        f&#34;et en meme temps vous avez donnes {par}={val}!&#34;)

        # Parametres restants.
        unknown_parameters = PARAM_SET - set(given_parameters)
        if not unknown_parameters: # Si Il n&#39;y a rien a calculer.
            self._calibration_parameters = given_parameters
            if self.verbose:
                if self.verbose &gt;= 2:
                    print(&#34;        OK: Tout est fournis, il n&#39;y a rien a faire.&#34;)
                print(f&#34;    OK: Calibration terminee: {given_parameters}&#34;)
            return self._calibration_parameters

        # Extraction d&#39;un diagramme interressant.
        if self.verbose &gt;= 2:
            print(&#34;    Recuperation des diagrammes interressants...&#34;)
        if not diagrams: # Si l&#39;utilisateur ne nous aide pas a trouver les bons diagrammes.
            diagrams = []
            for i, dia in enumerate(self):
                if i &gt; 60: # On ne s&#39;interesse qu&#39;a la premiere minute.
                    break
                diagrams.append(dia)
            best_diagrams = [sorted(diagrams, key=lambda dia: dia.get_quality(), reverse=True).pop()]
        else: # Si l&#39;utilisateur nous en fournit.
            best_diagrams = diagrams # C&#39;est un tuple et non pas une liste mais c&#39;est pas genant.
        if self.verbose &gt;= 2:
            for dia in best_diagrams:
                print(f&#34;        {dia.get_id()}&#34;)

        # Vectorisation des donnees pour de bonnes perfs.
        min_size = min(
            200,
            min(len(dia) for dia in best_diagrams)
            ) # Le plus petit nombre de points.
        spots_position = np.array(
            [dia.get_positions(n=min_size, sort=&#34;quality&#34;)
             for dia in best_diagrams],
            dtype=np.float32)
        spots_position = np.swapaxes(spots_position, 0, 1) # shape: (2, n_diagrams, nbr_spots)

        # Perparations des parametres pour la suite.
        vect_labels = tuple(unknown_parameters) # On recupere les nom des parametres inconus seulement.
        bounds = [(parameters_min[name], parameters_max[name]) for name in vect_labels] # Les limites des variables.
        args = (given_parameters, vect_labels, spots_position) # Les arguments en plus de la fonction de cout.
        if self.verbose &gt;= 2:
            print(f&#34;    calibration des parametres {vect_labels}&#34;)
            print(f&#34;    bornes min: {tuple(b_min for b_min, _ in bounds)}&#34;)
            print(f&#34;    bornes max: {tuple(b_max for _, b_max in bounds)}&#34;)
        
        # Recherche rapide d&#39;un minimum par descente de gradient.
        from scipy import optimize # On ne l&#39;importe que ici car on est pas sur de s&#39;en servir.
        if self.verbose &gt;= 2:
            print(&#34;    Optimsation globale, algo genetique...&#34;)
        
        if multiprocessing.current_process().name == &#34;MainProcess&#34; and os.cpu_count() &gt; 4:
            attrs = [&#34;transformer&#34;, &#34;verbose&#34;]
            self_bis = collections.namedtuple(&#34;PartialExperiment&#34;, attrs, defaults=[getattr(self, attr) for attr in attrs])()
            opt_res = optimize.differential_evolution(
                _Picklable(cloudpickle.dumps(self_bis), Experiment._calibration_cost,
                    {name: val for name, val in zip((&#34;known_params&#34;, &#34;vect_labels&#34;, &#34;spots_position&#34;), args)}
                    ),
                updating=&#34;deferred&#34;,
                bounds=bounds,
                disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
                polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
                popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
                workers=-1) # Pour utiliser tous les cpus.
        else:
            opt_res = optimize.differential_evolution(
                self._calibration_cost,
                bounds=bounds,
                args=args,
                disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
                polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
                popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
                workers=1) # Pour ne pas creer de sous processus.
                # C&#39;est plus rapide de ne pas creer de sous processus que d&#39;en faire... car cloudpickle est lent!
        if self.verbose &gt;= 2:
            print(f&#34;        Ok: cout final = {opt_res[&#39;fun&#39;]}&#34;)
        fit_parameters_vect = opt_res[&#34;x&#34;]
        
        # Mise en forme du resultat.
        fit_parameters = {name: fit_parameters_vect[i] for i, name in enumerate(vect_labels)}
        self._calibration_parameters = {**given_parameters, **fit_parameters}
        if self.verbose:
            print(f&#34;    OK: set_calibration terminee: {self._calibration_parameters}&#34;)
        return self._calibration_parameters

    def _calibration_cost(self, params_as_vect, known_params, vect_labels, spots_position):
        &#34;&#34;&#34;
        ** Help for ``set_calibration``. **

        Parameters
        ----------
        params_as_vect : np.ndarray
            Le vecteur des valeurs inconues de parametres.
        :param known_params : dict
            Dictionaire des parametres connus.
        :param vect_labels : tuple
            Le tuple des nom des parametres associes au vecteur.
        spots_position : np.ndarray
            Coordonnees des points x, y des diagrammes de reference.
            shape = (2, n_diagrams, nbr_spots)
        &#34;&#34;&#34;
        # Projection gnomonique.
        _, n_diagrams, nbr_spots = spots_position.shape
        unknown_parameters = {name: value for name, value in zip(vect_labels, params_as_vect)}
        parameters = {**unknown_parameters, **known_params}
        gnom_spots_x, gnom_spots_y = self.transformer.cam_to_gnomonic(*spots_position, parameters) # shape: (n_diagrams, nbr_pic)

        # Recherche des axes de zones intensifs.
        gnom_spots_x = ((gnom_spots_x
                        - np.repeat(gnom_spots_x.mean(axis=-1)[..., np.newaxis], nbr_spots, axis=-1)
                        ) / np.repeat(gnom_spots_x.std(axis=-1)[..., np.newaxis], nbr_spots, axis=-1))
        gnom_spots_y = ((gnom_spots_y
                        - np.repeat(gnom_spots_y.mean(axis=-1)[..., np.newaxis], nbr_spots, axis=-1)
                        ) / np.repeat(gnom_spots_y.std(axis=-1)[..., np.newaxis], nbr_spots, axis=-1))
        thetas, dists = self.transformer.hough(gnom_spots_x, gnom_spots_y) # shape: (n_diagrams, nbr_pic*(nbr_pic-1)/2)
        clusters = self.transformer.hough_reduce(thetas, dists, # shape: (n_diagrams,)
            nbr=6, tol=0.035) # On prend des qu&#39;il y a 6 points environ allignes.

        # Calcul de l&#39;erreur.
        projection = np.mean([np.log(1 + self.transformer.dist_line( # compris generalement entre [0.007, 0.3]
                                clusters[i][0, :], clusters[i][1, :],
                                gnom_spots_x[i, :], gnom_spots_y[i, :]).min(axis=0, initial=1.0)).mean()
                              if clusters[i].shape[-1] else 1.0 # Si il n&#39;y a pas de droite, c&#39;est qu&#39;on est dans les choux.
                            for i in range(n_diagrams)]) # Moyenne des ecarts des projetes des points sur la droite la plus proche.
        scattering = np.mean([np.log(
                                    (gnom_spots_x[i, :] - gnom_spots_x[i, :].mean())**2
                                  + (gnom_spots_y[i, :] - gnom_spots_y[i, :].mean())**2
                                  + 1)
                            for i in range(n_diagrams)]) # Eparpillement [0.1, 0.95], &gt; =&gt; bien eparpille
        cost = projection * scattering**(-4)

        if self.verbose &gt;= 3:
            print(f&#34;        Current parameters: {unknown_parameters}&#34;)
            print(f&#34;        Current cost: {cost}&#34;)
            if self.verbose &gt;= 4:
                import matplotlib.pyplot as plt
                plt.clf()
                for i in range(n_diagrams):
                    plt.subplot(n_diagrams, 3, 1 + 3*i)
                    plt.title(f&#34;diagramme {i+1}, plan camera&#34;)
                    plt.scatter(spots_position[0, i, ...], spots_position[1, i, ...])

                    plt.subplot(n_diagrams, 3, 2 + 3*i)
                    plt.title(f&#34;diagramme {i+1}, plan gnomonic&#34;)
                    plt.scatter(gnom_spots_x[i, :], gnom_spots_y[i, :])
                    for angle, dist in clusters[i].transpose():
                        v = np.array([np.cos(angle), np.sin(angle)])
                        u = np.array([np.sin(angle), -np.cos(angle)])
                        p = dist*v
                        plt.axline(p, p+u, lw=0.5, color=&#34;r&#34;)

                    plt.subplot(n_diagrams, 3, 3 + 3*i)
                    plt.title(f&#34;diagramme {i+1}, hough&#34;)
                    plt.scatter(thetas[i, :], dists[i, :])
                    plt.scatter(clusters[i][0], clusters[i][1])
                plt.draw()
                plt.pause(1e-6)

        return cost

    def get_diagrams(self, *, tense_flow=False):
        &#34;&#34;&#34;
        ** Genere les diagrammes de l&#39;experience. **

        C&#39;est la qu&#39;est effectue le pic search.

        Notes
        -----
        * Performances:
            * Sur un PC (intel core i7, ssd, 8 coeurs), met environ 37 ms/diagramme.
            * Sur un PC (intel centrino, hdd, 2 coeurs), met environ 530 ms/diagramme.

        Parameters
        ----------
        tense_flow : boolean
            * True : Permet de travailler a flux tendu, c&#39;est a dire
            de cede les diagrammes au fur a meusure qu&#39;ils sont crees.
                * Le generateur termine quand toutes les images sont lues ou
                que le generateur d&#39;images leve un ``StopIteration``.
                * A chaque nouvel appel de cette methode, l&#39;iteration
                recommence a partir du debut et l&#39;ordre reste inchange.
                * Equivalent a ``laue.experiment.base_experiment.Experiment.__iter__``.
            * False. Sinon, attend que tous les diagrammes
            soient lues afin de tout renvoyer en meme temps.

        Returns
        -------
        list
            La liste des diagrammes de type ``laue.diagram.LaueDiagram``.

        Yields
        ------
        laue.diagram.LaueDiagram
            * Chaque diagram extrait au fur a mesure qu&#39;il arrive.
            * L&#39;ordre est concerve pour chaque appel de cette methode a flux tendu.
            * A chaque appel on repars du debut, meme si un autre appel n&#39;est pas termine.
            * Les sections critiques sont verouillees donc cette methode supporte le multithread.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; experiment = laue.experiment.base_experiment.Experiment(images)
        &gt;&gt;&gt;
        &gt;&gt;&gt; diagrams = experiment.get_diagrams()
        &gt;&gt;&gt; type(diagrams)
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(diagrams.pop())
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def cast_to_diagram(spots_args, name, image=None):
            &#34;&#34;&#34;
            Met en forme du pic search pour en faire des diagrames.
            &#34;&#34;&#34;
            laue_diagram = LaueDiagram(name, experiment=self)
            spots = [Spot(diagram=laue_diagram, identifier=i, **spot_args)
                     for i, spot_args in enumerate(spots_args)]
            laue_diagram._set_spots(spots)
            if image is not None and (
                    (not os.path.exists(name)) or (psutil is not None and psutil.virtual_memory().percent &lt; 50)
                    ):
                laue_diagram._set_image(image)
            return laue_diagram

        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Extraction des diagrammes...&#34;)

                start_len = len(self._buff_diags)
                for i, diag in enumerate(func(*func_args, **func_kwargs)):
                    if self.verbose &gt;= 2:
                        print(f&#34;    diagramme num {i+start_len} extrait: &#34;
                              f&#34;(...{diag.get_id()[-20:]}) &#34;
                              f&#34;avec {len(diag)} spots&#34;)
                    yield diag
                if self.verbose:
                    print(&#34;    OK: Tous les diagrammes sont extraits.&#34;)
            
            return decorate

        @show_iterator_state
        def _diagram_extractor(self):
            &#34;&#34;&#34;
            Premiere vraie lecture. Cede les diagrammes.
            &#34;&#34;&#34;
            if multiprocessing.current_process().name == &#34;MainProcess&#34;:
                from laue.core.pic_search import _pickelable_pic_search
                from laue.utilities.multi_core import limited_imap
                with multiprocessing.Pool() as pool:
                    yield from (
                        cast_to_diagram(spots_args, name, image)
                        for spots_args, (name, image) in limited_imap(pool,
                            _pickelable_pic_search,
                            (
                                (
                                    (
                                        image,
                                        self.kernel_font,
                                        self.kernel_dilate,
                                        self.threshold
                                    ),
                                    (name, image)
                                )
                                for name, image in self.read_images(condition=(
                                    lambda im_id: not any(im_id == d.get_id() for d in self._buff_diags)
                                ))
                            )
                        )
                    )
            else:
                from laue import atomic_pic_search
                yield from (
                    cast_to_diagram(
                        atomic_pic_search(
                            image,
                            self.kernel_font,
                            self.kernel_dilate,
                            self.threshold
                        ),
                        name,
                        image
                    )
                    for name, image in self.read_images(condition=(
                        lambda im_id: not any(im_id == d.get_id() for d in self._buff_diags)
                    ))
                )
        
        if self._diagrams_iterator is None:
            self._diagrams_iterator = iter(_diagram_extractor(self))

        from laue.utilities.multi_core import RecallingIterator
        return (
            (lambda x: (yield from x))(RecallingIterator(self._diagrams_iterator, mother=self, buff_name=&#34;_buff_diags&#34;))
            if tense_flow else list(RecallingIterator(self._diagrams_iterator, mother=self, buff_name=&#34;_buff_diags&#34;)))

    def find_subsets(self, *, tense_flow=False, **kwds):
        &#34;&#34;&#34;
        ** Estime les grains dans chaque diagrame. **

        Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_subsets``.
        Le resultat est le meme que: ``[diag.find_subsets(**kwds) for diag in self]``

        Notes
        -----
        * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.
        
        Parameters
        ----------
        tense_flow : boolean
            * True : Permet de travailler a flux tendu, c&#39;est a dire
            de ceder les bouts de grains des diagrammes au fur a meusure qu&#39;ils sont trouves.
                * Le generateur termine quand toutes les images sont lues ou
                que le generateur d&#39;images leve un ``StopIteration``.
                * A chaque nouvel appel de cette methode, l&#39;iteration
                recommence a partir du debut et l&#39;ordre reste inchange.
                * Equivalent a ``(diag.find_subsets(**kwds) for diag in self)``.
            * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
                * C&#39;est equvalent a ``[diag.find_subsets(**kwds) for diag in self]``.
                * Au lieu de retourner un generateur, retourne une liste.
        **kwds
            Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_subsets``.
            Se sont aussi ceux de la fonction ``laue.diagram.LaueDiagram.find_zone_axes``.

        Returns
        -------
        list
            Pour chaque diagramme de cette experience, cede une estimation des grains.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; experiment = laue.experiment.base_experiment.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(experiment.find_subsets())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(experiment.find_subsets(tense_flow=True))
        &lt;class &#39;generator&#39;&gt;
        &gt;&gt;&gt; type(next(iter(experiment.find_subsets(tense_flow=True))))
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Estimation des grains...&#34;)
                
                for i, groups in enumerate(func(*func_args, **func_kwargs)):
                    if self.verbose &gt;= 2:
                        print(f&#34;    grain du diagramme num {i} estimes: il y a {len(groups)} clusters&#34;)
                    yield groups

                if self.verbose:
                    print(&#34;    OK: Tous les clusters de grains sont estimes.&#34;)

            return decorate

        @show_iterator_state
        def _subsets_extractor(self):
            if multiprocessing.current_process().name == &#34;MainProcess&#34;:
                from laue.core.subsets import _jump_find_subsets
                from laue.utilities.multi_core import limited_imap
                with multiprocessing.Pool() as pool:
                    yield from (
                        (
                            diag.find_subsets(_atomic_subsets_res=args)
                            if not isinstance(args, dict) else
                            diag.find_subsets(**args)
                        )
                        for diag, args
                        in zip(
                            self,
                            limited_imap(pool,
                                _jump_find_subsets,
                                (
                                    diag.find_subsets(**kwds, _get_args=True)
                                    for _, diag in zip(self.find_zone_axes(tense_flow=True, **kwds), self)
                                )
                            )
                        )
                    )
            else:
                yield from (diag.find_subsets(**kwds) for diag in self)

        if not tense_flow:
            return list(self.find_subsets(tense_flow=True, **kwds))

        if self._subsets_iterator is None:
            self._subsets_iterator = iter(_subsets_extractor(self))

        from laue.utilities.multi_core import RecallingIterator
        return (lambda x: (yield from x))(RecallingIterator(self._subsets_iterator, mother=self))

    def find_zone_axes(self, *, tense_flow=False, **kwds):
        &#34;&#34;&#34;
        ** Recherche l&#39;ensemble des axes de zones. **

        Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_zone_axes``.
        Le resultat est le meme que: ``[diag.find_zone_axes(**kwds) for diag in self]``

        Notes
        -----
        * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.

        Parameters
        ----------
        tense_flow : boolean
            * True : Permet de travailler a flux tendu, c&#39;est a dire
            de ceder les axes des diagrammes au fur a meusure qu&#39;ils sont trouves.
                * Le generateur termine quand toutes les images sont lues ou
                que le generateur d&#39;images leve un ``StopIteration``.
                * A chaque nouvel appel de cette methode, l&#39;iteration
                recommence a partir du debut et l&#39;ordre reste inchange.
                * Equivalent a ``(diag.find_zone_axes(**kwds) for diag in self)``.
            * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
                * C&#39;est equvalent a ``[diag.find_zone_axes(**kwds) for diag in self]``.
                * Au lieu de retourner un generateur, retourne une liste.
        **kwds
            Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_zone_axes``.

        Returns
        -------
        list
            Pour chaque diagramme de cette experience, cede la liste
            des axes de zones du diagramme. Les elements de l&#39;ensemble
            sont de type ``laue.zone_axis.ZoneAxis``.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; experiment = laue.experiment.base_experiment.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(experiment.find_zone_axes())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(experiment.find_zone_axes(tense_flow=True))
        &lt;class &#39;generator&#39;&gt;
        &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))))
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))).pop())
        &lt;class &#39;laue.zone_axis.ZoneAxis&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Extraction des axes de zone...&#34;)
                
                for i, axes in enumerate(func(*func_args, **func_kwargs)):
                    if self.verbose &gt;= 2:
                        print(f&#34;    axes du diagramme num {i} trouves: il y en a {len(axes)}&#34;)
                    yield axes

                if self.verbose:
                    print(&#34;    OK: Tous les axes de zone sont extraits.&#34;)

            return decorate

        @show_iterator_state
        def _axes_extractor(self):
            &#34;&#34;&#34;
            Premiere vraie extraction.
            &#34;&#34;&#34;
            if multiprocessing.current_process().name == &#34;MainProcess&#34;:
                # Parallelisation des fils.
                from laue.core.zone_axes import _jump_find_zone_axes
                from laue.utilities.multi_core import limited_imap
                with multiprocessing.Pool() as pool:
                    yield from (
                        (
                            diag.find_zone_axes(_axes_args=args)
                            if not isinstance(args, dict) else
                            diag.find_zone_axes(**args)
                        )
                        for diag, args
                        in zip(
                            self,
                            limited_imap(pool,
                                _jump_find_zone_axes,
                                (
                                    diag.find_zone_axes(**kwds, _get_args=True)
                                    for diag in self
                                )
                            )
                        )
                    )

            else:
                yield from (diag.find_zone_axes(**kwds) for diag in self)

        if not tense_flow:
            return list(self.find_zone_axes(tense_flow=True, **kwds))

        if self._axes_iterator is None:
            self._axes_iterator = iter(_axes_extractor(self))

        from laue.utilities.multi_core import RecallingIterator
        return (lambda x: (yield from x))(RecallingIterator(self._axes_iterator, mother=self))

    def _get_gnomonic_matrix(self):
        &#34;&#34;&#34;
        ** Calcul les matrices de transformation gnomonic **

        Notes
        -----
        * Permet via ``cv2`` d&#39;avoir une image dans le plan gnomonic.
        * Les tailles des image sont le meme dans le plan
        de la camera et dans le plan gnommonic.

        Returns
        -------
        np.ndarray(np.float32) : map_x
            La premiere matrice que l&#39;on peut voir comme une fonction
            de ``f(x_gnomon, y_gnomon) -&gt; x_camera``, avec les coordonnees
            gnomonique exprimees en pxl.
        np.ndarray(np.float32) : map_y
            La seconde matrice ``f(x_gnomon, y_gnomon) -&gt; y_camera``
        tuple : bornes
            Les limite en mm des pixel extremes:
            (xmin, xmax, ymin, ymax)
        &#34;&#34;&#34;
        if self._gnomonic_matrix is not None:
            return self._gnomonic_matrix

        if self.verbose:
            print(&#34;Recuperation de la matrice gnomonic...&#34;)
        # Recherche des bornes.
        x_max, y_max = self.get_images_shape()
        xg, yg = self.transformer.cam_to_gnomonic(
            *np.meshgrid(np.arange(x_max), np.arange(y_max), copy=False),
            self.set_calibration())
        bornes = (xg.min(), xg.max(), yg.min(), yg.max())
        
        del xg, yg
        x_side = np.linspace(bornes[0], bornes[1], num=x_max)
        y_side = np.linspace(bornes[2], bornes[3], num=y_max)

        # Fonction inverse.
        map_x, map_y = self.transformer.gnomonic_to_cam(
            *np.meshgrid(x_side, y_side, copy=False),
            self.set_calibration(), dtype=np.float32)
        # map_x, map_y = map_x.astype(np.float32, copy=False), map_y.astype(np.float32, copy=False) # cv2 en a besoin.

        if self.verbose:
            print(&#34;    OK: La matrice gnomonic est calculee.&#34;)

        # Sauvegarde
        if psutil is not None and psutil.virtual_memory().percent &lt; 75:
            self._gnomonic_matrix = (map_x, map_y, bornes)
            return self._gnomonic_matrix
        return (map_x, map_y, bornes)

    def get_mean(self):
        &#34;&#34;&#34;
        ** Estime la moyenne des images. **

        Cela permet d&#39;avoir une estimation du fond diffus.

        Notes
        -----
        * A cause des arrondis machine, seule les 9e15 permieres images sont considerees.
        * Ne retourne pas tant que toutes les images d&#39;entree ne sont pas lues.

        Returns
        -------
        np.ndarray
            L&#39;image de la moyenne des images en matrice 2d uint16.
        &#34;&#34;&#34;
        if self._mean_bg is not None:
            return self._mean_bg

        if self.verbose:
            print(&#34;Estimation du fond par la moyenne...&#34;)

        im_gen = iter((image.astype(np.float64) for _, image in self.read_images()))
        try:
            mean_array = next(im_gen)
        except StopIteration as err:
            raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
        for i, image in enumerate(im_gen):
            mean_array = i/(i+1) * mean_array + 1/(i+1) * image

        self._mean_bg = mean_array.astype(np.uint16)

        if self.verbose:
            print(&#34;    OK: La moyenne des images est estimee.&#34;)
        return self._mean_bg

    def get_images_shape(self):
        &#34;&#34;&#34;
        ** Recupere les dimensions des images. **

        Returns
        -------
        tuple
            (nbr de lignes, nbr de colones), de type (int, int).
        &#34;&#34;&#34;
        if self._shape is not None:
            return self._shape

        try:
            _, image = next(iter(self.read_images()))
        except StopIteration as err:
            raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
        self._shape = image.shape
        return self._shape

    def read_images(self, condition=(lambda name: True)):
        &#34;&#34;&#34;
        ** Cede le contenu des images. **

        Notes
        -----
        * Reitere depuis le debut a chaque appel.
        * Il peut y avoir plusieurs appels en parallele
        sans que cela ne genere de conflits. Dumoins tans que des threads
        ne sont pas utilises, car il n&#39;y a pas de mecanisme de verrou.
        * A chaque appel de cette methode, l&#39;ordre est conserve.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.

        Parameters
        ----------
        condition : callable, optional
            Une fonction de selection qui prend en entree l&#39;identifiant de l&#39;image
            et qui renvoi True si il faut lire l&#39;image, sinon. Si il renvoi False,
            l&#39;image en question est sautee.

        Yields
        ------
        name : str
            Le nom de l&#39;image (path si possible)
        image : np.ndarray
            Le contenu de l&#39;image

        Raises
        ------
        TypeError
            Si l&#39;image n&#39;est pas bien typee.
        FileNotFoundError
            Si le chemin de l&#39;image n&#39;est pas correcte.
        ValueError
            Si les images ne sont pas de la meme taille.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; for image in laue.experiment.base_experiment.Experiment(images):
        ...     pass
        ...
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        from laue.utilities.multi_core import RecallingIterator, prevent_generator_size

        def read_and_check_any_image(image_info, image_num):
            &#34;&#34;&#34;
            Soit retroune directement, soit lit le fichier.
            Retourne le nom de l&#39;image et l&#39;image elle-meme.
            Renvoi None, None si il faut ignorer cette image.
            &#34;&#34;&#34;            
            # Mise en forme.
            if isinstance(image_info, str):
                image_name = image_info
                from laue.utilities.image import read_image
                image = read_image(image_info, ignore_errors=self.ignore_errors)
                if image is None:
                    return None, None
            elif isinstance(image_info, np.ndarray):
                image_name = f&#34;image_{image_num}&#34;
                image = image_info
            else:
                raise TypeError(&#34;L&#39;image doit etre de type str ou np.array, &#34;
                    f&#34;pas {type(image_info).__name__}.&#34;)

            # Verifications
            if not isinstance(image, np.ndarray):
                raise TypeError(f&#34;L&#39;image doit etre un array numpy, pas un {type(image).__name__}.&#34;)
            if image.ndim != 2:
                raise TypeError(f&#34;L&#39;image {image_name} doit etre en niveau de gris pas de dimension {image.ndim}.&#34;)
            if image.dtype != np.uint16:
                raise TypeError(f&#34;L&#39;image {image_name} doit etre encodee en uint16, pas {image.dtype}.&#34;)
            if self._shape is None:
                self._shape = image.shape
            if self._shape != image.shape:
                raise ValueError(f&#34;L&#39;image {image_name} a pour taille {image.shape} tandis que les images &#34;
                    f&#34;precedentes ont pour taille {self._shape}. Les images ne sont pas issues de la meme experience.&#34;)

            return image_name, image

        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Lecture des images...&#34;)
                
                for image_info in func(*func_args, **func_kwargs):
                    yield image_info
                    if self.verbose &gt;= 2:
                        print(f&#34;    image : {str(image_info).split(&#39;/&#39;)[-1][-40:]} cedee.&#34;)

                if self.verbose:
                    print(&#34;    OK: Toutes les images sont lues.&#34;)

            return decorate

        def update_len(func):
            &#34;&#34;&#34;
            Tient a jour la longueur de l&#39;experience.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                for element in func(*func_args, **func_kwargs):
                    yield element
                self._len = len(self._buff_images)

            return decorate

        @update_len
        @show_iterator_state
        def _images_extractor():
            &#34;&#34;&#34;
            Premiere vraie extraction.
            &#34;&#34;&#34;
            yield from self._images

        @prevent_generator_size(min_size=(0 if self._buff_images else 1))
        def jump_map(multi_image_iterator):
            image_num = 0
            for image_info in multi_image_iterator:
                if condition(image_info):
                    image_name, image = read_and_check_any_image(image_info, image_num)
                else:
                    image_name = image = None
                    image_num += 1
                if image is None:
                    continue
                image_num += 1
                yield image_name, image

        if self._images_iterator is None:
            self._images_iterator = iter(_images_extractor())

        return jump_map(RecallingIterator(self._images_iterator, mother=self, buff_name=&#34;_buff_images&#34;))

    def save_file(self, filename):
        &#34;&#34;&#34;
        ** Enregistre un fichier contenant des informations. **

        Notes
        -----
        * Les extensions prises en charge sont ``.det``.
        * Pour les fichiers propres a chaque diagrammes, voir ``laue.diagram.LaueDiagram.save_file``.

        Parameters
        ----------
        filename : str
            Nom ou chemin du fichier de destination.
            L&#39;extension doit etre comprise dans le nom du fichier.
            Si un fichier du meme nom existe deja, il est ecrase.

        Example
        -------
        &gt;&gt;&gt; import os, tempfile
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt;
        &gt;&gt;&gt; images = [&#34;laue/examples/ge_blanc.mccd&#34;]
        &gt;&gt;&gt; rep = tempfile.mkdtemp()
        &gt;&gt;&gt; expe = laue.experiment.base_experiment.Experiment(images, dd=71.5, x0=938.5, y0=1078.1)
        &gt;&gt;&gt; expe.save_file(os.path.join(rep, &#34;fit.det&#34;))
        &#34;&#34;&#34;
        assert isinstance(filename, str), \
            f&#34;&#39;filename&#39; has to be a string, not a {type(filename).__name__}.&#34;
        assert &#34;.&#34; in filename, &#34;Le fichier doit posseder une extension.&#34;
        assert filename.split(&#34;.&#34;)[-1].lower() in {&#34;det&#34;}, \
            f&#34;Seule les extensions &#39;.det&#39; sont supportees. Pas &#39;.{filename.split(&#39;.&#39;)[-1]}&#39;.&#34;

        ext = filename.split(&#34;.&#34;)[-1].lower()
        if ext == &#34;det&#34;:
            with open(filename, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
                file.write(
                   (f&#34;{self.set_calibration()[&#39;dd&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;xcen&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;ycen&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;xbet&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;xgam&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;pixelsize&#39;]}, &#34;
                    f&#34;{self.get_images_shape()[0]}, &#34;
                    f&#34;{self.get_images_shape()[1]}\n&#34;))
                file.write(&#34;Sample-Detector distance(IM), xO, yO, angle1, angle2, pixelsize, dim1, dim2\n&#34;)
                file.write(f&#34;{repr(self)}\n&#34;)
                file.write(f&#34;Calibration done at {time.asctime()}.\n&#34;)

    def _clean(self):
        &#34;&#34;&#34;
        ** Tente de liberer de la memoire. **

        Supprime tous les attributs qui sont suceptibles
        de prendre de la place en memoire.
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Suppression des attributs facultatifs...&#34;)
        self._gnomonic_matrix = None
        for diag in self:
            diag._clean()
        if self.verbose:
            print(&#34;    OK: Le volume de donnees et minimum.&#34;)

    def __getitem__(self, item):
        &#34;&#34;&#34;
        ** Recupere un ou plusieurs diagrame.s. **

        Retroune le ou les diagrames de type ``laue.diagram.LaueDiagram``.

        Parameters
        ----------
        item
            * Ce qui permet de reconaitre un diagrame parmis tous.
                * ``int`` =&gt; Retourne le ieme diagrame, genere par la
                    ieme image lue.
                * ``slice`` =&gt; Permet de manipuler l&#39;experience comme une
                    liste de diagrames ordones dans l&#39;ordre de generation des images.

        Raises
        ------
        KeyError
            Si la clef est correcte mais qu&#39;aucun diagrame ne correspond a cette clef.
        TypeError
            Si la clef n&#39;est pas correcte.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(laue.experiment.base_experiment.Experiment(images)[0])
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt; type(laue.experiment.base_experiment.Experiment(images)[-1])
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(laue.experiment.base_experiment.Experiment(images)[:])
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; len(laue.experiment.base_experiment.Experiment(images)[:])
        2
        &gt;&gt;&gt; laue.experiment.base_experiment.Experiment(images)[2:]
        []
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def get_diag_list(limit, ignore=False):
            # Cas simple ou il n&#39;y a rien a extraire.
            if limit &gt;= 0 and len(self._buff_diags) &gt; limit: # Si on a deja une liste de la bone taille.
                return self._buff_diags
            if limit &lt; 0 and len(self) and -limit &lt;= len(self):
                return self._buff_diags
            if len(self) and ignore: # Si il faut se contenter de ce qu&#39;on a, meme si c&#39;est pas suffisant.
                return self._buff_diags
            if len(self) and limit &gt;= len(self):
                raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                    f&#34;Or vous tentez d&#39;acceder au {limit+1}eme diagrame!&#34;)
            if len(self) and -limit &gt; len(self):
                raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                    f&#34;Or vous tentez d&#39;acceder au rang {limit}. &#34;
                    f&#34;Le plus petit rang possible c&#39;est {-len(self)}.&#34;)

            # Cas ou il faut extraire.
            if limit &gt;= 0:
                target_limit = max(limit, 2*len(self._buff_diags))
                for i, diag in enumerate(self):
                    if i == limit:
                        break
            else:
                self.get_diagrams()

            return get_diag_list(limit=limit, ignore=ignore)

        if isinstance(item, (int, np.integer)):
            return get_diag_list(item)[item]

        if isinstance(item, slice):
            assert item.start is None or isinstance(item.start, (int, np.integer)), \
                f&#34;Slice arguments has to be int, not {type(item.start).__name__}.&#34;
            assert item.stop is None or isinstance(item.stop, (int, np.integer)), \
                f&#34;Slice arguments has to be int, not {type(item.stop).__name__}.&#34;
            assert item.step is None or isinstance(item.step, (int, np.integer)), \
                f&#34;Slice arguments has to be int, not {type(item.step).__name__}.&#34;
            l1 = get_diag_list(item.start, ignore=True) if item.start is not None else []
            l2 = get_diag_list(item.stop, ignore=True) if item.stop is not None else self.get_diagrams()
            return (l1 if len(l1) &gt; len(l2) else l2)[item]

        raise TypeError(f&#34;La clef doit etre de type int ou slice. Pas {type(item).__name__}.&#34;)

    def __iter__(self):
        &#34;&#34;&#34;
        ** Cede les differents diagrammes contenus dans l&#39;experience. **

        * L&#39;ordre est arbitraire la premiere fois mais reste le meme a chaque appel.
        * Strictement equivalent a ``self.get_diagrams(tense_flow=True)`` de
        la methode ``laue.experiment.base_experiment.Experiment.get_diagrams``.

        Yields
        ------
        diagram : laue.diagram.LaueDiagram
            Chaque diagramme contenus dans l&#39;experience.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; experiment = laue.experiment.base_experiment.Experiment(image)
        &gt;&gt;&gt;
        &gt;&gt;&gt; for diag in experiment:
        ...     pass # Allows to process each diagram as it is ready.
        ...
        &gt;&gt;&gt; type(next(iter(experiment)))
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        yield from self.get_diagrams(tense_flow=True)

    def __len__(self):
        &#34;&#34;&#34;
        ** Nombre de diagrammes constituants l&#39;experience. **

        Returns
        -------
        int
            Renvoi le nombre de diagrames presents dans cette experience.
            Si toutes les images ne sont pas lus, la valeur 0 est renvoyee.
        &#34;&#34;&#34;
        if self._len is None:
            return 0
        return self._len

    def __repr__(self):
        &#34;&#34;&#34;
        ** Renvoi une chaine evaluable de self. **
        &#34;&#34;&#34;
        name = repr(&#34;/&#34;.join(self[0].get_id().split(&#34;/&#34;)[:-1]))
        return f&#34;Experiment({name})&#34;

    def __str__(self):
        &#34;&#34;&#34;
        ** Retourne une jolie representation. **
        &#34;&#34;&#34;
        addi_kwargs = &#39;        \n&#39;.join(f&#39;{k}={v}&#39; for k, v in self.kwargs.items())
        addi_print = f&#34;\n    additional kwargs: \n        {addi_kwargs}&#34; if addi_kwargs else &#34;&#34;
        return (&#34;Basic Experiment:\n&#34;
                f&#34;    nbr reading diagrams: {len(self)}\n&#34;
                f&#34;    max_space: {self.max_space} pxl\n&#34;
                f&#34;    threshold: {self.threshold} impact/impact\n&#34;
                f&#34;    font_size: {self.font_size} pxl\n&#34;
                f&#34;    ignore_errors: {self.ignore_errors}\n&#34;
                f&#34;    verbose: {self.verbose}&#34;
                f&#34;{addi_print}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="laue.utilities.serialization.ExperimentPickleable" href="utilities/serialization.html#laue.utilities.serialization.ExperimentPickleable">ExperimentPickleable</a></li>
<li>laue.utilities.serialization.OrderedExperimentPickleable</li>
<li><a title="laue.utilities.data_consistency.Recordable" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable">Recordable</a></li>
<li>threading.Thread</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="laue.experiment.ordered_experiment.OrderedExperiment" href="experiment/ordered_experiment.html#laue.experiment.ordered_experiment.OrderedExperiment">OrderedExperiment</a></li>
<li><a title="laue.experiment.theorical_experiment.TheoricalExperiment" href="experiment/theorical_experiment.html#laue.experiment.theorical_experiment.TheoricalExperiment">TheoricalExperiment</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="laue.utilities.serialization.ExperimentPickleable" href="utilities/serialization.html#laue.utilities.serialization.ExperimentPickleable">ExperimentPickleable</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.utilities.serialization.ExperimentPickleable.__getstate__" href="utilities/serialization.html#laue.utilities.serialization.ExperimentPickleable.__getstate__">__getstate__</a></code></li>
<li><code><a title="laue.utilities.serialization.ExperimentPickleable.__setstate__" href="utilities/serialization.html#laue.utilities.serialization.ExperimentPickleable.__setstate__">__setstate__</a></code></li>
</ul>
</li>
<li><code><b><a title="laue.utilities.data_consistency.Recordable" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable">Recordable</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.utilities.data_consistency.Recordable.__enter__" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.__enter__">__enter__</a></code></li>
<li><code><a title="laue.utilities.data_consistency.Recordable.kill" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.kill">kill</a></code></li>
<li><code><a title="laue.utilities.data_consistency.Recordable.run" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.run">run</a></code></li>
<li><code><a title="laue.utilities.data_consistency.Recordable.save_state" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.save_state">save_state</a></code></li>
<li><code><a title="laue.utilities.data_consistency.Recordable.start" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.start">start</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="laue.Lambdify"><code class="flex name class">
<span>class <span class="ident">Lambdify</span></span>
<span>(</span><span>args, expr, *, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.lambdify.Lambdify" href="utilities/lambdify.html#laue.utilities.lambdify.Lambdify">Lambdify</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lambdify:
    &#34;&#34;&#34;
    ** Permet de manipuler plus simplement une fonction. **
    &#34;&#34;&#34;
    def __init__(self, args, expr, *, verbose=False, _simp_expr=None):
        &#34;&#34;&#34;
        ** Prepare la fonction. **

        Parameters
        ----------
        args : iterable
            Les parametres d&#39;entre de la fonction.
        expr : sympy.core
            L&#39;expresion sympy a vectoriser.
        &#34;&#34;&#34;
        # Preparation symbolique.
        self.args = [arg for arg in sympy.sympify(args)]
        self.args_name = [str(arg) for arg in self.args]
        self.args_position = {arg: i for i, arg in enumerate(self.args_name)}
        self.expr = expr
        self.verbose = verbose

        # Preparation vectoriele.
        self._simp_expr = _simp_expr
        if self._simp_expr is None:
            self._simp_expr = simplify(self.expr, measure=TimeCost(), verbose=verbose)
        self.fct = lambdify(self.args, self._simp_expr, cse=True, modules=&#34;numpy&#34;)
        try:
            self.fct_numexpr = lambdify(self.args, evalf(self._simp_expr, n=15), cse=True, modules=&#34;numexpr&#34;)
        except (ImportError, TypeError, RuntimeError):
            self.fct_numexpr = None

    def __str__(self, *, name=&#34;lambdifygenerated&#34;, bloc=&#34;numpy&#34;):
        &#39;&#39;&#39;
        ** Offre une representation explicite de la fonction. **

        Parameters
        ----------
        name : str
            Le nom a donner a la fonction.
        bloc : str
            La partie du code a impromer. Permet de selectionner la fonction.

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos, pi
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; print(Lambdify([x, y], pi*cos(x + y) + x + y), end=&#34;&#34;)
        def _lambdifygenerated_numpy(x, y):
            &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;
            x0 = x + y
            _0 = x0 + 3.14159265358979*cos(x0)
            return _0
        &gt;&gt;&gt;
        &#39;&#39;&#39;
        assert isinstance(name, str), f&#34;&#39;name&#39; has to be str, not {type(name).__name__}.&#34;
        assert bloc in {&#34;main&#34;, &#34;numpy&#34;, &#34;numpy128&#34;, &#34;numexpr&#34;, &#34;sympy&#34;}
        import re

        # Code numexpr.
        if bloc == &#34;numexpr&#34;:
            if self.fct_numexpr is not None:
                code = self.fct_numexpr.__doc__.split(&#34;\n&#34;)
                code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numexpr&#34;)
                code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float64 using the numexpr module.&#34;&#34;&#34;&#39;)
            else:
                code = []

        # Code &lt; float 64
        elif bloc == &#34;numpy&#34;:
            code = lambdify(self.args, evalf(self._simp_expr),
                cse=True, modules=&#34;numpy&#34;).__doc__.split(&#34;\n&#34;)
            code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy&#34;)
            code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in small float using the numpy module.&#34;&#34;&#34;&#39;)

        # Code float 128
        elif bloc == &#34;numpy128&#34;:
            f_mod = re.compile(r&#34;&#34;&#34;(?:[+-]*
                (?:
                  \. [0-9]+ (?:_[0-9]+)*
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)* \. (?: [0-9]+ (?:_[0-9]+)* )?
                  (?: e [+-]? [0-9]+ (?:_[0-9]+)* )?
                | [0-9]+ (?:_[0-9]+)*
                  e [+-]? [0-9]+ (?:_[0-9]+)*
                ))&#34;&#34;&#34;, re.VERBOSE | re.IGNORECASE) # Model d&#39;un flottant.
            code_str = self.fct.__doc__
            code_str = re.sub(f_mod,
                lambda m: (f&#34;float128({repr(m.group())})&#34; if len(m.group()) &gt;= 15 else m.group()),
                code_str)
            code = code_str.split(&#34;\n&#34;)
            code[0] = code[0].replace(&#34;_lambdifygenerated&#34;, f&#34;_{name}_numpy128&#34;)
            code.insert(1, &#39;    &#34;&#34;&#34;Perform calculations in float128 using the numpy module.&#34;&#34;&#34;&#39;)

        # Expression formelle
        elif bloc == &#34;sympy&#34;:
            defs, rvs = cse_homogeneous(self.expr)
            code = []
            code.append(f&#34;def _{name}_sympy():&#34;)
            code.append( &#39;    &#34;&#34;&#34;Returns the tree of the sympy expression.&#34;&#34;&#34;&#39;)
            code.append(f&#34;    {&#39;, &#39;.join(self.args_name)} = symbols(&#39;{&#39; &#39;.join(self.args_name)}&#39;)&#34;)
            for var, expr in defs:
                code.append(f&#34;    {var} = {expr}&#34;)
            code.append(f&#34;    return {rvs}&#34;)
            code.append( &#34;&#34;)

        # Fonction principale Equivalent as self.__call__.
        elif bloc == &#34;main&#34;:
            code = []
            code.append(f&#34;def {name}(*args, **kwargs):&#34;)
            code.append( &#39;    &#34;&#34;&#34;&#39;)
            code.append( &#34;    ** Choose the most suitable function according to&#34;)
            code.append( &#34;    the type and size of the input data. **&#34;)
            code.append( &#34;&#34;)
            code.append( &#34;    Parameters&#34;)
            code.append( &#34;    ----------&#34;)
            code.append( &#34;    *args&#34;)
            code.append( &#34;        Les parametres ordonnes de la fonction.&#34;)
            code.append( &#34;    **kwargs&#34;)
            code.append( &#34;        Les parametres nomes de la fonction. Ils&#34;)
            code.append( &#34;        ont le dessus sur les args en cas d&#39;ambiguite.&#34;)
            code.append( &#39;    &#34;&#34;&#34;&#39;)

            code.append( &#34;    assert len(args) &lt;= %d, f&#39;The function cannot take {len(args)} arguments.&#39;&#34;
                                                % len(self.args))
            code.append( &#34;    assert not set(kwargs) - {%s}, f&#39;You cannot provide {kwargs}.&#39;&#34;
                                                      % &#34;, &#34;.join(repr(a) for a in self.args_name))
            code.append( &#34;    if not args and not kwargs:&#34;)
            code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
            code.append(f&#34;        return _{name}_sympy()&#34;)

            code.append( &#34;    args = list(args)&#34;)
            code.append(f&#34;    if len(args) &lt; {len(self.args)}:&#34;)
            code.append(f&#34;        args += sympy.symbols(&#39; &#39;.join({self.args_name}[len(args):]))&#34;)
            code.append( &#34;    if kwargs:&#34;)
            code.append( &#34;        for arg, value in kwargs.items():&#34;)
            code.append(f&#34;            args[{self.args_position}[arg]] = value&#34;)

            code.append( &#34;    if any(isinstance(a, sympy.Basic) for a in args):&#34;)
            code.append( &#34;        sub = {arg: value for arg, value in zip(%s, args)}&#34; % self.args_name)
            code.append( &#34;        from laue.utilities.lambdify import subs&#34;)
            code.append(f&#34;        from laue.data.sympy_lambdify import _{name}_sympy&#34;)
            code.append(f&#34;        return subs(_{name}_sympy(), sub)&#34;)

            if hasattr(np, &#34;float128&#34;):
                code.append( &#34;    if any(a.dtype == np.float128 for a in args if isinstance(a, np.ndarray)):&#34;)
                code.append(f&#34;        from laue.data.numpy128_lambdify import _{name}_numpy128&#34;)
                code.append(f&#34;        return _{name}_numpy128(*args)&#34;)
            if self.fct_numexpr is not None:
                code.append( &#34;    if (&#34;)
                code.append( &#34;            (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)&#34;)
                code.append( &#34;            and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))&#34;)
                code.append( &#34;        ):&#34;)
                code.append(f&#34;        from laue.data.numexpr_lambdify import _{name}_numexpr&#34;)
                code.append(f&#34;        return _{name}_numexpr(*args)&#34;)
            code.append(f&#34;    from laue.data.numpy_lambdify import _{name}_numpy&#34;)
            code.append(f&#34;    return _{name}_numpy(*args)&#34;)
            code.append( &#34;&#34;)

        else:
            raise KeyError

        return &#34;\n&#34;.join(code)

    def __repr__(self):
        &#34;&#34;&#34;
        ** Offre une representation evaluable de l&#39;objet. **

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return f&#34;Lambdify([{&#39;, &#39;.join(self.args_name)}], {self.expr})&#34;

    def __call__(self, *args, **kwargs):
        &#34;&#34;&#34;
        ** Evalue la fonction. **

        Parameters
        ----------
        *args
            Les parametres ordonnes de la fonction.
        **kwargs
            Les parametres nomes de la fonction. Ils
            ont le dessus sur les args en cas d&#39;ambiguite.

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt; l = Lambdify([x, y], x + y + cos(x + y))

        Les cas symboliques.
        &gt;&gt;&gt; l() # Retourne l&#39;expression sympy.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(x) # Complete la suite en rajoutant &#39;y&#39;.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(y) # Complete aussi en rajoutant &#39;y&#39;.
        2*y + cos(2*y)
        &gt;&gt;&gt; l(x, y) # Retourne une copie de l&#39;expression sympy.
        x + y + cos(x + y)
        &gt;&gt;&gt; l(1, y=2*y) # Il est possible de faire un melange symbolique / numerique.
        2*y + cos(2*y + 1) + 1
        &gt;&gt;&gt;

        Les cas purement numeriques.
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; l(-1, 1)
        1.0
        &gt;&gt;&gt; l(x=-1, y=1)
        1.0
        &gt;&gt;&gt; np.round(l(0, np.linspace(-1, 1, 5)), 2)
        array([-0.46,  0.38,  1.  ,  1.38,  1.54])
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        # Cas patologiques.
        if not args and not kwargs:
            return self.expr
        if len(args) &gt; len(self.args):
            raise IndexError(f&#34;La fonction ne prend que {len(self.args)} arguments. &#34;
                f&#34;Or vous en avez fournis {len(args)}.&#34;)
        
        # Recuperation des arguments complets.
        args = list(args)
        args += self.args[len(args):]
        if kwargs:
            if set(kwargs) - set(self.args_position):
                raise NameError(f&#34;Les parametres {set(kwargs) - set(self.args_position)} &#34;
                    f&#34;ne sont pas admissible, seul {set(self.args_position)} sont admissibles.&#34;)
            for arg, value in kwargs.items():
                args[self.args_position[arg]] = value

        # Cas symbolique.
        if any(isinstance(a, sympy.Basic) for a in args):
            sub = {arg: value for arg, value in zip(self.args, args)}
            return subs(self.expr, sub)

        # Cas numerique.
        if (
                (self.fct_numexpr is not None)
                and (max((a.size for a in args if isinstance(a, np.ndarray)), default=0) &gt;= 157741)
                and all(a.dtype == np.float64 for a in args if isinstance(a, np.ndarray))
            ):
            return self.fct_numexpr(*args)
        return self.fct(*args)

    def __getstate__(self):
        &#34;&#34;&#34;
        ** Extrait l&#39;information serialisable. **

        Examples
        --------
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; l = Lambdify([x, y], cos(x + y) + x + y)
        &gt;&gt;&gt; l.__getstate__()
        ([x, y], x + y + cos(x + y), False)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self.expr == self._simp_expr:
            return (self.args, self.expr, self.verbose)
        return (self.args, self.expr, self.verbose, self._simp_expr)

    def __setstate__(self, state):
        &#34;&#34;&#34;
        ** Instancie l&#39;objet a partir de l&#39;etat. **

        Examples
        --------
        &gt;&gt;&gt; import pickle
        &gt;&gt;&gt; from sympy.abc import x, y; from sympy import cos
        &gt;&gt;&gt; from laue.utilities.lambdify import Lambdify
        &gt;&gt;&gt;
        &gt;&gt;&gt; Lambdify([x, y], cos(x + y) + x + y)
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt; pickle.loads(pickle.dumps(_))
        Lambdify([x, y], x + y + cos(x + y))
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if len(state) == 4:
            self.__init__(state[0], state[1], verbose=state[2], _simp_expr=state[3])
        else:
            self.__init__(state[0], state[1], verbose=state[2])</code></pre>
</details>
</dd>
<dt id="laue.NestablePool"><code class="flex name class">
<span>class <span class="ident">NestablePool</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.NestablePool" href="utilities/multi_core.html#laue.utilities.multi_core.NestablePool">NestablePool</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NestablePool(multiprocessing.pool.Pool):
    &#34;&#34;&#34;Permet de faire des pool de pool.&#34;&#34;&#34;
    def __init__(self, *args, **kwargs):
        kwargs[&#34;context&#34;] = NoDaemonContext()
        super(NestablePool, self).__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>multiprocessing.pool.Pool</li>
</ul>
</dd>
<dt id="laue.OrderedExperiment"><code class="flex name class">
<span>class <span class="ident">OrderedExperiment</span></span>
<span>(</span><span>*args, position, time=&lt;function OrderedExperiment.&lt;lambda&gt;&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.experiment.ordered_experiment.OrderedExperiment" href="experiment/ordered_experiment.html#laue.experiment.ordered_experiment.OrderedExperiment">OrderedExperiment</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OrderedExperiment(Experiment):
    &#34;&#34;&#34;
    ** Permet de travailler sur un lot ordonne d&#39;images. **
    &#34;&#34;&#34;
    def __init__(self, *args, position, time=(lambda ind: .0*ind), **kwargs):
        &#34;&#34;&#34;
        Parameters
        ----------
        time : callable
            Fonction qui a tout indice de diagrame (int)
            Associe le temps ecoule depuis le debut de l&#39;experience (float).
            Les indices commencent a 0 inclu.
        position : callable
            Fonction qui a tout indice de diagrame (int)
            Associe la position en x et en y du diagrame
            correspondant. Les indices commencent a 0 inclu.

        *args
            Same as ``laue.experiment.base_experiment.Experiment.__init__``.
        **kwargs
            Same as ``laue.experiment.base_experiment.Experiment.__init__``.
        &#34;&#34;&#34;
        assert hasattr(position, &#34;__call__&#34;), &#34;&#39;position&#39; has to be callable.&#34;
        assert hasattr(time, &#34;__call__&#34;), &#34;&#39;time&#39; has to be a callable.&#34;
        
        Experiment.__init__(self, *args, **kwargs)

        self.time = time
        self.position = position

        # Memory attrs.
        self._next_row = 0
        self._t_min, self._t_max = None, None
        self._x_min, self._x_max = None, None
        self._y_min, self._y_max = None, None
        self._t_dict, self._x_dict, self._y_dict = {}, {}, {}
        self._index = None

    def _full_update(self, i_max=None):
        &#34;&#34;&#34;
        ** Met a jour les tables. **

        Les elements sont calcules jusqu&#39;a ``self[i_max]`` inclu.
        &#34;&#34;&#34;
        if i_max is None:
            i_max = len(self._buff_diags)-1
        for current_row in range(self._next_row, i_max+1):
            self._update(current_row)
            self._next_row = current_row + 1

    def _update(self, i):
        &#34;&#34;&#34;
        ** Ajoute un elements aux tables de correspondances. **
        &#34;&#34;&#34;
        t, (x, y) = self.time(i), self.position(i)

        self._t_dict[t] = self._t_dict.get(t, set()) | {i}
        self._x_dict[x] = self._x_dict.get(x, set()) | {i}
        self._y_dict[y] = self._y_dict.get(y, set()) | {i}

        self._t_min = min(self._t_min, t) if self._t_min is not None else t
        self._t_max = min(self._t_max, t) if self._t_max is not None else t
        self._x_min = min(self._x_min, x) if self._x_min is not None else x
        self._x_max = min(self._x_max, x) if self._x_max is not None else x
        self._y_min = min(self._y_min, y) if self._y_min is not None else y
        self._y_max = min(self._y_max, y) if self._y_max is not None else y

    def get_shape(self):
        &#34;&#34;&#34;
        ** Recupere les 2 dimensions x, y. **

        Utilise uniquement la fonction ``position`` fourni a l&#39;initialisateur.

        Returns
        -------
        x : int
            Le nombre de diagrames sur l&#39;axe x.
        y : int
            Le nombre de diagrames pris selon l&#39;axe y.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; def get_positions(i):
        ...     i_mod = i % 3362
        ...     return divmod(i_mod, 82)
        ...
        &gt;&gt;&gt; exp = laue.OrderedExperiment((None,), position=get_positions)
        &gt;&gt;&gt; exp.get_shape()
        (41, 82)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def is_first():
            &#34;&#34;&#34;Renvoie True si on a fini le cycle.&#34;&#34;&#34;
            x, y = self.position(self._next_row)
            return bool(self._x_dict.get(x, set()) &amp; self._y_dict.get(y, set()))

        while not is_first():
            self._full_update(self._next_row)

        return len(self._x_dict), len(self._y_dict)

    def get_index(self):
        &#34;&#34;&#34;
        ** Recupere la matrice des index d&#39;une couche. **

        Utilise uniquement la fonction ``position`` fourni a l&#39;initialisateur.

        Returns
        -------
        np.ndarray
            La matrice 2d ayant le role d&#39;une fonction de N**2 dans N.
            A couple de rang (x, y) associ le rang &#39;ravel&#39; du diagrame.

        Examples
        --------
        &gt;&gt;&gt; import laue

        Cas balayage.
        &gt;&gt;&gt; def get_position(i):
        ...     i_mod = i % 12
        ...     return divmod(i_mod, 4)
        ...
        &gt;&gt;&gt; experiment = laue.OrderedExperiment((None,), position=get_position)
        &gt;&gt;&gt; experiment.get_index()
        array([[ 0,  1,  2,  3],
               [ 4,  5,  6,  7],
               [ 8,  9, 10, 11]], dtype=uint32)
        &gt;&gt;&gt;

        Cas non conventionel
        &gt;&gt;&gt; def get_position(i):
        ...     x = [0, 1, 1, 2, 2, 0, 2, 1, 0, 1, 0, 2]
        ...     y = [0, 2, 3, 1, 0, 2, 2, 0, 1, 1, 3, 3]
        ...     return x[i%12], y[i%12]
        ...
        &gt;&gt;&gt; experiment = laue.OrderedExperiment((None,), position=get_position)
        &gt;&gt;&gt; experiment.get_index()
        array([[ 0,  8,  5, 10],
               [ 7,  9,  1,  2],
               [ 4,  3,  6, 11]], dtype=uint32)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def min_inter(a, b, x_ind, y_ind):
            inter = a &amp; b
            if self.ignore_errors:
                return min(inter, default=np.nan)
            if not inter:
                raise ValueError(f&#34;pour la {x_ind+1}eme coordonnee sur x&#34;
                                 f&#34;et la {y_ind+1}eme coordonnee sur y, &#34;
                                  &#34;aucun numero de diagrame n&#39;est fournis &#34;
                                  &#34;par la fonction ``self.position``.&#34;) from err
            return min(a &amp; b)

        if self._index is not None:
            return self._index

        x, y = self.get_shape()
        self._index = np.array([[
                    min_inter(ind_x_set, ind_y_set, x_ind, y_ind)
                    for y_ind, ind_y_set
                    in sorted(self._y_dict.items(), key=lambda t: t[0])]
                for x_ind, ind_x_set
                in sorted(self._x_dict.items(), key=lambda t: t[0])],
            dtype=np.uint32)
        return self._index

    def __getitem__(self, item):
        &#34;&#34;&#34;
        ** Recupere un diagrame ou un tenseur de diagrames. **

        Retourne le ou les diagrames de type ``laue.diagram.LaueDiagram``.

        Parameters
        ----------
        item
            Il faut voir cette experience comme un tableau
            numpy a 3 dimensions. La premiere est associee au temps,
            la seconde a l&#39;axe x et la derniere a l&#39;axe y.

        Returns
        -------
        diagrams
            * Si seul 1 dimension est precisee, cette methode se refere a
            la methode ``laue.experiment.base_experiment.Experiment.__getitem__``.
            * Si les 3 coordonnees sont entieres, le diagrame
            correspondant est renvoye.
            * Si l&#39;une des 3 coordonnees au moins est un slice, une array
            numpy dimension 3 est renvoyee.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = (np.zeros(shape=(2, 2), dtype=np.uint16)
        ...     for _ in range(120)) # Image generator.
        &gt;&gt;&gt; def get_position(i):
        ...     i_mod = i % 12
        ...     return divmod(i_mod, 4)
        ...
        &gt;&gt;&gt; experiment = laue.OrderedExperiment(images, position=get_position)
        &gt;&gt;&gt;

        Acces directe simple.
        &gt;&gt;&gt; experiment[0]
        LaueDiagram(name=&#39;image_0&#39;)
        &gt;&gt;&gt; experiment[1]
        LaueDiagram(name=&#39;image_1&#39;)
        &gt;&gt;&gt; experiment[1:10:3]
        [LaueDiagram(name=&#39;image_1&#39;), LaueDiagram(name=&#39;image_4&#39;), LaueDiagram(name=&#39;image_7&#39;)]

        Acces directe organise.
        &gt;&gt;&gt; experiment[0, 0, 0]
        LaueDiagram(name=&#39;image_0&#39;)
        &gt;&gt;&gt; experiment[2, 3, 0]
        LaueDiagram(name=&#39;image_11&#39;)
        &gt;&gt;&gt;

        Acces slice
        &gt;&gt;&gt; experiment[:2, 1:3, 0]
        array([[[LaueDiagram(name=&#39;image_1&#39;)],
                [LaueDiagram(name=&#39;image_2&#39;)]],
        &lt;BLANKLINE&gt;
               [[LaueDiagram(name=&#39;image_5&#39;)],
                [LaueDiagram(name=&#39;image_6&#39;)]]], dtype=object)
        &gt;&gt;&gt; experiment[0, 0, 2:5]
        array([[[LaueDiagram(name=&#39;image_24&#39;), LaueDiagram(name=&#39;image_36&#39;),
                 LaueDiagram(name=&#39;image_48&#39;)]]], dtype=object)
        &gt;&gt;&gt; experiment[::-1, :2, -1]
        array([[[LaueDiagram(name=&#39;image_116&#39;)],
                [LaueDiagram(name=&#39;image_117&#39;)]],
        &lt;BLANKLINE&gt;
               [[LaueDiagram(name=&#39;image_112&#39;)],
                [LaueDiagram(name=&#39;image_113&#39;)]],
        &lt;BLANKLINE&gt;
               [[LaueDiagram(name=&#39;image_108&#39;)],
                [LaueDiagram(name=&#39;image_109&#39;)]]], dtype=object)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if isinstance(item, (slice, int, np.integer)):
            return super().__getitem__(item)

        if not isinstance(item, tuple):
            raise ValueError(&#34;La clef doit etre de type, int, slice or tuple &#34;
                f&#34;not {type(item).__name__}.&#34;)
        if len(item) != 3:
            raise ValueError(&#34;Si l&#39;element est un tuple, il doit contenir 3 &#34;
                f&#34; elements. x, y et t. Il en contient {len(item)}.&#34;)
        x, y, t = item
        size = np.prod(self.get_shape(), dtype=np.uint32)

        if all(isinstance(coord, (int, np.integer)) for coord in item):
            return super().__getitem__(self.get_index()[x, y] + t*size)

        x_index = np.arange(self.get_shape()[0])[x] if isinstance(x, slice) else [x]
        y_index = np.arange(self.get_shape()[1])[y] if isinstance(y, slice) else [y]
        if isinstance(t, slice): # Si il est pas nescessaire de lire tous les diagrames.
            if (    (t.start is None or t.start &gt;= 0)
                and (t.stop is not None and t.stop &gt; 0)
                and (t.step is None or t.step &gt; 0)
                ) or ( # cas croissant ou cas decroissant
                    (t.start is not None and t.start &gt; 0)
                and (t.stop is None or t.stop &gt;= 0)
                and (t.step is not None and t.step &lt; 0)):
                t_max = max(
                    (0 if t.stop is None else t.stop), # Cas croissant.
                    (0 if t.start is None else t.start)) # Cas decroissant.
            else:
                if len(self) == 0: # Si il faut lire tous les diagrames.
                    for _ in self:
                        pass
                t_max = (len(self) // np.prod(self.get_shape())) - 1
            t_index = np.arange(t_max+1)[t]
        else:
            t_index = [t]

        table = np.empty((len(x_index), len(y_index), len(t_index)), dtype=object)
        table[...] = [[[
                    self[x_, y_, t_]
                    for t_ in t_index
                ]
                for y_ in y_index
            ]
            for x_ in x_index
        ]
        return table</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="laue.experiment.base_experiment.Experiment" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment">Experiment</a></li>
<li><a title="laue.utilities.serialization.ExperimentPickleable" href="utilities/serialization.html#laue.utilities.serialization.ExperimentPickleable">ExperimentPickleable</a></li>
<li>laue.utilities.serialization.OrderedExperimentPickleable</li>
<li><a title="laue.utilities.data_consistency.Recordable" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable">Recordable</a></li>
<li>threading.Thread</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="laue.experiment.base_experiment.Experiment" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment">Experiment</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.experiment.base_experiment.Experiment.__enter__" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.__enter__">__enter__</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.__getitem__" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.__getitem__">__getitem__</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.__getstate__" href="utilities/serialization.html#laue.utilities.serialization.ExperimentPickleable.__getstate__">__getstate__</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.__iter__" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.__iter__">__iter__</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.__len__" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.__len__">__len__</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.__setstate__" href="utilities/serialization.html#laue.utilities.serialization.ExperimentPickleable.__setstate__">__setstate__</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.find_subsets" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.find_subsets">find_subsets</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.find_zone_axes" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.find_zone_axes">find_zone_axes</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.get_diagrams" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.get_diagrams">get_diagrams</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.get_images_shape" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.get_images_shape">get_images_shape</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.get_mean" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.get_mean">get_mean</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.kill" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.kill">kill</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.read_images" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.read_images">read_images</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.run" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.run">run</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.save_file" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.save_file">save_file</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.save_state" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.save_state">save_state</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.set_calibration" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.set_calibration">set_calibration</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.start" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable.start">start</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="laue.RecallingIterator"><code class="flex name class">
<span>class <span class="ident">RecallingIterator</span></span>
<span>(</span><span>base_iterator, *, mother=None, buff_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.multi_core.RecallingIterator" href="utilities/multi_core.html#laue.utilities.multi_core.RecallingIterator">RecallingIterator</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecallingIterator:
    &#34;&#34;&#34;
    ** Permet d&#39;iterer plusieurs instances d&#39;un unique generateur. **

    Examples
    --------
    Example avec une classe.
    &gt;&gt;&gt; from laue.utilities.multi_core import RecallingIterator
    &gt;&gt;&gt;
    &gt;&gt;&gt; class Foo:
    ...     def __init__(self):
    ...         self.it = iter(range(5))
    ...     def __iter__(self):
    ...         yield from RecallingIterator(self.it, mother=self)
    ...
    &gt;&gt;&gt; foo = Foo()
    &gt;&gt;&gt; for a, b in zip(foo, foo):
    ...     a, b
    ... 
    (0, 0)
    (1, 1)
    (2, 2)
    (3, 3)
    (4, 4)
    &gt;&gt;&gt; list(foo)
    [0, 1, 2, 3, 4]
    &gt;&gt;&gt;

    Example sans classe
    &gt;&gt;&gt; it = iter(range(5))
    &gt;&gt;&gt; for a, b in zip(RecallingIterator(it), RecallingIterator(it)):
    ...     a, b
    ... 
    (0, 0)
    (1, 1)
    (2, 2)
    (3, 3)
    (4, 4)
    &gt;&gt;&gt; list(RecallingIterator(it))
    [0, 1, 2, 3, 4]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def __init__(self, base_iterator, *, mother=None, buff_name=None):
        &#34;&#34;&#34;
        Paremeters
        ----------
        base_iterator : iterator
            L&#39;iterateur epuisable, qui ne doit en tout et pour tout
            etre parcouru qu&#39;une seule fois.
        mother : object (optional)
            Instance de la classe dans laquelle on met cet iterateur.
            Si il est omis, la memoire est globale et ne sera pas netoyee
            par le ramasse-miette. Il est conseille si possible fournir &#39;mother&#39;.
        buff_name : str (optional)
            Si il est precise, c&#39;est le nom de la variable du buffer.
        &#34;&#34;&#34;
        self.mother = mother
        self.base_iterator = base_iterator
        signature = hashlib.md5(id(base_iterator).to_bytes(16, &#34;big&#34;)).hexdigest()

        self.stape = 0 # Le rang de l&#39;element suivant a ceder.

        # Mise en place du verrou.
        lock_name = f&#34;_lock_{signature}&#34;
        if self.mother is not None:
            if not hasattr(self.mother, lock_name):
                setattr(self.mother, lock_name, multiprocessing.Lock())
            self.lock = getattr(self.mother, lock_name)
        else:
            if lock_name not in globals():
                globals()[lock_name] = multiprocessing.Lock()
            self.lock = globals()[lock_name]

        # Mise en place de la memoire pour reiterer.
        buffer_name = f&#34;_buffer_recalling_{signature}&#34; if buff_name is None else buff_name
        if self.mother is not None:
            if not hasattr(self.mother, buffer_name):
                setattr(self.mother, buffer_name, [])
            self.buffer = getattr(self.mother, buffer_name)
        else:
            if buffer_name not in globals():
                globals()[buffer_name] = []
            self.buffer = globals()[buffer_name]

    def __iter__(self):
        &#34;&#34;&#34;
        ** Permet d&#39;etre mis dans une boucle for. **
        &#34;&#34;&#34;
        return self

    def __next__(self):
        &#34;&#34;&#34;
        ** Itere de facon intrementale. **

        Raises
        ------
        StopIteration
            Quand tous les paquets sont cedes.
        &#34;&#34;&#34;
        with self.lock:
            # Si il ne faut pas iterer &#39;base_iterator&#39;
            if self.stape &lt; len(self.buffer):
                self.stape += 1
                return self.buffer[self.stape-1]

            # Si il faut iterer.
            while True:
                try:
                    element = next(self.base_iterator)
                except ValueError: # precisement: generator already executing
                    time.sleep(.1) # On attend 100 ms avant de retenter.
                else:
                    self.buffer.append(element)
                    self.stape += 1
                    return element</code></pre>
</details>
</dd>
<dt id="laue.Recordable"><code class="flex name class">
<span>class <span class="ident">Recordable</span></span>
<span>(</span><span>saving_file='experiment_state', compress=False, dt=600, **_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.data_consistency.Recordable" href="utilities/data_consistency.html#laue.utilities.data_consistency.Recordable">Recordable</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Recordable(threading.Thread):
    &#34;&#34;&#34;
    ** Interface asynchrone gerant la persistance des donnees. **
    &#34;&#34;&#34;
    def __init__(self, saving_file=&#34;experiment_state&#34;, compress=False, dt=600, **_kwargs):
        &#34;&#34;&#34;
        ** Initialise le gestionaire d&#39;enregistrement. **

        Dans le cas ou l&#39;etat de l&#39;ancienne session de travail
        est fournis en parametre, les element de la nouvelle experience
        sont mis a jour.

        Parameters
        ----------
        saving_file : str
            Le path du fichier dans lequel sera enregistre l&#39;etat de l&#39;experience.
        compress : boolean
            Si True, compresse les donnees avec l&#39;algorithme gzip. Cela utilise
            plus de CPU mais reduit un peu la taille des donnees a ecrire.
        dt : number
            Le temps qui separe 2 enregistrements (en secondes).
        &#34;&#34;&#34;
        assert isinstance(saving_file, str), f&#34;&#39;file&#39; has to be of type str, not {type(saving_file).__name__}.&#34;
        assert isinstance(compress, bool), \
            f&#34;&#39;compress&#39; has to be of type bool, not {type(compress).__name__}.&#34;
        assert isinstance(dt, numbers.Number), f&#34;&#39;dt&#39; has to be a number, not a {type(dt).__name__}.&#34;
        assert dt &gt; 0, f&#34;Le temps vaut {dt}.&#34;

        self.saving_file = saving_file
        self.compress = compress
        self.dt = dt

        self._must_die = False

        threading.Thread.__init__(self)

        if os.path.exists(self.saving_file):
            self._load()

    def __enter__(self):
        &#34;&#34;&#34;
        ** Gestionaire de contexte. **

        Demarre l&#39;activite du thread.

        Examples
        --------
        &gt;&gt;&gt; import os, tempfile
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; saving_file = os.path.join(tempfile.mkdtemp(), &#34;state&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; with laue.experiment.base_experiment.Experiment(image, saving_file=saving_file, verbose=2) as experiment:
        ...     pass
        ...
        Starting the thread.
        The thread says: I was just born.
        Sends the thread the order to succumb...
        Recording of the current status...
            OK: the state of the experiment is recorded.
        The thread says: Oh help! I&#39;m dying!
            the thread is killed.
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        self.start()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.kill()

    def __del__(self):
        try:
            if self.is_alive():
                self.kill()
        except AssertionError:
            pass

    def kill(self):
        &#34;&#34;&#34;
        ** Stop the thread activity. **
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Sends the thread the order to succumb...&#34;)
        self._must_die = True
        while self.is_alive():
            time.sleep(.1)
        if self.verbose:
            print(&#34;    the thread is killed.&#34;)

    def run(self):
        &#34;&#34;&#34;
        ** Enregistre indefiniment l&#39;etat de l&#39;experience. **

        Cette methode ne doit pas etre appelee directement car elle
        est bloquante. Pour l&#39;executer en tache de fond il faut invoquer
        ``laue.utilities.data_consistency.Recordable.start``. Ou bien
        l&#39;instanceier via un gestionaire de contexte.
        &#34;&#34;&#34;
        def pause(dt):
            ti = time.time()
            while not self._must_die and time.time() - ti &lt; dt:
                time.sleep(0.01)

        if self.verbose &gt;= 2:
            print(&#34;The thread says: I was just born.&#34;)

        while not self._must_die:
            pause(self.dt)
            self.save_state()

        if self.verbose &gt;= 2:
            print(&#34;The thread says: Oh help! I&#39;m dying!&#34;)

    def start(self):
        &#34;&#34;&#34;
        ** Demarre l&#39;activite du thread. **

        Elle doit etre appelee au maximum une fois par objet thread.
        Elle fait en sorte que la methode run()
        de l&#39;objet soit invoquee dans un thread de controle separe.

        Cette methode declenchera une RuntimeError si elle
        est appelee plus d&#39;une fois sur le meme objet thread.
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Starting the thread.&#34;)
        super().start()

    def _load(self):
        &#34;&#34;&#34;
        ** Met a jour l&#39;etat de l&#39;experience a partir du fichier. **
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Updating the current state...&#34;)
        with open(self.saving_file, &#34;rb&#34;) as f:
            compress = f.read(1)
            if compress == b&#34;\x00&#34;:
                state = pickle.load(f)
            elif compress == b&#34;\x01&#34;:
                from gzip import decompress
                state = pickle.loads(decompress(f.read()))
            else:
                raise ValueError(r&#34;Le fichier doit commencer par b&#39;\x00&#39; ou b&#39;\x01&#39;.&#34;
                    f&#34;Or il commence par {compress}.&#34;)
        self.__setstate__(state)
        if self.verbose:
            print(&#34;    OK: the attributes are updated&#34;)

    def save_state(self):
        &#34;&#34;&#34;
        ** Enregistre l&#39;etat courant. **
        &#34;&#34;&#34;
        if self.verbose &gt;= 2:
            print(&#34;Recording of the current status...&#34;)
        state = self.__getstate__()
        with open(self.saving_file, &#34;wb&#34;) as f:
            if self.compress:
                from gzip import compress
                f.write(b&#34;\x01&#34;)
                f.write(compress(pickle.dumps(state)))
            else:
                f.write(b&#34;\x00&#34;)
                pickle.dump(state, f)
        if self.verbose &gt;= 2:
            print(&#34;    OK: the state of the experiment is recorded.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="laue.experiment.base_experiment.Experiment" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment">Experiment</a></li>
</ul>
</dd>
<dt id="laue.TimeCost"><code class="flex name class">
<span>class <span class="ident">TimeCost</span></span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.utilities.lambdify.TimeCost" href="utilities/lambdify.html#laue.utilities.lambdify.TimeCost">TimeCost</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeCost:
    &#34;&#34;&#34;
    ** Estime le cout d&#39;une expression. **
    &#34;&#34;&#34;
    def __init__(self):
        self.costs = {}

        self._zero = np.zeros(shape=(1000, 1000))
        self._one = np.ones(shape=(1000, 1000))
        self._false = self._zero.astype(bool)
        self._true = self._one.astype(bool)
        self._negone = -self._one
        self._two = 2.0*self._one
        self._bat = .32267452*self._one
        self._comp = (1.0 + 1.0j)*self._one

        self._tests = {
            &#34;Abs&#34;: (lambda: np.abs(self._negone)),
            &#34;Add&#34;: (lambda: self._bat + self._bat),
            &#34;And&#34;: (lambda: self._true &amp; self._true),
            &#34;BooleanTrue&#34;: (lambda: self._one.astype(bool)),
            &#34;Equality&#34;: (lambda: self._bat == self._bat),
            &#34;GreaterThan&#34;: (lambda: self._one &gt;= self._one),
            &#34;LessThan&#34;: (lambda: self._one &lt;= self._one),
            &#34;MatAdd&#34;: (lambda: self._bat + self._bat),
            &#34;MatMul&#34;: (lambda: self._bat @ self._bat),
            &#34;MatPow&#34;: (lambda: self._bat ** self._bat),
            &#34;Max&#34;: (lambda: np.max(self._one)),
            &#34;Min&#34;: (lambda: np.min(self._one)),
            &#34;Mod&#34;: (lambda: self._one % self._bat),
            &#34;Mul&#34;: (lambda: self._bat * self._bat),
            &#34;Nand&#34;: (lambda: not np.all(self._true)),
            &#34;Nor&#34;: (lambda: not np.any(self._false)),
            &#34;Not&#34;: (lambda: ~ self._true),
            &#34;Or&#34;: (lambda: self._false | self._false),
            &#34;Piecewise&#34;: (lambda: ... if True else ...),
            &#34;Pow&#34;: (lambda: self._two ** self._bat),
            &#34;StrictGreaterThan&#34;: (lambda: self._one &gt; self._one),
            &#34;StrictLessThan&#34;: (lambda: self._one &lt; self._one),
            &#34;Transpose&#34;: (lambda: np.transpose(self._zero)),
            &#34;Unequality&#34;: (lambda: self._bat != self._bat),
            &#34;Xor&#34;: (lambda: (self._false|self._true) &amp; ~(self._false&amp;self._true)),
            &#34;acos&#34;: (lambda: np.arccos(self._bat)),
            &#34;acosh&#34;: (lambda: np.arccosh(self._two)),
            &#34;arg&#34;: (lambda: np.angle(self._comp)),
            &#34;asin&#34;: (lambda: np.arcsin(self._bat)),
            &#34;asinh&#34;: (lambda: np.arcsinh(self._bat)),
            &#34;atan&#34;: (lambda: np.arctan(self._bat)),
            &#34;atan2&#34;: (lambda: np.arctan2(self._bat, self._one)),
            &#34;atanh&#34;: (lambda: np.arctanh(self._bat)),
            &#34;conjugate&#34;: (lambda: np.conjugate(self._comp)),
            &#34;cos&#34;: (lambda: np.cos(self._bat)),
            &#34;cosh&#34;: (lambda: np.cosh(self._bat)),
            &#34;exp&#34;: (lambda: np.exp(self._bat)),
            &#34;im&#34;: (lambda: np.imag(self._comp)),
            &#34;log&#34;: (lambda: np.log(self._bat)),
            &#34;re&#34;: (lambda: np.real(self._comp)),
            &#34;sign&#34;: (lambda: np.sign(self._bat)),
            &#34;sin&#34;: (lambda: np.sin(self._bat)),
            &#34;sinc&#34;: (lambda: np.sinc(self._bat)),
            &#34;sinh&#34;: (lambda: np.sinh(self._bat)),
            &#34;sqrt&#34;: (lambda: np.sqrt(self._bat)),
            &#34;tan&#34;: (lambda: np.tan(self._bat)),
            &#34;tanh&#34;: (lambda: np.tanh(self._bat)),
            &#34;eval&#34;: (lambda: np.float64(&#34;0.123456789e+01&#34;)),
            &#34;aloc&#34;: (lambda: np.zeros(shape=(1000, 1000))),
            &#34;div&#34;: (lambda: 1/self._bat),
            &#34;**2&#34;: (lambda: self._bat**2),
        }

        self.load_save()

    def load_save(self):
        &#34;&#34;&#34;
        Charge le fichier qui contient les resultats.
        &#34;&#34;&#34;
        dirname = os.path.join(os.path.dirname(os.path.abspath(laue.__file__)), &#34;data&#34;)
        file = os.path.join(dirname, &#34;timecost.pickle&#34;)
        if os.path.exists(file):
            with open(file, &#34;rb&#34;) as f:
                self.__setstate__(pickle.load(f))
        else:
            with open(file, &#34;wb&#34;) as f:
                pickle.dump(self.__getstate__(), f)

    def atom_cost(self, key):
        &#34;&#34;&#34;
        Retourne le cout de l&#39;opperateur.
        &#34;&#34;&#34;
        if key in self.costs:
            return self.costs[key]
        if hasattr(self, &#34;_tests&#34;):
            if key in self._tests:
                self.costs[key] = timeit.timeit(self._tests[key], number=100)
                return self.costs[key]
        raise ValueError(f&#34;L&#39;opperation {key} est inconnue.&#34;)

    def branch_cost(self, branch):
        &#34;&#34;&#34;
        Le cout brut de l&#39;expression sympy sans cse.
        &#34;&#34;&#34;
        if isinstance(branch, (sympy.Atom, numbers.Number)):
            return self.atom_cost(&#34;eval&#34;)

        if isinstance(branch, (sympy.Add, sympy.And, sympy.MatAdd, sympy.MatMul,
                sympy.MatPow, sympy.Mul, sympy.Nand, sympy.Nor, sympy.Or, sympy.Xor)):
            op_cost = self.atom_cost(type(branch).__name__) * (len(branch.args)-1)
            return sum((self.branch_cost(e) for e in branch.args)) + op_cost

        if isinstance(branch, sympy.Pow):
            if isinstance(branch.exp, sympy.Number):
                if branch.exp == 2:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;**2&#34;)
                if branch.exp == sympy.S.Half:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;sqrt&#34;)
                if branch.exp == -sympy.S.Half:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;sqrt&#34;)
                if branch.exp == -sympy.S.One:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;)
                if branch.exp == -2:
                    return self.branch_cost(branch.base) + self.atom_cost(&#34;div&#34;) + self.atom_cost(&#34;**2&#34;)
            return self.branch_cost(branch.base) + self.branch_cost(branch.exp) + self.atom_cost(&#34;Pow&#34;)

        if isinstance(branch, sympy.Piecewise):
            op_cost = self.atom_cost(&#34;Piecewise&#34;) * (len(branch.args)-1)
            return sum(
                self.branch_cost(val) + sum(self.branch_cost(a) for a in cond.args)
                for val, cond in branch.args) + op_cost

        return sum((self.branch_cost(e) for e in branch.args)) + self.atom_cost(type(branch).__name__)

    def __call__(self, expr):
        &#34;&#34;&#34;
        Le cout de l&#39;expression avec cse.
        &#34;&#34;&#34;
        defs, rvs = sympy.cse(expr)
        return (sum(self.branch_cost(e) for var, e in defs)
              + sum(self.branch_cost(e) for e in rvs)
              + len(defs)*self.atom_cost(&#34;aloc&#34;))

    def __getstate__(self):
        if hasattr(self, &#34;_tests&#34;):
            for key in self._tests:
                self.atom_cost(key)
        return self.costs

    def __setstate__(self, state):
        self.costs = state</code></pre>
</details>
</dd>
<dt id="laue.Transformer"><code class="flex name class">
<span>class <span class="ident">Transformer</span></span>
<span>(</span><span>verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias vers <code><a title="laue.core.geometry.transformer.Transformer" href="core/geometry/transformer.html#laue.core.geometry.transformer.Transformer">Transformer</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transformer(TransformerPickleable, Compilator):
    &#34;&#34;&#34;
    Permet d&#39;effectuer des transformations geometrique comme jongler
    entre l&#39;espace de la camera et l&#39;espace gnomonique ou encore
    s&#39;ammuser avec la transformee de Hough.
    &#34;&#34;&#34;
    def __init__(self, verbose=False):
        Compilator.__init__(self, verbose=verbose) # Globalisation des expressions.
        self.verbose = verbose

        # Les memoires tampon.
        self._fcts_cam_to_gnomonic = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(x_cam, y_cam), les parametres sont deja remplaces.
        self._fcts_gnomonic_to_cam = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(x_gnom, y_gnom), les parametres sont deja remplaces.
        self._fcts_cam_to_thetachi = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(x_cam, y_cam), les parametres sont deja remplaces.
        self._fcts_thetachi_to_cam = collections.defaultdict(lambda: 0) # Fonctions vectorisees avec seulement f(theta, chi), les parametres sont deja remplaces.
        self._parameters_memory = {} # Permet d&#39;eviter de relire le dictionaire des parametres a chaque fois.

    def compile(self, parameters=None, *, transform=None):
        &#34;&#34;&#34;
        ** Precalcul toutes les equations. **

        Parameters
        ----------
        parameters : dict, optional
            Les parametres donnes par la fonction ``laue.utilities.parsing.extract_parameters``.
            Si ils sont fourni, l&#39;expression est encore un peu
            plus optimisee.
        transform : str
            La fonction qu&#39;il faut particulierement optimiser. Si ce parametre n&#39;est
            pas fournis, toutes les fonctions sont optimisees.
            Peut prendre les valeurs: ``&#34;cam_to_gnomonic&#34;``, ``&#34;gnomonic_to_cam&#34;``,
            ``&#34;cam_to_thetachi&#34;`` ou ``&#34;thetachi_to_cam&#34;``.
        &#34;&#34;&#34;
        if parameters is not None:
            assert isinstance(parameters, dict), (&#34;Les parametres doivent founis &#34;
                f&#34;dans un dictionaire, pas dans un {type(parameters).__name__}&#34;)
            assert set(parameters) == {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;pixelsize&#34;}, \
                (&#34;Les clefs doivent etres &#39;dd&#39;, &#39;xbet&#39;, &#39;xgam&#39;, &#39;xcen&#39;, &#39;ycen&#39; et &#39;pixelsize&#39;. &#34;
                f&#34;Or les clefs sont {set(parameters)}.&#34;)
            assert all(isinstance(v, numbers.Number) for v in parameters.values()), \
                &#34;La valeurs des parametres doivent toutes etre des nombres.&#34;

            if transform is not None:
                assert isinstance(transform, str), f&#34;Doit etre str, pas {type(transform).__name__}.&#34;
                assert transform in {&#34;cam_to_gnomonic&#34;, &#34;gnomonic_to_cam&#34;,
                    &#34;cam_to_thetachi&#34;, &#34;thetachi_to_cam&#34;}, f&#34;Ne doit pas etre {transform}.&#34;

            hash_param = self._hash_parameters(parameters)
            constants = {self.dd: parameters[&#34;dd&#34;], # C&#39;est qu&#39;il est tant de faire de l&#39;optimisation.
                         self.xcen: parameters[&#34;xcen&#34;],
                         self.ycen: parameters[&#34;ycen&#34;],
                         self.xbet: parameters[&#34;xbet&#34;],
                         self.xgam: parameters[&#34;xgam&#34;],
                         self.pixelsize: parameters[&#34;pixelsize&#34;]}
            # Dans le cas ou l&#39;expression est deserialise, les pointeurs ne sont plus les memes.
            constants = {str(var): value for var, value in constants.items()}
            for trans, args in {
                    &#34;cam_to_gnomonic&#34;: (self.x_cam, self.y_cam),
                    &#34;gnomonic_to_cam&#34;: (self.x_gnom, self.y_gnom),
                    &#34;cam_to_thetachi&#34;: (self.x_cam, self.y_cam),
                    &#34;thetachi_to_cam&#34;: (self.theta, self.chi)
                    }.items():
                if transform is not None and trans != transform:
                    continue
                formal_expr = getattr(self, f&#34;get_fct_{trans}&#34;)()()
                subs = {symbol: constants[str(symbol)]
                    for symbol in set.union(*(e.free_symbols for e in formal_expr))
                    if str(symbol) in constants}
                getattr(self, f&#34;_fcts_{trans}&#34;)[hash_param] = lambdify.Lambdify(
                    args=args,
                    expr=lambdify.subs(formal_expr, subs))

    def cam_to_gnomonic(self, pxl_x, pxl_y, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points de la camera dans un plan gnomonic. **

        Parameters
        ----------
        pxl_x : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe x dans le repere de la camera. (en pxl)
        pxl_y : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe y dans le repere de la camera. (en pxl)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic exprimee.s en mm.
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.cam_to_gnomonic(x_cam, y_cam, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.cam_to_gnomonic(x_cam, y_cam, parameters, dtype=np.float64), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.cam_to_gnomonic(0.0, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
        ...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.cam_to_gnomonic(x_cam, y_cam, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;cam_to_gnomonic&#34;, pxl_x, pxl_y,
            parameters=parameters, dtype=dtype)

    def cam_to_thetachi(self, pxl_x, pxl_y, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points de la camera vers la representation theta et chi. **

        Parameters
        ----------
        pxl_x : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe x dans le repere de la camera. (en pxl)
        pxl_y : float, int ou np.ndarray
            Coordonnee.s du.des pxl.s selon l&#39;axe y dans le repere de la camera. (en pxl)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s theta puis chi du.des point.s. (en deg)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_cam, y_cam = np.linspace(3, 2048, 6), np.linspace(3, 2048, 6)
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters))
        array([[ 64.,  60.,  51.,  39.,  30.,  26.],
               [ 49.,  35.,  13., -13., -35., -49.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.cam_to_thetachi(x_cam, y_cam, parameters, dtype=np.float64))
        array([[ 64.,  60.,  51.,  39.,  30.,  26.],
               [ 49.,  35.,  13., -13., -35., -49.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.cam_to_thetachi(0.0, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(0, 2048, size=(1, 2, 3)),
        ...                 np.random.uniform(0, 2048, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.cam_to_thetachi(x_cam, y_cam, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;cam_to_thetachi&#34;, pxl_x, pxl_y,
            parameters=parameters, dtype=dtype)

    def dist_cosine(self, theta_1, chi_1, theta_2, chi_2, *, dtype=np.float64):
        r&#34;&#34;&#34;
        ** Calcul les cosine-distances entre les familles de spot 1 et 2. **

        La distance entre 2 vecteurs est definie de la facon suivante:
        \[ \arccos{\left(\frac{\vec{u_1}.\vec{u_1}}{\left\|\vec{u_1}\right\|.\left\|\vec{u_2}\right\|}\right)} \]

        Parameters
        ----------
        theta_1 : np.ndarray
            Les angles theta des spots de la premiere famille. (en degre)
            shape = ``(*shape_fam_1)``
        chi_1 : np.ndarray
            Les angles chi des spots de la premiere famille. (en degre)
            shape = ``(*shape_fam_1)``
        theta_2 : np.ndarray
            Les angles theta des spots de la second famille. (en degre)
            shape = ``(*shape_fam_2)``
        chi_2 : np.ndarray
            Les angles chi des spots de la seconde famille. (en degre)
            shape = ``(*shape_fam_2)``
        dtype : type, optional
            La representation machine des nombres.
            Attention pour les calculs en float32, les arrondis
            risquent d&#39;etre importants.

        Returns
        -------
        np.ndarray
            Les cosine-distances entre les 2 familles de vecteurs. (en degre)
            shape = ``(*shape_fam_1, *shape_fam_2)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt;
        &gt;&gt;&gt; theta, chi = np.array([[ 63.605,  59.91 ,  51.367,  38.546,  30.05 ],
        ...                        [ 49.403,  34.97 ,  13.062, -13.248, -35.102]])
        &gt;&gt;&gt; np.round(transformer.dist_cosine(theta, chi, theta, chi), 5)
        array([[ 0.     ,  7.74103, 22.58762, 44.11754, 60.96129],
               [ 7.74103,  0.     , 14.91692, 36.82838, 54.46589],
               [22.58762, 14.91692,  0.     , 22.40912, 41.26854],
               [44.11754, 36.82838, 22.40912,  0.     , 19.88537],
               [60.96129, 54.46589, 41.26854, 19.88537,  0.     ]])
        &gt;&gt;&gt; transformer.dist_cosine(theta, chi, theta, chi, dtype=np.float16).dtype
        dtype(&#39;float16&#39;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; theta_1, chi_1 = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
        ...                   np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
        &gt;&gt;&gt; theta_2, chi_2 = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(3, 4, 5)),
        ...                   np.random.uniform(-np.pi/4, np.pi/4, size=(3, 4, 5)))
        &gt;&gt;&gt; transformer.dist_cosine(theta_1, chi_1, theta_2, chi_2).shape
        (1, 2, 3, 3, 4, 5)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(theta_1, np.ndarray), \
            f&#34;&#39;theta_1&#39; has to be of type np.ndarray, not {type(theta_1).__name__}.&#34;
        assert isinstance(chi_1, np.ndarray), \
            f&#34;&#39;chi_1&#39; has to be of type np.ndarray, not {type(chi_1).__name__}.&#34;
        assert theta_1.shape == chi_1.shape, \
            f&#34;Les 2 parametres de droite doivent avoir la meme taille: {theta_1.shape} vs {chi_1.shape}.&#34;
        assert isinstance(theta_2, np.ndarray), \
            f&#34;&#39;theta_2&#39; has to be of type np.ndarray, not {type(theta_2).__name__}.&#34;
        assert isinstance(chi_2, np.ndarray), \
            f&#34;&#39;chi_2&#39; has to be of type np.ndarray, not {type(chi_2).__name__}.&#34;
        assert theta_2.shape == chi_2.shape, \
            f&#34;Les 2 coordonnees des points doivent avoir la meme shape: {theta_2.shape} vs {chi_2.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        shape1, shape2 = theta_1.shape, theta_2.shape
        theta_1, theta_2 = np.meshgrid(theta_1.astype(dtype, copy=False), theta_2.astype(dtype, copy=False), indexing=&#34;ij&#34;, copy=False)
        chi_1, chi_2 = np.meshgrid(chi_1.astype(dtype, copy=False), chi_2.astype(dtype, copy=False), indexing=&#34;ij&#34;, copy=False)
        theta_1, chi_1 = theta_1.reshape((*shape1, *shape2)), chi_1.reshape((*shape1, *shape2))
        theta_2, chi_2 = theta_2.reshape((*shape1, *shape2)), chi_2.reshape((*shape1, *shape2))

        func = self.get_fct_dist_cosine()
        return np.nan_to_num(func(theta_1, chi_1, theta_2, chi_2), copy=False, nan=0.0)

    def dist_euclidian(self, x1, y1, x2, y2, *, dtype=np.float32):
        r&#34;&#34;&#34;
        ** Calcul les distances euclidiennes entre les familles de vecteur 1 et 2. **

        La distance entre 2 vecteurs est definie de la facon suivante:
        \[ \left\|\vec{u_1} - \vec{u_2}\right\| \]

        Parameters
        ----------
        x1 : np.ndarray
            Les coordonnees x des vecteurs de la premiere famille.
            shape = ``(*shape_fam_1)``
        y1 : np.ndarray
            Les coordonnees y des vecteurs de la premiere famille.
            shape = ``(*shape_fam_1)``
        x2 : np.ndarray
            Les coordonnees x des vecteurs de la seconde famille.
            shape = ``(*shape_fam_2)``
        y2 : np.ndarray
            Les coordonnees y des vecteurs de la seconde famille.
            shape = ``(*shape_fam_2)``
        dtype : type, optional
            La representation machine des nombres. Comme le calcul
            est simple et n&#39;engendre pas de gros arrondi, faire
            les calculs en float32 n&#39;est pas delirant.

        Returns
        -------
        np.ndarray
            Les distances entre les 2 familles de vecteurs.
            shape = ``(*shape_fam_1, *shape_fam_2)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt;
        &gt;&gt;&gt; x, y = np.linspace(-1, 1, 5), np.linspace(-1, 1, 5)
        &gt;&gt;&gt; transformer.dist_euclidian(x, y, x, y)
        array([[0.        , 0.70710677, 1.4142135 , 2.1213202 , 2.828427  ],
               [0.70710677, 0.        , 0.70710677, 1.4142135 , 2.1213202 ],
               [1.4142135 , 0.70710677, 0.        , 0.70710677, 1.4142135 ],
               [2.1213202 , 1.4142135 , 0.70710677, 0.        , 0.70710677],
               [2.828427  , 2.1213202 , 1.4142135 , 0.70710677, 0.        ]],
              dtype=float32)
        &gt;&gt;&gt; transformer.dist_euclidian(x, y, x, y, dtype=np.float16)
        array([[0.   , 0.707, 1.414, 2.121, 2.828],
               [0.707, 0.   , 0.707, 1.414, 2.121],
               [1.414, 0.707, 0.   , 0.707, 1.414],
               [2.121, 1.414, 0.707, 0.   , 0.707],
               [2.828, 2.121, 1.414, 0.707, 0.   ]], dtype=float16)
        &gt;&gt;&gt;
        &gt;&gt;&gt; x1, y1 = np.random.normal(size=(1, 2, 3)), np.random.normal(size=(1, 2, 3))
        &gt;&gt;&gt; x2, y2 = np.random.normal(size=(3, 4, 5)), np.random.normal(size=(3, 4, 5))
        &gt;&gt;&gt; transformer.dist_euclidian(x1, y1, x2, y2).shape
        (1, 2, 3, 3, 4, 5)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(x1, np.ndarray), \
            f&#34;&#39;x1&#39; has to be of type np.ndarray, not {type(x1).__name__}.&#34;
        assert isinstance(y1, np.ndarray), \
            f&#34;&#39;y1&#39; has to be of type np.ndarray, not {type(y1).__name__}.&#34;
        assert x1.shape == y1.shape, \
            f&#34;Les 2 parametres de droite doivent avoir la meme taille: {x1.shape} vs {y1.shape}.&#34;
        assert isinstance(x2, np.ndarray), \
            f&#34;&#39;x2&#39; has to be of type np.ndarray, not {type(x2).__name__}.&#34;
        assert isinstance(y2, np.ndarray), \
            f&#34;&#39;y2&#39; has to be of type np.ndarray, not {type(y2).__name__}.&#34;
        assert x2.shape == y2.shape, \
            f&#34;Les 2 coordonnees des points doivent avoir la meme shape: {x2.shape} vs {y2.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        shape1, shape2 = x1.shape, x2.shape
        x1, x2 = np.meshgrid(x1.astype(dtype, copy=False), x2.astype(dtype, copy=False), indexing=&#34;ij&#34;, copy=False)
        y1, y2 = np.meshgrid(y1.astype(dtype, copy=False), y2.astype(dtype, copy=False), indexing=&#34;ij&#34;, copy=False)
        x1, y1 = x1.reshape((*shape1, *shape2)), y1.reshape((*shape1, *shape2))
        x2, y2 = x2.reshape((*shape1, *shape2)), y2.reshape((*shape1, *shape2))

        func = self.get_fct_dist_euclidian()
        return func(x1, y1, x2, y2)

    def dist_line(self, phi_vect, mu_vect, x_vect, y_vect, *, dtype=np.float64):
        &#34;&#34;&#34;
        ** Calcul les distances projetees des points sur une droite. **

        Parameters
        ----------
        phi_vect : np.ndarray
            Les angles des droites normales aux droites principales.
            shape = ``(*nbr_droites)``
        mu_vect : np.ndarray
            Les distances entre les droites et l&#39;origine.
            shape = ``(*nbr_droites)``
        x_vect : np.ndarray
            L&#39;ensemble des coordonnees x des points.
            shape = ``(*nbr_points)``
        y_vect : np.ndarray
            L&#39;ensemble des coordonnees y des points.
            shape = ``(*nbr_points)``
        dtype : type, optional
            La representation machine des nombres.
            Attention pour les calculs en float32 et moins
            risque d&#39;y avoir des arrondis qui engendrent:
            ``RuntimeWarning: invalid value encountered in sqrt``.

        Returns
        -------
        np.ndarray
            Les distances des projetees des points sur chacunes des droites.
            shape = ``(*nbr_droites, *nbr_points)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt;
        &gt;&gt;&gt; lines = (np.array([0, np.pi/2]), np.array([1, 1])) # Horizontale et verticale passant par (1, 1)
        &gt;&gt;&gt; points = (np.array([0, 1, 3, 0]), np.array([0, 1, 3, 1])) # Le points (0, 1), ...
        &gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points))
        array([[1., 0., 2., 1.],
               [1., 0., 2., 0.]])
        &gt;&gt;&gt; np.round(transformer.dist_line(*lines, *points, dtype=np.float32))
        array([[1., 0., 2., 1.],
               [1., 0., 2., 0.]], dtype=float32)
        &gt;&gt;&gt;
        &gt;&gt;&gt; phi_vect, mu_vect = np.random.normal(size=(1, 2)), np.random.normal(size=(1, 2))
        &gt;&gt;&gt; x_vect, y_vect = np.random.normal(size=(3, 4, 5)), np.random.normal(size=(3, 4, 5))
        &gt;&gt;&gt; transformer.dist_line(phi_vect, mu_vect, x_vect, y_vect).shape
        (1, 2, 3, 4, 5)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(phi_vect, np.ndarray), \
            f&#34;&#39;phi_vect&#39; has to be of type np.ndarray, not {type(phi_vect).__name__}.&#34;
        assert isinstance(mu_vect, np.ndarray), \
            f&#34;&#39;mu_vect&#39; has to be of type np.ndarray, not {type(mu_vect).__name__}.&#34;
        assert phi_vect.shape == mu_vect.shape, \
            f&#34;Les 2 parametres de droite doivent avoir la meme taille: {phi_vect.shape} vs {mu_vect.shape}.&#34;
        assert isinstance(x_vect, np.ndarray), \
            f&#34;&#39;x_vect&#39; has to be of type np.ndarray, not {type(x_vect).__name__}.&#34;
        assert isinstance(y_vect, np.ndarray), \
            f&#34;&#39;y_vect&#39; has to be of type np.ndarray, not {type(y_vect).__name__}.&#34;
        assert x_vect.shape == y_vect.shape, \
            f&#34;Les 2 coordonnees des points doivent avoir la meme shape: {x_vect.shape} vs {y_vect.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        phi_vect, mu_vect = phi_vect.astype(dtype, copy=False), mu_vect.astype(dtype, copy=False)
        x_vect, y_vect = x_vect.astype(dtype, copy=False), y_vect.astype(dtype, copy=False)

        nbr_droites = phi_vect.shape
        nbr_points = x_vect.shape

        # Ca ne vaut pas le coup de paralleliser car c&#39;est tres rapide.
        func = self.get_fct_dist_line()
        result = np.array([func(phi, mu, x_vect, y_vect)
                           for phi, mu
                           in zip(phi_vect.ravel(), mu_vect.ravel())
                          ], dtype=dtype).reshape((*nbr_droites, *nbr_points))
        return np.nan_to_num(result, copy=False, nan=0.0)

    def gnomonic_to_cam(self, gnom_x, gnom_y, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points du plan gnomonic vers la camera. **

        Parameters
        ----------
        gnom_x : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe x du repere du plan gnomonic. (en mm)
        gnom_y : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe y du repere du plan gnomonic. (en mm)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        coords : np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
        ...                              0.09978235,  0.17156848,  0.13417314 ],
        ...                            [ 0.40283853,  0.31846303,  0.14362221, 
        ...                             -0.18308422, -0.58226374, -0.93854752 ]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_cam(x_gnom, y_gnom, parameters, dtype=np.float64))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.gnomonic_to_cam(0.0, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
        ...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.gnomonic_to_cam(x_cam, y_cam, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;gnomonic_to_cam&#34;, gnom_x, gnom_y,
            parameters=parameters, dtype=dtype)

    def gnomonic_to_thetachi(self, gnom_x, gnom_y, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe des points du plan gnomonic vers theta et chi. **

        Parameters
        ----------
        gnom_x : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe x du repere du plan gnomonic. (en mm)
        gnom_y : float ou np.ndarray
            Coordonnee.s du.des point.s selon l&#39;axe y du repere du plan gnomonic. (en mm)
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s theta puis chi du.des point.s. (en deg)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; x_gnom, y_gnom = np.array([[-0.51176567, -0.35608186, -0.1245152 ,
        ...                              0.09978235,  0.17156848,  0.13417314 ],
        ...                            [ 0.40283853,  0.31846303,  0.14362221, 
        ...                             -0.18308422, -0.58226374, -0.93854752 ]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom))
        array([[ 64.,  60.,  51.,  39.,  30.,  26.],
               [ 49.,  35.,  13., -13., -35., -49.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.gnomonic_to_thetachi(x_gnom, y_gnom, dtype=np.float64))
        array([[ 64.,  60.,  51.,  39.,  30.,  26.],
               [ 49.,  35.,  13., -13., -35., -49.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.gnomonic_to_thetachi(0.0, 0.0).shape
        (2,)
        &gt;&gt;&gt; x_cam, y_cam = (np.random.uniform(-.1, .1, size=(1, 2, 3)),
        ...                 np.random.uniform(-.1, .1, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.gnomonic_to_thetachi(x_cam, y_cam).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;gnomonic_to_thetachi&#34;, gnom_x, gnom_y,
            parameters=None, dtype=dtype)

    def hough(self, x_vect, y_vect, *, dtype=np.float64):
        r&#34;&#34;&#34;
        ** Transformee de hough avec des droites. **

        Note
        ----
        * Pour des raisons de performances, les calculs se font sur des float32.
        * Les indices sont agences selon l&#39;ordre defini par la fonction ``comb2ind``.

        Parameters
        ----------
        x_vect : np.ndarray
            L&#39;ensemble des coordonnees x des points de shape: (*over_dims, nbr_points)
        y_vect : np.ndarray
            L&#39;ensemble des coordonnees y des points de shape: (*over_dims, nbr_points)
        dtype : type, optional
            La representation machine des nombres.
            Attention pour les calculs en float32 et moins
            risque d&#39;y avoir des arrondis qui engendrent:
            ``RuntimeWarning: invalid value encountered in sqrt``.

        Returns
        -------
        np.ndarray
            * phi : np.ndarray
                * Les angles au sens trigomometrique des vecteurs reliant l&#39;origine
                ``O`` (0, 0) au point ``P`` appartenant a la droite tel que ``||OP||``
                soit la plus petite possible.
                * phi â‚¬ ]-pi, pi]
                * shape = ``(*over_dims, n*(n-1)/2)``
            * lamb : np.ndarray
                * Ce sont les normes des vecteur ``OP``.
                * lamb â‚¬ [0, +oo].
                * shape = ``(*over_dims, n*(n-1)/2)``
            * Ces 2 grandeurs sont concatenees dans une seule array de
        shape = ``(2, *over_dims, n*(n-1)/2)``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry import transformer
        &gt;&gt;&gt; transformer = transformer.Transformer()
        &gt;&gt;&gt; x, y = np.random.normal(size=(2, 6))
        &gt;&gt;&gt; transformer.hough(x, y).shape
        (2, 15)
        &gt;&gt;&gt;
        &gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
        &gt;&gt;&gt; transformer.hough(x, y).shape
        (2, 4, 5, 15)
        &gt;&gt;&gt; 
        &#34;&#34;&#34;
        assert isinstance(x_vect, np.ndarray), \
            f&#34;&#39;x_vect&#39; has to be of type np.ndarray, not {type(x_vect).__name__}.&#34;
        assert isinstance(y_vect, np.ndarray), \
            f&#34;&#39;y_vect&#39; has to be of type np.ndarray, not {type(y_vect).__name__}.&#34;
        assert x_vect.shape == y_vect.shape, \
            f&#34;Les 2 entrees doivent avoir la meme taille: {x_vect.shape} vs {y_vect.shape}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        n = x_vect.shape[-1]
        if n == 1:
            over_dims = x_vect.shape[:-1]
            clusters = np.empty(np.prod(over_dims, dtype=int), dtype=object)
            clusters[:] = [[] for _ in range(clusters.size)]
            clusters = clusters.reshape(over_dims)
            return clusters
        
        x_vect, y_vect = x_vect.astype(dtype, copy=False), y_vect.astype(dtype, copy=False)

        xa = np.concatenate([np.repeat(x_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        ya = np.concatenate([np.repeat(y_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        xb = np.concatenate([x_vect[..., i+1:] for i in range(n-1)], axis=-1)
        yb = np.concatenate([y_vect[..., i+1:] for i in range(n-1)], axis=-1)

        return np.nan_to_num(
            np.stack(self.get_fct_hough()(xa, ya, xb, yb)),
            copy=False,
            nan=0.0)

    def hough_reduce(self, phi_vect, mu_vect, *, nbr=4, tol=0.018, dtype=np.float32):
        &#34;&#34;&#34;
        ** Regroupe des droites ressemblantes. **

        Notes
        -----
        * Cette methode est concue pour traiter les donnees issues de ``laue.core.geometry.transformer.Transformer.hough``.
        * La metrique utilise est la distance euclidiene sur un cylindre ferme sur phi.
        * En raison de performance et de memoire, les calculs se font sur des float32.

        Parameters
        ----------
        phi_vect : np.ndarray
            * Vecteur des angles compris entre [-pi, pi].
            * shape = ``(*over_dims, nbr_inter)``
        mu_vect : np.ndarray
            * Vecteur des distances des droites a l&#39;origine comprises [0, +oo].
            * shape = ``(*over_dims, nbr_inter)``
        tol : float
            La distance maximal separant 2 points dans l&#39;espace de hough reduit,
            (ie la difference entre 2 droites dans l&#39;espace spacial) tel que les points
            se retrouvent dans le meme cluster. Plus ce nombre est petit, plus les points
            doivent etre bien alignes. C&#39;est une sorte de tolerance sur l&#39;alignement.
        nbr : int
            C&#39;est le nombre minimum de points presque alignes pour que
            l&#39;on puisse considerer la droite qui passe par ces points.
            Par defaut, les droites qui ne passent que par 4 points et plus sont retenues.
        dtype : type, optional
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64``.
            ``np.float128`` est interdit car c&#39;est un peu over-kill pour cette methode!

        Returns
        -------
        np.ndarray(dtype=float), np.ndarray(dtype=object)
            * Ce sont les centres des clusters pour chaque &#39;nuages de points&#39;. Cela correspond
            aux angles et aux distances qui caracterisent chaque droites.
            * Si les parametres d&#39;entres sont des vecteurs 1d, le resultat sera une array
            numpy contenant les **angles** puis les **distances**. Donc de shape = ``(2, nbr_clusters)``
            * Si les parametres d&#39;entres sont en plusieur dimensions, (representes plusieur
            nuages de points indepandant), alors le resultat sera une array d&#39;objet de
            shape = ``(*over_dims)``. Chaque objet est lui meme un array, resultat recursif
            de l&#39;appel de cette fonction sur le nuage de points unique correspondant.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry import transformer
        &gt;&gt;&gt; transformer = transformer.Transformer()

        Type de retour ``float`` vs ``object``.
        &gt;&gt;&gt; x, y = (np.array([ 1.,  2.,  3.,  0., -1.]),
        ...         np.array([ 0.,  1.,  1., -1.,  1.]))
        &gt;&gt;&gt; phi, mu = transformer.hough(x, y)
        &gt;&gt;&gt; np.round(transformer.hough_reduce(phi, mu, nbr=3), 2)
        array([[-0.79,  1.57],
               [ 0.71,  1.  ]], dtype=float32)
        &gt;&gt;&gt; res = transformer.hough_reduce(phi.reshape((1, -1)), mu.reshape((1, -1)), nbr=3)
        &gt;&gt;&gt; res.dtype
        dtype(&#39;O&#39;)
        &gt;&gt;&gt; res.shape
        (1,)
        &gt;&gt;&gt; np.round(res[0], 2)
        array([[-0.79,  1.57],
               [ 0.71,  1.  ]], dtype=float32)
        &gt;&gt;&gt;

        Les dimensions de retour.
        &gt;&gt;&gt; x, y = (np.random.normal(size=(6, 5, 4)),
        ...         np.random.normal(size=(6, 5, 4)))
        &gt;&gt;&gt; phi, mu = transformer.hough(x, y)
        &gt;&gt;&gt; transformer.hough_reduce(phi, mu).shape
        (6, 5)
        &gt;&gt;&gt; 
        &#34;&#34;&#34;
        assert isinstance(phi_vect, np.ndarray), \
            f&#34;&#39;phi_vect&#39; has to be of type np.ndarray, not {type(phi_vect).__name__}.&#34;
        assert isinstance(mu_vect, np.ndarray), \
            f&#34;&#39;mu_vect&#39; has to be of type np.ndarray, not {type(mu_vect).__name__}.&#34;
        assert phi_vect.shape == mu_vect.shape, \
            f&#34;Les 2 entrees doivent avoir la meme taille: {phi_vect.shape} vs {mu_vect.shape}.&#34;
        assert phi_vect.ndim &gt;= 1, &#34;La matrice ne doit pas etre vide.&#34;
        assert isinstance(tol, float), f&#34;&#39;tol&#39; has to be a float, not a {type(tol).__name__}.&#34;
        assert 0.0 &lt; tol &lt;= 0.5, (&#34;Les valeurs coherentes de &#39;tol&#39; se trouvent entre &#34;
            f&#34;]0, 1/2], or tol vaut {tol}, ce qui sort de cet intervalle.&#34;)
        assert isinstance(nbr, int), f&#34;&#39;nbr&#39; has to be an integer, not a {type(nbr).__name__}.&#34;
        assert 2 &lt; nbr, f&#34;2 points sont toujours alignes! Vous ne pouvez pas choisir nbr={nbr}.&#34;
        assert dtype in {np.float16, np.float32, np.float64}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64. Pas {dtype}.&#34;

        # On fait la conversion des le debut pour un gain de temps.
        phi_vect, mu_vect = phi_vect.astype(dtype, copy=False), mu_vect.astype(dtype, copy=False)

        *over_dims, nbr_inter = phi_vect.shape # Recuperation des dimensions.
        nbr = (nbr*(nbr-1))/2 # On converti le nombre de points alignes en nbr de segments.

        # On commence par travailler avec les donnees reduites.
        phi_theo_std = math.pi / math.sqrt(3) # Variance theorique = (math.pi - -math.pi)**2 / 12
        mu_std = np.nanstd(mu_vect, axis=-1) # Ecart type non biaise (sum(*over_dims)/N), shape: (*over_dims)
        mu_vect = (mu_vect * phi_theo_std
            / np.repeat(mu_std[..., np.newaxis], nbr_inter, axis=-1)) # Les distances quasi reduites.
        
        # Extraction des clusters.
        if not len(over_dims): # Cas des tableaux 1d.
            return self._clustering_1d(phi_vect, mu_vect, mu_std, tol, nbr)

        clusters = np.empty(np.prod(over_dims, dtype=int), dtype=object) # On doit d&#39;abord creer un tableau d&#39;objet 1d.
        if multiprocessing.current_process().name == &#34;MainProcess&#34; and np.prod(over_dims) &gt;= os.cpu_count(): # Si ca vaut le coup de parraleliser:
            ser_self = cloudpickle.dumps(self) # Strategie car &#39;pickle&#39; ne sais pas faire ca.
            from laue.utilities.multi_core import pickleable_method
            with multiprocessing.Pool() as pool:
                clusters[:] = pool.map(
                    pickleable_method, # Car si il y a autant de cluster dans chaque image,
                    (                   # numpy aurait envi de faire un tableau 2d plutot qu&#39;un vecteur de listes.
                        (
                            Transformer._clustering_1d,
                            ser_self,
                            {&#34;phi_vect_1d&#34;:phi, &#34;mu_vect_1d&#34;:mu, &#34;std&#34;:std, &#34;tol&#34;:tol, &#34;nbr&#34;:nbr}
                        )
                        for phi, mu, std
                        in zip(
                            phi_vect.reshape((-1, nbr_inter)),
                            mu_vect.reshape((-1, nbr_inter)),
                            np.nditer(mu_std)
                        )
                    )
                )
        else:
            clusters[:] = [self._clustering_1d(chi, mu, std, tol, nbr)
                           for chi, mu, std in zip(
                                    phi_vect.reshape((-1, nbr_inter)),
                                    mu_vect.reshape((-1, nbr_inter)),
                                    np.nditer(mu_std))] 
        clusters = clusters.reshape(over_dims) # On redimensione a la fin de sorte a garentir les dimensions.

        return clusters

    def inter_lines(self, phi_vect, mu_vect, *, dtype=np.float32):
        r&#34;&#34;&#34;
        ** Calcul les points d&#39;intersection entre les droites. **

        Notes
        -----
        * Cette methode est concue pour traiter les donnees issues de ``laue.core.geometry.transformer.Transformer.hough``.
        * En raison de performance et de memoire, les calculs se font sur des float32.
        * Les indices sont agences selon l&#39;ordre defini par la fonction ``comb2ind``.

        Parameters
        ----------
        phi_vect : np.ndarray
            * Vecteur des angles compris entre [-pi, pi].
            * shape = (*over_dims, nbr_droites)
        mu_vect : np.ndarray
            * Vecteur des distances des droites a l&#39;origine comprises [0, +oo].
            * shape = (*over_dims, nbr_droites)
        dtype : type, optional
            La representation machine des nombres. Par defaut
            ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser
            ``np.float64`` ou ``(getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)``.

        Returns
        -------
        np.ndarray
            * Dans le dommaine spatial et non pas le domaine de hough, cherche
            les intersections des droites. Il y a ``n*(n-1)/2`` intersections, n etant
            le nombre de droites. donc la complexite de cette methode est en ``o(n**2)``.
            * Si les vecteurs d&#39;entre sont des vecteurs 1d (ie ``*over_dims == ()``), 
            Seront retournes le vecteur d&#39;intersection selon l&#39;axe x et le vecteur
            des intersections selon l&#39;axe y. Ces 2 vecteurs de meme taille sont concatenes
            sous la forme d&#39;une matrice de shape = ``(2, n*(n-1)/2)``.
            * Si les vecteurs d&#39;entre sont en plusieurs dimensions, seul les droites de la
            derniere dimensions se retrouvent dans la meme famille. Tous comme pour les
            vecteurs 1d, on trouve d&#39;abord les intersections selon x puis en suite selon y.
            La shape du tenseur final est donc: ** shape = ``(2, *over_dims, n*(n-1)/2)`` **.

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; np.random.seed(0)
        &gt;&gt;&gt; x, y = np.random.normal(size=(2, 4, 5, 6))
        &gt;&gt;&gt; phi, mu = transformer.hough(x, y)
        &gt;&gt;&gt; phi.shape
        (4, 5, 15)
        &gt;&gt;&gt; transformer.inter_lines(phi, mu).shape
        (2, 4, 5, 105)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        assert isinstance(phi_vect, np.ndarray), \
            f&#34;&#39;phi_vect&#39; has to be of type np.ndarray, not {type(phi_vect).__name__}.&#34;
        assert isinstance(mu_vect, np.ndarray), \
            f&#34;&#39;mu_vect&#39; has to be of type np.ndarray, not {type(mu_vect).__name__}.&#34;
        assert phi_vect.shape == mu_vect.shape, \
            f&#34;Les 2 entrees doivent avoir la meme taille: {phi_vect.shape} vs {mu_vect.shape}.&#34;
        assert phi_vect.ndim &gt;= 1, &#34;La matrice ne doit pas etre vide.&#34;
        assert phi_vect.shape[-1] &gt;= 2, \
            f&#34;Il doit y avoir au moins 2 droites par famille, pas {phi_vect.shape[-1]}.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        phi_vect, mu_vect = phi_vect.astype(dtype, copy=False), mu_vect.astype(dtype, copy=False)
        n = phi_vect.shape[-1]

        phi_1 = np.concatenate([np.repeat(phi_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        mu_1 = np.concatenate([np.repeat(mu_vect[..., i, np.newaxis], n-i-1, axis=-1) for i in range(n-1)], axis=-1)
        phi_2 = np.concatenate([phi_vect[..., i+1:] for i in range(n-1)], axis=-1)
        mu_2 = np.concatenate([mu_vect[..., i+1:] for i in range(n-1)], axis=-1)

        return np.stack(self.get_fct_inter_line()(phi_1, mu_1, phi_2, mu_2))

    def thetachi_to_cam(self, theta, chi, parameters, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe de la representation theta et chi vers la camera. **

        Parameters
        ----------
        theta : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de y. (en deg)
        chi : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de x. (en deg)
        parameters : dict
            Le dictionaire issue de la fonction ``laue.utilities.parsing.extract_parameters``.
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        coords : np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan de la camera. (en pxl)
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; from laue.utilities.parsing import extract_parameters
        &gt;&gt;&gt; parameters = extract_parameters(dd=70, bet=.0, gam=.0, size=.08, x0=1024, y0=1024)
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; theta, chi = np.array([[ 63.605,  59.91 ,  51.367,  38.546,  30.05 ,  26.378],
        ...                        [ 49.403,  34.97 ,  13.062, -13.248, -35.102, -49.486]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.thetachi_to_cam(theta, chi, parameters))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.thetachi_to_cam(theta, chi, parameters, dtype=np.float64))
        array([[   3.,  412.,  821., 1230., 1639., 2048.],
               [   3.,  412.,  821., 1230., 1639., 2048.]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.thetachi_to_cam(np.pi/4, 0.0, parameters).shape
        (2,)
        &gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
        ...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.thetachi_to_cam(theta, chi, parameters).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;thetachi_to_cam&#34;, theta, chi,
            parameters=parameters, dtype=dtype)

    def thetachi_to_gnomonic(self, theta, chi, *, dtype=np.float32):
        &#34;&#34;&#34;
        ** Passe de la representation theta et chi vers une projection gnomonique. **

        Parameters
        ----------
        theta : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de y. (en deg)
        chi : float ou np.ndarray
            Coordonnee.s du.des angle.s de rotation autour de x. (en deg)
        dtype : type, optional
            Si l&#39;entree est un nombre et non pas une array numpy. Les calculs sont fait en ``float``.
            La representation machine des nombres. Par defaut ``np.float32`` permet des calculs rapide
            mais peu precis. Pour la presision il faut utiliser ``np.float64`` ou ``np.float128``.

        Returns
        -------
        float ou np.ndarray
            * Le.s coordonnee.s x puis y du.des point.s dans le plan gnomonic exprimee.s en mm.
            * shape = (2, *shape_d_entree)

        Examples
        -------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
        &gt;&gt;&gt; transformer = Transformer()
        &gt;&gt;&gt; theta, chi = np.array([[ 63.605,  59.91 ,  51.367,  38.546,  30.05 ,  26.378],
        ...                        [ 49.403,  34.97 ,  13.062, -13.248, -35.102, -49.486]])
        &gt;&gt;&gt;

        Output type
        &gt;&gt;&gt; type(transformer.thetachi_to_gnomonic(theta, chi))
        &lt;class &#39;numpy.ndarray&#39;&gt;
        &gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]], dtype=float32)
        &gt;&gt;&gt; np.round(transformer.thetachi_to_gnomonic(theta, chi, dtype=np.float64), 2)
        array([[-0.51, -0.36, -0.12,  0.1 ,  0.17,  0.13],
               [ 0.4 ,  0.32,  0.14, -0.18, -0.58, -0.94]])
        &gt;&gt;&gt;
        
        Output shape
        &gt;&gt;&gt; transformer.thetachi_to_gnomonic(np.pi/4, 0.0).shape
        (2,)
        &gt;&gt;&gt; theta, chi = (np.random.uniform(np.pi/8, 3*np.pi/8, size=(1, 2, 3)),
        ...               np.random.uniform(-np.pi/4, np.pi/4, size=(1, 2, 3)))
        &gt;&gt;&gt; transformer.thetachi_to_gnomonic(theta, chi).shape
        (2, 1, 2, 3)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        return self._generic_transformation(&#34;thetachi_to_gnomonic&#34;, theta, chi,
            parameters=None, dtype=dtype)

    def _clustering_1d(self, phi_vect_1d, mu_vect_1d, std, tol, nbr):
        &#34;&#34;&#34;
        ** Help for hough_reduce. **

        * Permet de trouver les clusters d&#39;un nuage de points.
        * La projection 3d, bien que moins realiste, est 20% plus rapide que la distance reele.
        &#34;&#34;&#34;
        from sklearn.cluster import DBSCAN

        dtype_catser = phi_vect_1d.dtype.type
        PHI_STD = dtype_catser(math.pi / math.sqrt(3))
        WEIGHT = 0.65 # 0 =&gt; tres souple sur les angles, 1=&gt; tres souple sur les distances.

        # On retire les droites aberantes.
        mask_to_keep = np.isfinite(phi_vect_1d) &amp; np.isfinite(mu_vect_1d)
        if not mask_to_keep.any(): # Si il ne reste plus rien.
            return np.array([], dtype=dtype_catser)
        phi_vect_1d, mu_vect_1d = phi_vect_1d[mask_to_keep], mu_vect_1d[mask_to_keep]

        # On passe dans un autre repere de facon a ce que -pi et pi se retrouvent a cote.
        if numexpr is not None:
            phi_x = numexpr.evaluate(&#34;2*WEIGHT*cos(phi_vect_1d)&#34;)
            phi_y = numexpr.evaluate(&#34;2*WEIGHT*sin(phi_vect_1d)&#34;)
        else:
            phi_x, phi_y = 2*WEIGHT*np.cos(phi_vect_1d), 2*WEIGHT*np.sin(phi_vect_1d)

        # Recherche des clusters.
        n_jobs = -1 if multiprocessing.current_process().name == &#34;MainProcess&#34; else 1
        db_res = DBSCAN(eps=tol, min_samples=nbr, n_jobs=n_jobs).fit(
            np.vstack((phi_x, phi_y, 2*(1-WEIGHT)*mu_vect_1d)).transpose())

        # Mise en forme des clusters.
        clusters_dict = collections.defaultdict(lambda: [])
        keep = db_res.labels_ != -1 # Les indices des clusters a garder.
        for x_cyl, y_cyl, mu, group in zip(
                phi_x[keep], phi_y[keep], mu_vect_1d[keep], db_res.labels_[keep]):
            clusters_dict[group].append((x_cyl, y_cyl, mu))

        phi = np.array([np.arccos(cluster[:, 0].mean()/(2*WEIGHT))*np.sign(cluster[:, 1].sum())
                    for cluster in map(np.array, clusters_dict.values())],
                    dtype=dtype_catser)
        mu = np.array([cluster[:, 2].mean()
                        for cluster in map(np.array, clusters_dict.values())],
                    dtype=dtype_catser) * std / PHI_STD
        return np.array([phi, mu], dtype=dtype_catser)

    def _generic_transformation(self, transform, data1, data2, *, parameters, dtype):
        &#34;&#34;&#34;
        ** Passe d&#39;un espace de representation a un autre. **

        Help for ``Transformer.truc_to_machin``.

        Notes
        -----
        Fait les verifications.
        &#34;&#34;&#34;
        assert isinstance(data1, (float, int, np.ndarray)), \
            f&#34;&#39;data1&#39; can not be of type {type(data1).__name__}.&#34;
        assert isinstance(data2, (float, int, np.ndarray)), \
            f&#34;&#39;data2&#39; can not be of type {type(data2).__name__}.&#34;
        assert type(data1) == type(data2), \
            f&#34;Les 2 types sont differents: {type(data1).__name__} vs {type(data2).__name__}.&#34;
        if isinstance(data1, np.ndarray):
            assert data1.shape == data2.shape, \
                f&#34;Ils n&#39;ont pas le meme taille: {data1.shape} vs {data2.shape}.&#34;
        if parameters is not None:
            assert isinstance(parameters, dict), (&#34;Les parametres doivent founis &#34;
                f&#34;dans un dictionaire, pas dans un {type(parameters).__name__}&#34;)
            assert set(parameters) == {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;pixelsize&#34;}, \
                (&#34;Les clefs doivent etres &#39;dd&#39;, &#39;xbet&#39;, &#39;xgam&#39;, &#39;xcen&#39;, &#39;ycen&#39; et &#39;pixelsize&#39;. &#34;
                f&#34;Or les clefs sont {set(parameters)}.&#34;)
            assert all(isinstance(v, numbers.Number) for v in parameters.values()), \
                &#34;La valeurs des parametres doivent toutes etre des nombres.&#34;
        assert dtype in {np.float16, np.float32, np.float64, (getattr(np, &#34;float128&#34;) if hasattr(np, &#34;float128&#34;) else np.float64)}, \
            f&#34;Les types ne peuvent etre que np.float16, np.float32, np.float64, np.float128. Pas {dtype}.&#34;

        if isinstance(data1, np.ndarray):
            data1, data2 = data1.astype(dtype, copy=False), data2.astype(dtype, copy=False)
        else:
            data1, data2 = dtype(data1), dtype(data2)
        
        if parameters is not None:
            parameters = {k: dtype(v) for k, v in parameters.items()} # Pour eviter par la suite de mauvais casts.
            hash_param = self._hash_parameters(parameters) # Recuperation de la &#39;signature&#39; des parametres.
            optimized_func = getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param] # On regarde si il y a une fonction deja optimisee.

            if isinstance(optimized_func, int): # Si il n&#39;y a pas de fonction optimisee.
                nbr_access = optimized_func # Ce qui est enregistre et le nombre de fois que l&#39;on a chercher a y acceder.
                getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param] += 1 # Comme on cherche a y acceder actuelement, on peut incrementer le compteur.
                if nbr_access + 1 == 4: # Si c&#39;est la 4 eme fois qu&#39;on accede a la fonction.
                    self.compile(parameters, transform=transform) # On optimise la fonction.
                else: # Si ce n&#39;est pas encore le moment de perdre du temps a optimiser.
                    return np.stack(getattr(self, f&#34;get_fct_{transform}&#34;)()(
                        data1, data2,
                        parameters[&#34;dd&#34;], parameters[&#34;xcen&#34;], parameters[&#34;ycen&#34;],
                        parameters[&#34;xbet&#34;], parameters[&#34;xgam&#34;], parameters[&#34;pixelsize&#34;]))

            return np.stack(getattr(self, f&#34;_fcts_{transform}&#34;)[hash_param](data1, data2))

        return np.stack(getattr(self, f&#34;get_fct_{transform}&#34;)()(data1, data2))

    def _hash_parameters(self, parameters):
        &#34;&#34;&#34;
        ** Hache le dictionaire des parametres. **

        * Il n&#39;y a pas de verification pour des histoires de performances.

        Parameters
        ----------
        parameters : dict
            Dictionaire des parametres issues de ``laue.utilities.parsing.extract_parameters``.

        Returns
        -------
        int
            Un identifiant tq 2 dictionaires identiques renvoient le meme id.
        &#34;&#34;&#34;
        return hash(( # Il faut imperativement garantir l&#39;ordre.
            parameters[&#34;dd&#34;],
            parameters[&#34;xcen&#34;],
            parameters[&#34;ycen&#34;],
            parameters[&#34;xbet&#34;],
            parameters[&#34;xgam&#34;],
            parameters[&#34;pixelsize&#34;]))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="laue.utilities.serialization.TransformerPickleable" href="utilities/serialization.html#laue.utilities.serialization.TransformerPickleable">TransformerPickleable</a></li>
<li><a title="laue.core.geometry.symbolic.Compilator" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator">Compilator</a></li>
<li><a title="laue.core.geometry.symbolic.Equations" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations">Equations</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="laue.utilities.serialization.TransformerPickleable" href="utilities/serialization.html#laue.utilities.serialization.TransformerPickleable">TransformerPickleable</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.utilities.serialization.TransformerPickleable.__getstate__" href="utilities/serialization.html#laue.utilities.serialization.TransformerPickleable.__getstate__">__getstate__</a></code></li>
<li><code><a title="laue.utilities.serialization.TransformerPickleable.__setstate__" href="utilities/serialization.html#laue.utilities.serialization.TransformerPickleable.__setstate__">__setstate__</a></code></li>
</ul>
</li>
<li><code><b><a title="laue.core.geometry.symbolic.Compilator" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator">Compilator</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_cam_to_uf" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_cam_to_uf">get_expr_cam_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_gnomonic_to_uq" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_gnomonic_to_uq">get_expr_gnomonic_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_thetachi_to_uf" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_thetachi_to_uf">get_expr_thetachi_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uf_to_cam" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uf_to_cam">get_expr_uf_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uf_to_thetachi" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uf_to_thetachi">get_expr_uf_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uf_to_uq" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uf_to_uq">get_expr_uf_to_uq</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uq_to_gnomonic" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uq_to_gnomonic">get_expr_uq_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_expr_uq_to_uf" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Equations.get_expr_uq_to_uf">get_expr_uq_to_uf</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_gnomonic" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_cam_to_gnomonic">get_fct_cam_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_cam_to_thetachi" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_cam_to_thetachi">get_fct_cam_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_dist_cosine" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_dist_cosine">get_fct_dist_cosine</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_dist_euclidian" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_dist_euclidian">get_fct_dist_euclidian</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_dist_line" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_dist_line">get_fct_dist_line</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_cam" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_cam">get_fct_gnomonic_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_thetachi" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_gnomonic_to_thetachi">get_fct_gnomonic_to_thetachi</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_hough" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_hough">get_fct_hough</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_inter_line" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_inter_line">get_fct_inter_line</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_cam" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_cam">get_fct_thetachi_to_cam</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_gnomonic" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.get_fct_thetachi_to_gnomonic">get_fct_thetachi_to_gnomonic</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.load" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.load">load</a></code></li>
<li><code><a title="laue.core.geometry.symbolic.Compilator.save" href="core/geometry/symbolic.html#laue.core.geometry.symbolic.Compilator.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#permet-de-manipuler-un-lot-de-diagrammes-de-laue">Permet de manipuler un lot de diagrammes de laue.</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="laue.core" href="core/index.html">laue.core</a></code></li>
<li><code><a title="laue.diagram" href="diagram.html">laue.diagram</a></code></li>
<li><code><a title="laue.experiment" href="experiment/index.html">laue.experiment</a></code></li>
<li><code><a title="laue.spot" href="spot.html">laue.spot</a></code></li>
<li><code><a title="laue.utilities" href="utilities/index.html">laue.utilities</a></code></li>
<li><code><a title="laue.zone_axis" href="zone_axis.html">laue.zone_axis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laue.atomic_find_subsets" href="#laue.atomic_find_subsets">atomic_find_subsets</a></code></li>
<li><code><a title="laue.atomic_find_zone_axes" href="#laue.atomic_find_zone_axes">atomic_find_zone_axes</a></code></li>
<li><code><a title="laue.atomic_pic_search" href="#laue.atomic_pic_search">atomic_pic_search</a></code></li>
<li><code><a title="laue.cam_to_gnomonic" href="#laue.cam_to_gnomonic">cam_to_gnomonic</a></code></li>
<li><code><a title="laue.cam_to_thetachi" href="#laue.cam_to_thetachi">cam_to_thetachi</a></code></li>
<li><code><a title="laue.comb2ind" href="#laue.comb2ind">comb2ind</a></code></li>
<li><code><a title="laue.create_image" href="#laue.create_image">create_image</a></code></li>
<li><code><a title="laue.dist_cosine" href="#laue.dist_cosine">dist_cosine</a></code></li>
<li><code><a title="laue.dist_euclidian" href="#laue.dist_euclidian">dist_euclidian</a></code></li>
<li><code><a title="laue.dist_line" href="#laue.dist_line">dist_line</a></code></li>
<li><code><a title="laue.extract_parameters" href="#laue.extract_parameters">extract_parameters</a></code></li>
<li><code><a title="laue.gnomonic_to_cam" href="#laue.gnomonic_to_cam">gnomonic_to_cam</a></code></li>
<li><code><a title="laue.gnomonic_to_thetachi" href="#laue.gnomonic_to_thetachi">gnomonic_to_thetachi</a></code></li>
<li><code><a title="laue.hough" href="#laue.hough">hough</a></code></li>
<li><code><a title="laue.hough_reduce" href="#laue.hough_reduce">hough_reduce</a></code></li>
<li><code><a title="laue.images_to_iter" href="#laue.images_to_iter">images_to_iter</a></code></li>
<li><code><a title="laue.ind2comb" href="#laue.ind2comb">ind2comb</a></code></li>
<li><code><a title="laue.inter_lines" href="#laue.inter_lines">inter_lines</a></code></li>
<li><code><a title="laue.limited_imap" href="#laue.limited_imap">limited_imap</a></code></li>
<li><code><a title="laue.pickleable_method" href="#laue.pickleable_method">pickleable_method</a></code></li>
<li><code><a title="laue.prevent_generator_size" href="#laue.prevent_generator_size">prevent_generator_size</a></code></li>
<li><code><a title="laue.read_image" href="#laue.read_image">read_image</a></code></li>
<li><code><a title="laue.reduce_object" href="#laue.reduce_object">reduce_object</a></code></li>
<li><code><a title="laue.thetachi_to_cam" href="#laue.thetachi_to_cam">thetachi_to_cam</a></code></li>
<li><code><a title="laue.thetachi_to_gnomonic" href="#laue.thetachi_to_gnomonic">thetachi_to_gnomonic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code></h4>
</li>
<li>
<h4><code><a title="laue.Lambdify" href="#laue.Lambdify">Lambdify</a></code></h4>
</li>
<li>
<h4><code><a title="laue.NestablePool" href="#laue.NestablePool">NestablePool</a></code></h4>
</li>
<li>
<h4><code><a title="laue.OrderedExperiment" href="#laue.OrderedExperiment">OrderedExperiment</a></code></h4>
</li>
<li>
<h4><code><a title="laue.RecallingIterator" href="#laue.RecallingIterator">RecallingIterator</a></code></h4>
</li>
<li>
<h4><code><a title="laue.Recordable" href="#laue.Recordable">Recordable</a></code></h4>
</li>
<li>
<h4><code><a title="laue.TimeCost" href="#laue.TimeCost">TimeCost</a></code></h4>
</li>
<li>
<h4><code><a title="laue.Transformer" href="#laue.Transformer">Transformer</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>