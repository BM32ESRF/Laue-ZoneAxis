<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>laue API documentation</title>
<meta name="description" content="** Permet de manipuler un lot de diagrammes de laue. **
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>laue</code></h1>
</header>
<section id="section-intro">
<h2 id="permet-de-manipuler-un-lot-de-diagrammes-de-laue"><strong> Permet de manipuler un lot de diagrammes de laue. </strong></h2>
<h2 id="notes">Notes</h2>
<ul>
<li>Pour effectuer les bancs de tests, il faut installer le module <code>pip install pytest</code>.
Il faut ensuite saisir la commande suivante:<ul>
<li><code>clear &amp;&amp; python -m pytest --doctest-modules laue/
&amp;&amp; python -m pytest -vv --exitfirst laue/tests.py &amp;&amp; cat tests_results.txt</code></li>
</ul>
</li>
<li>Pour generer la documentation, il faut installer le module <code>pip install pdoc3</code>.
Il faut ensuite saisir la commande suivante:<ul>
<li><code>pdoc3 laue/ -c latex_math=True --force --html</code></li>
</ul>
</li>
<li>A la premiere execution, les equations sont compilees, ce qui peut metre
plusieurs disaines de minutes. Soyez patients!</li>
</ul>
<h2 id="examples">Examples</h2>
<p>preparation</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt;
</code></pre>
<p>creation d'une experience</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(image)
&gt;&gt;&gt;
&gt;&gt;&gt; experiment
Experiment('laue/examples')
&gt;&gt;&gt;
</code></pre>
<p>recuperation des diagrammes</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; for diag in experiment:
...     print(type(diag))
...
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt;
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;
** Permet de manipuler un lot de diagrammes de laue. **
-------------------------------------------------------

Notes
-----
* Pour effectuer les bancs de tests, il faut installer le module ``pip install pytest``.
    Il faut ensuite saisir la commande suivante:
    * ``clear &amp;&amp; python -m pytest --doctest-modules laue/
        &amp;&amp; python -m pytest -vv --exitfirst laue/tests.py &amp;&amp; cat tests_results.txt``
* Pour generer la documentation, il faut installer le module ``pip install pdoc3``.
    Il faut ensuite saisir la commande suivante:
    * ``pdoc3 laue/ -c latex_math=True --force --html``
* A la premiere execution, les equations sont compilees, ce qui peut metre
    plusieurs disaines de minutes. Soyez patients!

Examples
--------

preparation
&gt;&gt;&gt; import laue
&gt;&gt;&gt;

creation d&#39;une experience
&gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
&gt;&gt;&gt; experiment = laue.Experiment(image)
&gt;&gt;&gt;
&gt;&gt;&gt; experiment
Experiment(&#39;laue/examples&#39;)
&gt;&gt;&gt;

recuperation des diagrammes
&gt;&gt;&gt; for diag in experiment:
...     print(type(diag))
...
&lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
&gt;&gt;&gt;
&#34;&#34;&#34;

__all__ = [&#34;Experiment&#34;, &#34;OrderedExperiment&#34;, &#34;geometry&#34;,
           &#34;atomic_pic_search&#34;, &#34;atomic_find_zone_axes&#34;, &#34;atomic_find_subsets&#34;]
__pdoc__ = {&#34;tests&#34;: False,
            &#34;data&#34;: False,
            &#34;Experiment.__getitem__&#34;: True,
            &#34;Experiment.__iter__&#34;: True,
            &#34;Experiment.__len__&#34;: True,
            &#34;OrderedExperiment.__getitem__&#34;: True}

from laue.experiment.base_experiment import Experiment
from laue.experiment.ordered_experiment import OrderedExperiment
from laue.core import geometry
from laue.core.pic_search import atomic_pic_search
from laue.core.zone_axes import atomic_find_zone_axes
from laue.core.subsets import atomic_find_subsets</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="laue.core" href="core/index.html">laue.core</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="laue.diagram" href="diagram.html">laue.diagram</a></code></dt>
<dd>
<div class="desc"><p><strong> Permet de manipuler un diagramme de Laue unique. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.experiment" href="experiment/index.html">laue.experiment</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="laue.spot" href="spot.html">laue.spot</a></code></dt>
<dd>
<div class="desc"><p><strong> Represente un spot dans un diagramme de Laue. </strong>
…</p></div>
</dd>
<dt><code class="name"><a title="laue.utilities" href="utilities/index.html">laue.utilities</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="laue.zone_axis" href="zone_axis.html">laue.zone_axis</a></code></dt>
<dd>
<div class="desc"><p><strong> Represente un axe de zone. </strong>
…</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="laue.atomic_find_subsets"><code class="name flex">
<span>def <span class="ident">atomic_find_subsets</span></span>(<span>spots_dict, axes_dict, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Fonction 'bas niveau' de separation de grains. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Cette fonction n'est pas faite pour etre utilisee directement,
il vaut mieux s'en servir a travers <code><a title="laue.Experiment.find_subsets" href="#laue.Experiment.find_subsets">Experiment.find_subsets()</a></code>
ou encore via <code><a title="laue.diagram.LaueDiagram.find_subsets" href="core/subsets.html#laue.core.subsets.Splitable.find_subsets">Splitable.find_subsets()</a></code> car le context
est mieu gere, les entrees sont plus simples et les sorties aussi.</li>
<li>Il n'y a pas de verifications sur les entrees car elles sont faite
dans les methodes de plus haut niveau.</li>
<li>Cette fonction n'est pas parallelisee. Par contre la methode
<code><a title="laue.Experiment.find_subsets" href="#laue.Experiment.find_subsets">Experiment.find_subsets()</a></code> gere nativement le parallelisme.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spots_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Une representation des spots et des information minimales
qui y sont raccrochees. Il doit prendre la forme suivante:
<code>{spot_ind: {"gnom": (x_gnom, y_gnom), "axes": {1, 3, ...}}, ...}</code></dd>
<dt><strong><code>axes_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Une representations des axes de zone. Doit etre de la forme:
<code>{axe_ind: {"polar": (theta, dist), "quality": .7, "spots": {1, 4, 5, 6}}, ...}</code></dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Doit au moins contenir les 3 champs <code>angle_max</code>, <code>spots_max</code> et <code>distance_max</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Chaque element est un ensemble d'indice de spot appartenant au meme grain.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; spots_dict = {0: {'gnom': (0.3136510725564478, -0.44091934214920697), 'axes': set()},
...               1: {'gnom': (0.3092269223801162, -0.3703963974694111), 'axes': {0}},
...               2: {'gnom': (0.29464954430652696, 0.39670741889986955), 'axes': {1}},
...               3: {'gnom': (0.30191318963902786, 0.011759364157261544), 'axes': {2}},
...               4: {'gnom': (0.2656586060012433, -0.29892567761860783), 'axes': {0}},
...               5: {'gnom': (0.2537441830952802, 0.32256757073867776), 'axes': {1}},
...               6: {'gnom': (0.259687191990358, 0.011094867051531301), 'axes': {2}},
...               7: {'gnom': (0.21447480004378858, -0.2150686716681864), 'axes': {0}},
...               8: {'gnom': (0.2057015738443993, 0.2356420984106664), 'axes': {1}},
...               9: {'gnom': (0.09095514707222462, -0.5356714822419564), 'axes': {3, 4}},
...               10: {'gnom': (0.06846289051965272, 0.5548594993575858), 'axes': {3, 5}},
...               11: {'gnom': (0.16685972592987006, -0.1362785647833782), 'axes': {0}},
...               12: {'gnom': (0.16092652407854113, 0.15424696872260854), 'axes': {1}},
...               13: {'gnom': (0.0880179013812851, -0.40043047804756454), 'axes': {3}},
...               14: {'gnom': (0.07130573600458438, 0.4174843621463065), 'axes': {3}},
...               15: {'gnom': (0.08639048300887514, -0.31911672107326594), 'axes': {3}},
...               16: {'gnom': (0.07308383568548608, 0.3351760458933546), 'axes': {3}},
...               17: {'gnom': (-0.016567440130016563, -0.5541568143935384), 'axes': {6}},
...               18: {'gnom': (-0.04084781468303007, 0.5689448068249144), 'axes': {7}},
...               19: {'gnom': (0.0011982188252073992, -0.45016007120047424), 'axes': set()},
...               20: {'gnom': (-0.018154025485441625, 0.46402526754308027), 'axes': set()},
...               21: {'gnom': (-0.07286049562681773, -0.5640133440412382), 'axes': set()},
...               22: {'gnom': (0.0798366324753105, 0.007023938379407561), 'axes': {0, 1, 2, 3}},
...               23: {'gnom': (-0.0026903259324252246, 0.3921879524265071), 'axes': {5}},
...               24: {'gnom': (-0.09784778756977644, 0.5766271192972883), 'axes': set()},
...               25: {'gnom': (0.008002458469782677, -0.12293574282766238), 'axes': {1}},
...               26: {'gnom': (0.0027460490484708115, 0.13394781189060836), 'axes': {0}},
...               27: {'gnom': (-0.00523750349077013, -0.1470394198008183), 'axes': {1}},
...               28: {'gnom': (-0.011614516626281228, 0.15777148638160254), 'axes': {0}},
...               29: {'gnom': (-0.02477598980567221, -0.1823836791494654), 'axes': {1}},
...               30: {'gnom': (-0.03264505249777272, 0.19229497060446735), 'axes': {0}},
...               31: {'gnom': (-0.05554717740227801, -0.23832176191125093), 'axes': {1, 4}},
...               32: {'gnom': (-0.06606796372263056, 0.24757266647939288), 'axes': {0, 5}},
...               33: {'gnom': (-0.07907768658950604, -0.28096918114364355), 'axes': {1}},
...               34: {'gnom': (-0.09156428823859053, 0.2893970244445073), 'axes': {0}},
...               35: {'gnom': (-0.1126289846318788, -0.3416241560303849), 'axes': {1, 6}},
...               36: {'gnom': (-0.060637577826655534, 0.0040391083212410655), 'axes': {2}},
...               37: {'gnom': (-0.12787900102974828, 0.3491863530719953), 'axes': {0, 7}},
...               38: {'gnom': (-0.1638208798822865, -0.4347286698438957), 'axes': {1}},
...               39: {'gnom': (-0.18763951100210385, -0.4776573606384503), 'axes': {1}},
...               40: {'gnom': (-0.1835787305562983, 0.4411739247300923), 'axes': {0}},
...               41: {'gnom': (-0.08524649743749545, 0.003436523504335945), 'axes': {2}},
...               42: {'gnom': (-0.2523542667003644, -0.5949096601292776), 'axes': {8, 1}},
...               43: {'gnom': (-0.20958039716029048, 0.4837711867805186), 'axes': {0}},
...               44: {'gnom': (-0.11758167206566646, -0.1123768702642382), 'axes': {4}},
...               45: {'gnom': (-0.12266805447587614, 0.11817207059217111), 'axes': {5}},
...               46: {'gnom': (-0.17376685735949005, 0.0016472083664571353), 'axes': {2, 4, 5}},
...               47: {'gnom': (-0.20724297206742168, -0.25150647771157364), 'axes': set()},
...               48: {'gnom': (-0.19501092265693473, -0.15910834995174863), 'axes': {6}},
...               49: {'gnom': (-0.21870028043714163, 0.25404867230414246), 'axes': set()},
...               50: {'gnom': (-0.2022799134764107, 0.16163477331619278), 'axes': {7}},
...               51: {'gnom': (-0.2581018757728966, -0.3579924435989167), 'axes': {8}},
...               52: {'gnom': (-0.2748170617964089, 0.3596407013965223), 'axes': {8}},
...               53: {'gnom': (-0.21290266125204668, 0.0008346770568725252), 'axes': {2}},
...               54: {'gnom': (-0.21986841578944072, -0.10369811043407293), 'axes': {5, 6}},
...               55: {'gnom': (-0.224622744015843, 0.10503684334781563), 'axes': {4, 7}},
...               56: {'gnom': (-0.25955409478645797, -0.29848728294016463), 'axes': {8}},
...               57: {'gnom': (-0.27338619051240226, 0.299389601118816), 'axes': {8}},
...               58: {'gnom': (-0.3156632165624574, -0.4202358686963255), 'axes': set()},
...               59: {'gnom': (-0.2618304221414466, -0.19929059589121062), 'axes': {8, 5}},
...               60: {'gnom': (-0.2711073666720387, 0.1994839074523256), 'axes': {8, 4}},
...               61: {'gnom': (-0.2637120677768278, -0.11984479170021081), 'axes': {8}},
...               62: {'gnom': (-0.26934469418071083, 0.11943958616023759), 'axes': {8}},
...               63: {'gnom': (-0.26653796331705015, -0.00040349411462381246), 'axes': {8, 2, 6, 7}},
...               64: {'gnom': (-0.3351088299984176, -0.36661822106768144), 'axes': {5}},
...               65: {'gnom': (-0.30919293226499917, -0.22782988778598667), 'axes': set()},
...               66: {'gnom': (-0.3524825023650732, 0.3647641920521141), 'axes': {4}},
...               67: {'gnom': (-0.31990969642322137, 0.22611752961083748), 'axes': set()},
...               68: {'gnom': (-0.3144023520521512, -0.0013698968940222644), 'axes': {2}},
...               69: {'gnom': (-0.3223772542169661, -0.14153279317889217), 'axes': {7}},
...               70: {'gnom': (-0.3290872223583307, 0.13867490378055763), 'axes': {6}},
...               71: {'gnom': (-0.34380505280556134, -0.0019232844125064402), 'axes': {2}},
...               72: {'gnom': (-0.3716527272451695, -0.2655541496297943), 'axes': {7}},
...               73: {'gnom': (-0.384382394518522, 0.26137948985364423), 'axes': {6}},
...               74: {'gnom': (-0.4150393355485816, -0.37556396956837046), 'axes': {7}},
...               75: {'gnom': (-0.4213116259525938, -0.1277995546595711), 'axes': set()},
...               76: {'gnom': (-0.42743697409652126, 0.12091462467337603), 'axes': set()},
...               77: {'gnom': (-0.4305672928685682, -0.10207732996277492), 'axes': set()}}
&gt;&gt;&gt; axes_dict = {0: {'polar': (0.5456325, 0.07189146), 'quality': 0.7786729549943984, 'spots': {32, 1, 34, 4, 37, 7, 40, 11, 43, 22, 26, 28, 30}},
...              1: {'polar': (-0.50404394, 0.066435024), 'quality': 0.8495679649229442, 'spots': {33, 2, 35, 5, 38, 39, 8, 42, 12, 22, 25, 27, 29, 31}},
...              2: {'polar': (1.5920126, 0.0053436677), 'quality': 0.5048333500772214, 'spots': {3, 36, 68, 6, 71, 41, 46, 53, 22, 63}},
...              3: {'polar': (0.020630987, 0.07989738), 'quality': 0.32446216058045907, 'spots': {9, 10, 13, 14, 15, 16, 22}},
...              4: {'polar': (-2.6840417, 0.15513226), 'quality': 0.32470155528405464, 'spots': {66, 9, 44, 46, 55, 60, 31}},
...              5: {'polar': (2.7287471, 0.15980783), 'quality': 0.36693478788694234, 'spots': {32, 64, 10, 45, 46, 54, 23, 59}},
...              6: {'polar': (-2.7180853, 0.24310948), 'quality': 0.324204821510315, 'spots': {35, 70, 73, 48, 17, 54, 63}},
...              7: {'polar': (2.7643242, 0.24759501), 'quality': 0.3668147624332471, 'spots': {69, 37, 72, 74, 18, 50, 55, 63}},
...              8: {'polar': (-3.118213, 0.26645306), 'quality': 0.5046664108258551, 'spots': {42, 51, 52, 56, 57, 59, 60, 61, 62, 63}}}
&gt;&gt;&gt; kwargs = {'angle_max': 0.1308996938995747, 'spots_max': 20, 'distance_max': 0.08}
&gt;&gt;&gt; laue.atomic_find_subsets(spots_dict, axes_dict, **kwargs)
[{9, 10, 22}]
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_find_subsets(spots_dict, axes_dict, **kwargs):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de separation de grains. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.Experiment.find_subsets``
    ou encore via ``laue.diagram.LaueDiagram.find_subsets`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.Experiment.find_subsets`` gere nativement le parallelisme.

    Parameters
    ----------
    spots_dict : dict
        Une representation des spots et des information minimales
        qui y sont raccrochees. Il doit prendre la forme suivante:
        ``{spot_ind: {&#34;gnom&#34;: (x_gnom, y_gnom), &#34;axes&#34;: {1, 3, ...}}, ...}``
    axes_dict : dict
        Une representations des axes de zone. Doit etre de la forme:
        ``{axe_ind: {&#34;polar&#34;: (theta, dist), &#34;quality&#34;: .7, &#34;spots&#34;: {1, 4, 5, 6}}, ...}``
    **kwargs
        Doit au moins contenir les 3 champs ``angle_max``, ``spots_max`` et ``distance_max``.

    Returns
    -------
    list
        Chaque element est un ensemble d&#39;indice de spot appartenant au meme grain.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; spots_dict = {0: {&#39;gnom&#39;: (0.3136510725564478, -0.44091934214920697), &#39;axes&#39;: set()},
    ...               1: {&#39;gnom&#39;: (0.3092269223801162, -0.3703963974694111), &#39;axes&#39;: {0}},
    ...               2: {&#39;gnom&#39;: (0.29464954430652696, 0.39670741889986955), &#39;axes&#39;: {1}},
    ...               3: {&#39;gnom&#39;: (0.30191318963902786, 0.011759364157261544), &#39;axes&#39;: {2}},
    ...               4: {&#39;gnom&#39;: (0.2656586060012433, -0.29892567761860783), &#39;axes&#39;: {0}},
    ...               5: {&#39;gnom&#39;: (0.2537441830952802, 0.32256757073867776), &#39;axes&#39;: {1}},
    ...               6: {&#39;gnom&#39;: (0.259687191990358, 0.011094867051531301), &#39;axes&#39;: {2}},
    ...               7: {&#39;gnom&#39;: (0.21447480004378858, -0.2150686716681864), &#39;axes&#39;: {0}},
    ...               8: {&#39;gnom&#39;: (0.2057015738443993, 0.2356420984106664), &#39;axes&#39;: {1}},
    ...               9: {&#39;gnom&#39;: (0.09095514707222462, -0.5356714822419564), &#39;axes&#39;: {3, 4}},
    ...               10: {&#39;gnom&#39;: (0.06846289051965272, 0.5548594993575858), &#39;axes&#39;: {3, 5}},
    ...               11: {&#39;gnom&#39;: (0.16685972592987006, -0.1362785647833782), &#39;axes&#39;: {0}},
    ...               12: {&#39;gnom&#39;: (0.16092652407854113, 0.15424696872260854), &#39;axes&#39;: {1}},
    ...               13: {&#39;gnom&#39;: (0.0880179013812851, -0.40043047804756454), &#39;axes&#39;: {3}},
    ...               14: {&#39;gnom&#39;: (0.07130573600458438, 0.4174843621463065), &#39;axes&#39;: {3}},
    ...               15: {&#39;gnom&#39;: (0.08639048300887514, -0.31911672107326594), &#39;axes&#39;: {3}},
    ...               16: {&#39;gnom&#39;: (0.07308383568548608, 0.3351760458933546), &#39;axes&#39;: {3}},
    ...               17: {&#39;gnom&#39;: (-0.016567440130016563, -0.5541568143935384), &#39;axes&#39;: {6}},
    ...               18: {&#39;gnom&#39;: (-0.04084781468303007, 0.5689448068249144), &#39;axes&#39;: {7}},
    ...               19: {&#39;gnom&#39;: (0.0011982188252073992, -0.45016007120047424), &#39;axes&#39;: set()},
    ...               20: {&#39;gnom&#39;: (-0.018154025485441625, 0.46402526754308027), &#39;axes&#39;: set()},
    ...               21: {&#39;gnom&#39;: (-0.07286049562681773, -0.5640133440412382), &#39;axes&#39;: set()},
    ...               22: {&#39;gnom&#39;: (0.0798366324753105, 0.007023938379407561), &#39;axes&#39;: {0, 1, 2, 3}},
    ...               23: {&#39;gnom&#39;: (-0.0026903259324252246, 0.3921879524265071), &#39;axes&#39;: {5}},
    ...               24: {&#39;gnom&#39;: (-0.09784778756977644, 0.5766271192972883), &#39;axes&#39;: set()},
    ...               25: {&#39;gnom&#39;: (0.008002458469782677, -0.12293574282766238), &#39;axes&#39;: {1}},
    ...               26: {&#39;gnom&#39;: (0.0027460490484708115, 0.13394781189060836), &#39;axes&#39;: {0}},
    ...               27: {&#39;gnom&#39;: (-0.00523750349077013, -0.1470394198008183), &#39;axes&#39;: {1}},
    ...               28: {&#39;gnom&#39;: (-0.011614516626281228, 0.15777148638160254), &#39;axes&#39;: {0}},
    ...               29: {&#39;gnom&#39;: (-0.02477598980567221, -0.1823836791494654), &#39;axes&#39;: {1}},
    ...               30: {&#39;gnom&#39;: (-0.03264505249777272, 0.19229497060446735), &#39;axes&#39;: {0}},
    ...               31: {&#39;gnom&#39;: (-0.05554717740227801, -0.23832176191125093), &#39;axes&#39;: {1, 4}},
    ...               32: {&#39;gnom&#39;: (-0.06606796372263056, 0.24757266647939288), &#39;axes&#39;: {0, 5}},
    ...               33: {&#39;gnom&#39;: (-0.07907768658950604, -0.28096918114364355), &#39;axes&#39;: {1}},
    ...               34: {&#39;gnom&#39;: (-0.09156428823859053, 0.2893970244445073), &#39;axes&#39;: {0}},
    ...               35: {&#39;gnom&#39;: (-0.1126289846318788, -0.3416241560303849), &#39;axes&#39;: {1, 6}},
    ...               36: {&#39;gnom&#39;: (-0.060637577826655534, 0.0040391083212410655), &#39;axes&#39;: {2}},
    ...               37: {&#39;gnom&#39;: (-0.12787900102974828, 0.3491863530719953), &#39;axes&#39;: {0, 7}},
    ...               38: {&#39;gnom&#39;: (-0.1638208798822865, -0.4347286698438957), &#39;axes&#39;: {1}},
    ...               39: {&#39;gnom&#39;: (-0.18763951100210385, -0.4776573606384503), &#39;axes&#39;: {1}},
    ...               40: {&#39;gnom&#39;: (-0.1835787305562983, 0.4411739247300923), &#39;axes&#39;: {0}},
    ...               41: {&#39;gnom&#39;: (-0.08524649743749545, 0.003436523504335945), &#39;axes&#39;: {2}},
    ...               42: {&#39;gnom&#39;: (-0.2523542667003644, -0.5949096601292776), &#39;axes&#39;: {8, 1}},
    ...               43: {&#39;gnom&#39;: (-0.20958039716029048, 0.4837711867805186), &#39;axes&#39;: {0}},
    ...               44: {&#39;gnom&#39;: (-0.11758167206566646, -0.1123768702642382), &#39;axes&#39;: {4}},
    ...               45: {&#39;gnom&#39;: (-0.12266805447587614, 0.11817207059217111), &#39;axes&#39;: {5}},
    ...               46: {&#39;gnom&#39;: (-0.17376685735949005, 0.0016472083664571353), &#39;axes&#39;: {2, 4, 5}},
    ...               47: {&#39;gnom&#39;: (-0.20724297206742168, -0.25150647771157364), &#39;axes&#39;: set()},
    ...               48: {&#39;gnom&#39;: (-0.19501092265693473, -0.15910834995174863), &#39;axes&#39;: {6}},
    ...               49: {&#39;gnom&#39;: (-0.21870028043714163, 0.25404867230414246), &#39;axes&#39;: set()},
    ...               50: {&#39;gnom&#39;: (-0.2022799134764107, 0.16163477331619278), &#39;axes&#39;: {7}},
    ...               51: {&#39;gnom&#39;: (-0.2581018757728966, -0.3579924435989167), &#39;axes&#39;: {8}},
    ...               52: {&#39;gnom&#39;: (-0.2748170617964089, 0.3596407013965223), &#39;axes&#39;: {8}},
    ...               53: {&#39;gnom&#39;: (-0.21290266125204668, 0.0008346770568725252), &#39;axes&#39;: {2}},
    ...               54: {&#39;gnom&#39;: (-0.21986841578944072, -0.10369811043407293), &#39;axes&#39;: {5, 6}},
    ...               55: {&#39;gnom&#39;: (-0.224622744015843, 0.10503684334781563), &#39;axes&#39;: {4, 7}},
    ...               56: {&#39;gnom&#39;: (-0.25955409478645797, -0.29848728294016463), &#39;axes&#39;: {8}},
    ...               57: {&#39;gnom&#39;: (-0.27338619051240226, 0.299389601118816), &#39;axes&#39;: {8}},
    ...               58: {&#39;gnom&#39;: (-0.3156632165624574, -0.4202358686963255), &#39;axes&#39;: set()},
    ...               59: {&#39;gnom&#39;: (-0.2618304221414466, -0.19929059589121062), &#39;axes&#39;: {8, 5}},
    ...               60: {&#39;gnom&#39;: (-0.2711073666720387, 0.1994839074523256), &#39;axes&#39;: {8, 4}},
    ...               61: {&#39;gnom&#39;: (-0.2637120677768278, -0.11984479170021081), &#39;axes&#39;: {8}},
    ...               62: {&#39;gnom&#39;: (-0.26934469418071083, 0.11943958616023759), &#39;axes&#39;: {8}},
    ...               63: {&#39;gnom&#39;: (-0.26653796331705015, -0.00040349411462381246), &#39;axes&#39;: {8, 2, 6, 7}},
    ...               64: {&#39;gnom&#39;: (-0.3351088299984176, -0.36661822106768144), &#39;axes&#39;: {5}},
    ...               65: {&#39;gnom&#39;: (-0.30919293226499917, -0.22782988778598667), &#39;axes&#39;: set()},
    ...               66: {&#39;gnom&#39;: (-0.3524825023650732, 0.3647641920521141), &#39;axes&#39;: {4}},
    ...               67: {&#39;gnom&#39;: (-0.31990969642322137, 0.22611752961083748), &#39;axes&#39;: set()},
    ...               68: {&#39;gnom&#39;: (-0.3144023520521512, -0.0013698968940222644), &#39;axes&#39;: {2}},
    ...               69: {&#39;gnom&#39;: (-0.3223772542169661, -0.14153279317889217), &#39;axes&#39;: {7}},
    ...               70: {&#39;gnom&#39;: (-0.3290872223583307, 0.13867490378055763), &#39;axes&#39;: {6}},
    ...               71: {&#39;gnom&#39;: (-0.34380505280556134, -0.0019232844125064402), &#39;axes&#39;: {2}},
    ...               72: {&#39;gnom&#39;: (-0.3716527272451695, -0.2655541496297943), &#39;axes&#39;: {7}},
    ...               73: {&#39;gnom&#39;: (-0.384382394518522, 0.26137948985364423), &#39;axes&#39;: {6}},
    ...               74: {&#39;gnom&#39;: (-0.4150393355485816, -0.37556396956837046), &#39;axes&#39;: {7}},
    ...               75: {&#39;gnom&#39;: (-0.4213116259525938, -0.1277995546595711), &#39;axes&#39;: set()},
    ...               76: {&#39;gnom&#39;: (-0.42743697409652126, 0.12091462467337603), &#39;axes&#39;: set()},
    ...               77: {&#39;gnom&#39;: (-0.4305672928685682, -0.10207732996277492), &#39;axes&#39;: set()}}
    &gt;&gt;&gt; axes_dict = {0: {&#39;polar&#39;: (0.5456325, 0.07189146), &#39;quality&#39;: 0.7786729549943984, &#39;spots&#39;: {32, 1, 34, 4, 37, 7, 40, 11, 43, 22, 26, 28, 30}},
    ...              1: {&#39;polar&#39;: (-0.50404394, 0.066435024), &#39;quality&#39;: 0.8495679649229442, &#39;spots&#39;: {33, 2, 35, 5, 38, 39, 8, 42, 12, 22, 25, 27, 29, 31}},
    ...              2: {&#39;polar&#39;: (1.5920126, 0.0053436677), &#39;quality&#39;: 0.5048333500772214, &#39;spots&#39;: {3, 36, 68, 6, 71, 41, 46, 53, 22, 63}},
    ...              3: {&#39;polar&#39;: (0.020630987, 0.07989738), &#39;quality&#39;: 0.32446216058045907, &#39;spots&#39;: {9, 10, 13, 14, 15, 16, 22}},
    ...              4: {&#39;polar&#39;: (-2.6840417, 0.15513226), &#39;quality&#39;: 0.32470155528405464, &#39;spots&#39;: {66, 9, 44, 46, 55, 60, 31}},
    ...              5: {&#39;polar&#39;: (2.7287471, 0.15980783), &#39;quality&#39;: 0.36693478788694234, &#39;spots&#39;: {32, 64, 10, 45, 46, 54, 23, 59}},
    ...              6: {&#39;polar&#39;: (-2.7180853, 0.24310948), &#39;quality&#39;: 0.324204821510315, &#39;spots&#39;: {35, 70, 73, 48, 17, 54, 63}},
    ...              7: {&#39;polar&#39;: (2.7643242, 0.24759501), &#39;quality&#39;: 0.3668147624332471, &#39;spots&#39;: {69, 37, 72, 74, 18, 50, 55, 63}},
    ...              8: {&#39;polar&#39;: (-3.118213, 0.26645306), &#39;quality&#39;: 0.5046664108258551, &#39;spots&#39;: {42, 51, 52, 56, 57, 59, 60, 61, 62, 63}}}
    &gt;&gt;&gt; kwargs = {&#39;angle_max&#39;: 0.1308996938995747, &#39;spots_max&#39;: 20, &#39;distance_max&#39;: 0.08}
    &gt;&gt;&gt; laue.atomic_find_subsets(spots_dict, axes_dict, **kwargs)
    [{9, 10, 22}]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.zone_axis import distance as distance_axis
    from laue.spot import distance as distance_pic
    import networkx

    def count_variant_axis(spot_id):
        &#34;&#34;&#34;
        Compte le nombre d&#39;axes de zone qui different beaucoup.
        (ie considere 2 axes proche comme un seul axe)
        &#34;&#34;&#34;
        axes_id = spots_dict[spot_id][&#34;axes&#34;]
        if len(axes_id) &lt;= 1:
            return len(axes_id)
        axes = [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes_id]
        nbr_near = (distance_axis(axes, axes, weight=1) &lt; kwargs[&#34;angle_max&#34;]).sum()
        nbr = len(axes) - (nbr_near-len(axes))//2
        return nbr

    def simul_remove_axis(graph, axis, excluded):
        &#34;&#34;&#34;
        Retire les aretes liees a cet axe, puis regarde ce que ca donne.
        &#34;&#34;&#34;
        graph_bis = graph.copy()
        for spot1, spot2, axis_found in graph.edges.data(&#34;axis&#34;):
            if axis_found is axis:
                graph_bis.remove_edge(spot1, spot2)
        excluded_bis = [edge for edge in excluded if networkx.algorithms.has_path(graph_bis, *edge)]
        return excluded_bis, graph_bis

    # Extraction des spots.
    spots_at_cross = sorted(spots_dict, key=count_variant_axis, reverse=True)[:kwargs[&#34;spots_max&#34;]]
    max_cross = count_variant_axis(spots_at_cross[0])
    limit = math.sqrt(max(2**2, max_cross)) # Permet d&#39;eviter &#39;ValueError: math domain error&#39;
    spots_at_cross = [spot_id for spot_id in spots_at_cross if count_variant_axis(spot_id) &gt;= limit]

    # Creation des noeuds du graphe.
    graph = networkx.Graph()
    graph.add_nodes_from(spots_at_cross)

    # Ajout grossier de certaine aretes.
    excluded = [] # La liste des noeuds appartenant a des grains differents.
    candidate_axes = set() # L&#39;ensemble des axes de zone consideres.
    for i, spot1 in enumerate(spots_at_cross[:-1]): # On faite toutes les combinaisons
        for spot2 in spots_at_cross[i+1:]: # de 2 sommets possibles.

            ## Exclusion des spots trop proches.
            if distance_pic(
                    spots_dict[spot1][&#34;gnom&#34;],
                    spots_dict[spot2][&#34;gnom&#34;],
                    space=&#34;gnomonic&#34;
                    ) &lt; kwargs[&#34;distance_max&#34;]:
                excluded.append((spot1, spot2))
                continue

            ## On ne relie pas les spots qui n&#39;ont pas d&#39;axe commun.
            common_axes = spots_dict[spot1][&#34;axes&#34;] &amp; spots_dict[spot2][&#34;axes&#34;]
            if not common_axes:
                continue

            ## Exclusion des spots ayant 2 axes de zone paralleles.
            axes1, axes2 = spots_dict[spot1][&#34;axes&#34;]-common_axes, spots_dict[spot2][&#34;axes&#34;]-common_axes
            if axes1 and axes2 and distance_axis(
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes1],
                    [axes_dict[axis_id][&#34;polar&#34;] for axis_id in axes2],
                    weight=1).min() &lt; kwargs[&#34;angle_max&#34;]: # tolerance angulaire de pi/32
                excluded.append((spot1, spot2))
                continue

            ## Ajout dans le graphe.
            best_axis = sorted(common_axes, key=lambda axis_id: axes_dict[axis_id][&#34;quality&#34;])[-1]
            candidate_axes.add(best_axis)
            graph.add_edge(spot1, spot2, quality=axes_dict[best_axis][&#34;quality&#34;], axis=best_axis)

    # Suppression des aretes en trop afin de discosier les grains.
    excluded = [edge for edge in excluded if networkx.algorithms.has_path(graph, *edge)]
    while excluded:
        predictions = [(*simul_remove_axis(graph, axis_id, excluded), axis_id) for axis_id in candidate_axes]
        best_len = min(len(excluded_bis) for excluded_bis, _, _ in predictions)
        predictions = [p for p in predictions if len(p[0]) == best_len]
        costs = [axes_dict[axis_id][&#34;quality&#34;] for _, _, axis_id in predictions]
        min_quality = min(costs)
        predictions = [p for p in predictions if axes_dict[p[2]][&#34;quality&#34;] == min_quality]
        excluded, graph, axis_id = predictions.pop()
        candidate_axes.remove(axis_id)

    # Creation des clusters.
    subsets = list(networkx.algorithms.connected_components(graph))
    subsets = sorted(subsets, key=lambda con: len(con), reverse=True)
    subsets = [con for con in subsets if len(con) &gt;= 2]
    return subsets</code></pre>
</details>
</dd>
<dt id="laue.atomic_find_zone_axes"><code class="name flex">
<span>def <span class="ident">atomic_find_zone_axes</span></span>(<span>transformer, gnomonics, dmax, nbr, tol)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Fonction 'bas niveau' de recherche d'axes de zonnes. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Cette fonction n'est pas faite pour etre utilisee directement,
il vaut mieux s'en servir a travers <code><a title="laue.Experiment.find_zone_axes" href="#laue.Experiment.find_zone_axes">Experiment.find_zone_axes()</a></code>
ou encore via <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code> car le context
est mieu gere, les entrees sont plus simples et les sorties aussi.</li>
<li>Il n'y a pas de verifications sur les entrees car elles sont faite
dans les methodes de plus haut niveau.</li>
<li>Cette fonction n'est pas parallelisee. Par contre la methode
<code><a title="laue.Experiment.find_zone_axes" href="#laue.Experiment.find_zone_axes">Experiment.find_zone_axes()</a></code> gere nativement le parallelisme.</li>
<li>La seule raison d'utiliser cette fonction, c'est si le pic_search
utilise n'est pas celui de <code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code>. Sinon, l'utilisation
de cette fonction ne fera qu'alourdir et ralentir votre code.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transformer</code></strong> :&ensp;<code><a title="laue.core.geometry.transformer.Transformer" href="core/geometry/transformer.html#laue.core.geometry.transformer.Transformer">Transformer</a></code></dt>
<dd>Instance d'un objet capable de gerer formellement
la transformee de hough. (Cet argument n'est pas present
si on utilise les methodes ci dessus car il fait partie
d'une <code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code>.)</dd>
<dt><strong><code>gnomonics</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Les positions des spots en coordonnees gnomonic.
Il faut que <code>x_gnomonic = gnomonic[0]</code>
et que <code>y_gnomonic = gnomonic[1]</code>.</dd>
<dt><strong><code>dmax</code></strong></dt>
<dd>Comme <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code> a la difference
que ce parametre n'est pas factultatif.</dd>
<dt><strong><code>nbr</code></strong></dt>
<dd>Comme <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code> a la difference
que ce parametre n'est pas factultatif.</dd>
<dt><strong><code>tol</code></strong></dt>
<dd>Comme <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code> a la difference
que ce parametre doit etre fixe par vous et ne peut
pas prendre tous seulle une valeur optimale.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>angles</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Vecteur des angles des droites. C'est la premiere partie
de la representation polaire des droites. (C'est l'angle
algebrique entre l'axe x et un vecteur normal a la droite.)</dd>
<dt><strong><code>dists</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Vecteur des distances des droites. C'est la seconde partie
de la representation polaire des droites. (C'est la plus courte
distance entre l'origine et tous les points constituant la droite.)</dd>
<dt><strong><code>axes_spots_ind</code></strong> :&ensp;<code>list</code></dt>
<dd>Vecteur des ensembles de spots lies a chaque droites.
On a <code>len(axes_spots_ind) == nbr_d_axe_de_zones</code>.</dd>
<dt><strong><code>spots_axes_ind</code></strong> :&ensp;<code>list</code></dt>
<dd>Vecteur des indices des droites passant par chaque spot.
On a <code>len(spots_axes_ind) == nbr_de_spots</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import laue
&gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
&gt;&gt;&gt; transformer = Transformer()
&gt;&gt;&gt; gnomonics = np.array(
... [[ 3.13651353e-01,  3.09226930e-01,  2.94649661e-01,  3.01913261e-01,
...    2.65658647e-01,  2.53744185e-01,  2.59687364e-01,  2.14474797e-01,
...    2.05701679e-01,  9.09550861e-02,  6.84629381e-02,  1.66859716e-01,
...    1.60926506e-01,  8.80179554e-02,  7.13057593e-02,  8.63905624e-02,
...    7.30837137e-02, -1.65674724e-02, -4.08478454e-02,  1.19812461e-03,
...   -1.81540363e-02, -7.28605017e-02,  7.98366740e-02, -2.69038416e-03,
...   -9.78478342e-02,  8.00240133e-03,  2.74614431e-03, -5.23754954e-03,
...   -1.16145127e-02, -2.47761104e-02, -3.26450653e-02, -5.55472001e-02,
...   -6.60679415e-02, -7.90777430e-02, -9.15642828e-02, -1.12629071e-01,
...   -6.06376082e-02, -1.27878949e-01, -1.63820893e-01, -1.87639564e-01,
...   -1.83578789e-01, -8.52464810e-02, -2.52354264e-01, -2.09580392e-01,
...   -1.17581628e-01, -1.22668095e-01, -1.73766926e-01, -2.07243070e-01,
...   -1.95010900e-01, -2.18700320e-01, -2.02279896e-01, -2.58101851e-01,
...   -2.74817050e-01, -2.12902710e-01, -2.19868407e-01, -2.24622726e-01,
...   -2.59554148e-01, -2.73386180e-01, -3.15663189e-01, -2.61830509e-01,
...   -2.71107376e-01, -2.63712078e-01, -2.69344717e-01, -2.66537964e-01,
...   -3.35108876e-01, -3.09192955e-01, -3.52482527e-01, -3.19909692e-01,
...   -3.14402401e-01, -3.22377235e-01, -3.29087257e-01, -3.43805134e-01,
...   -3.71652663e-01, -3.84382367e-01, -4.15039361e-01, -4.21311647e-01,
...   -4.27436978e-01, -4.30567324e-01],
...  [-4.40919399e-01, -3.70396405e-01,  3.96707416e-01,  1.17593547e-02,
...   -2.98925638e-01,  3.22567523e-01,  1.10948607e-02, -2.15068594e-01,
...    2.35642120e-01, -5.35671413e-01,  5.54859519e-01, -1.36278614e-01,
...    1.54246926e-01, -4.00430471e-01,  4.17484373e-01, -3.19116771e-01,
...    3.35176021e-01, -5.54156780e-01,  5.68944812e-01, -4.50160027e-01,
...    4.64025259e-01, -5.64013302e-01,  7.02395430e-03,  3.92187923e-01,
...    5.76627076e-01, -1.22935735e-01,  1.33947819e-01, -1.47039399e-01,
...    1.57771528e-01, -1.82383612e-01,  1.92295000e-01, -2.38321751e-01,
...    2.47572735e-01, -2.80969173e-01,  2.89397061e-01, -3.41624111e-01,
...    4.03913576e-03,  3.49186361e-01, -4.34728622e-01, -4.77657378e-01,
...    4.41173941e-01,  3.43652675e-03, -5.94909608e-01,  4.83771175e-01,
...   -1.12376906e-01,  1.18172102e-01,  1.64722977e-03, -2.51506448e-01,
...   -1.59108326e-01,  2.54048705e-01,  1.61634743e-01, -3.57992381e-01,
...    3.59640747e-01,  8.34673643e-04, -1.03698038e-01,  1.05036855e-01,
...   -2.98487246e-01,  2.99389601e-01, -4.20235783e-01, -1.99290574e-01,
...    1.99483901e-01, -1.19844824e-01,  1.19439557e-01, -4.03501937e-04,
...   -3.66618216e-01, -2.27829859e-01,  3.64764214e-01,  2.26117536e-01,
...   -1.36989250e-03, -1.41532809e-01,  1.38674900e-01, -1.92326447e-03,
...   -2.65554100e-01,  2.61379480e-01, -3.75563949e-01, -1.27799526e-01,
...    1.20914638e-01, -1.02077320e-01]])
&gt;&gt;&gt; dmax = 0.01086181640625
&gt;&gt;&gt; nbr = 7
&gt;&gt;&gt; tol = 0.01758723266
&gt;&gt;&gt; angles, dists, axes_spots_ind, spots_axes_ind = laue.atomic_find_zone_axes(
...     transformer, gnomonics, dmax, nbr, tol)
&gt;&gt;&gt; len(angles), len(dists)
(9, 9)
&gt;&gt;&gt; for spots in axes_spots_ind:
...     print(sorted(spots))
...
[1, 4, 7, 11, 22, 26, 28, 30, 32, 34, 37, 40, 43]
[2, 5, 8, 12, 22, 25, 27, 29, 31, 33, 35, 38, 39, 42]
[3, 6, 22, 36, 41, 46, 53, 63, 68, 71]
[9, 10, 13, 14, 15, 16, 22]
[9, 31, 44, 46, 55, 60, 66]
[10, 23, 32, 45, 46, 54, 59, 64]
[17, 35, 48, 54, 63, 70, 73]
[18, 37, 50, 55, 63, 69, 72, 74]
[42, 51, 52, 56, 57, 59, 60, 61, 62, 63]
&gt;&gt;&gt; spots_axes_ind[0]
set()
&gt;&gt;&gt; sorted(spots_axes_ind[22])
[0, 1, 2, 3]
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_find_zone_axes(transformer, gnomonics, dmax, nbr, tol):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau&#39; de recherche d&#39;axes de zonnes. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.Experiment.find_zone_axes``
    ou encore via ``laue.diagram.LaueDiagram.find_zone_axes`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre la methode
    ``laue.Experiment.find_zone_axes`` gere nativement le parallelisme.
    * La seule raison d&#39;utiliser cette fonction, c&#39;est si le pic_search
    utilise n&#39;est pas celui de ``laue.Experiment``. Sinon, l&#39;utilisation
    de cette fonction ne fera qu&#39;alourdir et ralentir votre code.

    Parameters
    ----------
    transformer : laue.core.geometry.transformer.Transformer
        Instance d&#39;un objet capable de gerer formellement
        la transformee de hough. (Cet argument n&#39;est pas present
        si on utilise les methodes ci dessus car il fait partie
        d&#39;une ``laue.Experiment``.)
    gnomonics : np.ndarray
        Les positions des spots en coordonnees gnomonic.
        Il faut que ``x_gnomonic = gnomonic[0]``
        et que ``y_gnomonic = gnomonic[1]``.
    dmax
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre n&#39;est pas factultatif.
    nbr
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre n&#39;est pas factultatif.
    tol
        Comme ``laue.diagram.LaueDiagram.find_zone_axes`` a la difference
        que ce parametre doit etre fixe par vous et ne peut
        pas prendre tous seulle une valeur optimale.

    Returns
    -------
    angles : iterable
        Vecteur des angles des droites. C&#39;est la premiere partie
        de la representation polaire des droites. (C&#39;est l&#39;angle
        algebrique entre l&#39;axe x et un vecteur normal a la droite.)
    dists : iterable
        Vecteur des distances des droites. C&#39;est la seconde partie
        de la representation polaire des droites. (C&#39;est la plus courte
        distance entre l&#39;origine et tous les points constituant la droite.)
    axes_spots_ind : list
        Vecteur des ensembles de spots lies a chaque droites.
        On a ``len(axes_spots_ind) == nbr_d_axe_de_zones``.
    spots_axes_ind : list
        Vecteur des indices des droites passant par chaque spot.
        On a ``len(spots_axes_ind) == nbr_de_spots``.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; from laue.core.geometry.transformer import Transformer
    &gt;&gt;&gt; transformer = Transformer()
    &gt;&gt;&gt; gnomonics = np.array(
    ... [[ 3.13651353e-01,  3.09226930e-01,  2.94649661e-01,  3.01913261e-01,
    ...    2.65658647e-01,  2.53744185e-01,  2.59687364e-01,  2.14474797e-01,
    ...    2.05701679e-01,  9.09550861e-02,  6.84629381e-02,  1.66859716e-01,
    ...    1.60926506e-01,  8.80179554e-02,  7.13057593e-02,  8.63905624e-02,
    ...    7.30837137e-02, -1.65674724e-02, -4.08478454e-02,  1.19812461e-03,
    ...   -1.81540363e-02, -7.28605017e-02,  7.98366740e-02, -2.69038416e-03,
    ...   -9.78478342e-02,  8.00240133e-03,  2.74614431e-03, -5.23754954e-03,
    ...   -1.16145127e-02, -2.47761104e-02, -3.26450653e-02, -5.55472001e-02,
    ...   -6.60679415e-02, -7.90777430e-02, -9.15642828e-02, -1.12629071e-01,
    ...   -6.06376082e-02, -1.27878949e-01, -1.63820893e-01, -1.87639564e-01,
    ...   -1.83578789e-01, -8.52464810e-02, -2.52354264e-01, -2.09580392e-01,
    ...   -1.17581628e-01, -1.22668095e-01, -1.73766926e-01, -2.07243070e-01,
    ...   -1.95010900e-01, -2.18700320e-01, -2.02279896e-01, -2.58101851e-01,
    ...   -2.74817050e-01, -2.12902710e-01, -2.19868407e-01, -2.24622726e-01,
    ...   -2.59554148e-01, -2.73386180e-01, -3.15663189e-01, -2.61830509e-01,
    ...   -2.71107376e-01, -2.63712078e-01, -2.69344717e-01, -2.66537964e-01,
    ...   -3.35108876e-01, -3.09192955e-01, -3.52482527e-01, -3.19909692e-01,
    ...   -3.14402401e-01, -3.22377235e-01, -3.29087257e-01, -3.43805134e-01,
    ...   -3.71652663e-01, -3.84382367e-01, -4.15039361e-01, -4.21311647e-01,
    ...   -4.27436978e-01, -4.30567324e-01],
    ...  [-4.40919399e-01, -3.70396405e-01,  3.96707416e-01,  1.17593547e-02,
    ...   -2.98925638e-01,  3.22567523e-01,  1.10948607e-02, -2.15068594e-01,
    ...    2.35642120e-01, -5.35671413e-01,  5.54859519e-01, -1.36278614e-01,
    ...    1.54246926e-01, -4.00430471e-01,  4.17484373e-01, -3.19116771e-01,
    ...    3.35176021e-01, -5.54156780e-01,  5.68944812e-01, -4.50160027e-01,
    ...    4.64025259e-01, -5.64013302e-01,  7.02395430e-03,  3.92187923e-01,
    ...    5.76627076e-01, -1.22935735e-01,  1.33947819e-01, -1.47039399e-01,
    ...    1.57771528e-01, -1.82383612e-01,  1.92295000e-01, -2.38321751e-01,
    ...    2.47572735e-01, -2.80969173e-01,  2.89397061e-01, -3.41624111e-01,
    ...    4.03913576e-03,  3.49186361e-01, -4.34728622e-01, -4.77657378e-01,
    ...    4.41173941e-01,  3.43652675e-03, -5.94909608e-01,  4.83771175e-01,
    ...   -1.12376906e-01,  1.18172102e-01,  1.64722977e-03, -2.51506448e-01,
    ...   -1.59108326e-01,  2.54048705e-01,  1.61634743e-01, -3.57992381e-01,
    ...    3.59640747e-01,  8.34673643e-04, -1.03698038e-01,  1.05036855e-01,
    ...   -2.98487246e-01,  2.99389601e-01, -4.20235783e-01, -1.99290574e-01,
    ...    1.99483901e-01, -1.19844824e-01,  1.19439557e-01, -4.03501937e-04,
    ...   -3.66618216e-01, -2.27829859e-01,  3.64764214e-01,  2.26117536e-01,
    ...   -1.36989250e-03, -1.41532809e-01,  1.38674900e-01, -1.92326447e-03,
    ...   -2.65554100e-01,  2.61379480e-01, -3.75563949e-01, -1.27799526e-01,
    ...    1.20914638e-01, -1.02077320e-01]])
    &gt;&gt;&gt; dmax = 0.01086181640625
    &gt;&gt;&gt; nbr = 7
    &gt;&gt;&gt; tol = 0.01758723266
    &gt;&gt;&gt; angles, dists, axes_spots_ind, spots_axes_ind = laue.atomic_find_zone_axes(
    ...     transformer, gnomonics, dmax, nbr, tol)
    &gt;&gt;&gt; len(angles), len(dists)
    (9, 9)
    &gt;&gt;&gt; for spots in axes_spots_ind:
    ...     print(sorted(spots))
    ...
    [1, 4, 7, 11, 22, 26, 28, 30, 32, 34, 37, 40, 43]
    [2, 5, 8, 12, 22, 25, 27, 29, 31, 33, 35, 38, 39, 42]
    [3, 6, 22, 36, 41, 46, 53, 63, 68, 71]
    [9, 10, 13, 14, 15, 16, 22]
    [9, 31, 44, 46, 55, 60, 66]
    [10, 23, 32, 45, 46, 54, 59, 64]
    [17, 35, 48, 54, 63, 70, 73]
    [18, 37, 50, 55, 63, 69, 72, 74]
    [42, 51, 52, 56, 57, 59, 60, 61, 62, 63]
    &gt;&gt;&gt; spots_axes_ind[0]
    set()
    &gt;&gt;&gt; sorted(spots_axes_ind[22])
    [0, 1, 2, 3]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.core.geometry.transformer import ind2comb

    # Recherches des axes de zone.
    angles, dists = transformer.hough_reduce(
        *transformer.hough(*gnomonics),
        nbr=nbr, tol=tol) # Recuperation des axes.
    if len(angles) &lt;= 1: # Si on a pas trouve suffisement de choses.
        return (), (), (), ((),)*gnomonics.shape[-1]

    # Attribution des points aux droites.
    axes_spots_ind = [set() for _ in range(len(angles))] # A chaque droite, c&#39;est les spots qu&#39;elle possede.
    spots_axes_ind = [set() for _ in range(gnomonics.shape[-1])]
    x_inters, y_inters = transformer.inter_lines(angles, dists)
    xg_spots, yg_spots = gnomonics

    ## Recuperation des points aux intersections.
    
    ### Calcul des points les plus proche pour chaque intersections.
    used_memory = len(x_inters)*len(xg_spots)*8 # Taille de la matrice de distance en octet.
    if psutil is not None and psutil.virtual_memory().available &gt; 2*used_memory:
        xg_spots_mesh, x_inters_mesh = np.meshgrid(xg_spots, x_inters, copy=False)
        yg_spots_mesh, y_inters_mesh = np.meshgrid(yg_spots, y_inters, copy=False)
        if numexpr is not None: # d[inter, gnomo]
            distances = numexpr.evaluate(
                &#34;sqrt((xg_spots_mesh-x_inters_mesh)**2 + (yg_spots_mesh-y_inters_mesh)**2)&#34;)
        else:
            distances = np.sqrt((xg_spots_mesh-x_inters_mesh)**2 + (yg_spots_mesh-y_inters_mesh)**2)
        nearest_spots = np.argmin(distances, axis=1) # Pour chaque intersections, son spot le plus proche.
        del distances, xg_spots_mesh, x_inters_mesh, yg_spots_mesh, y_inters_mesh
    else: # Si il n&#39;y a pas suffisement de RAM.
        nearest_spots = np.array([ # attention &#39;numexpr&#39; est 7 fois plus lent.
            np.argmin(np.sqrt((xg_spots-x_inter)**2 + (yg_spots-y_inter)**2))
            for x_inter, y_inter in zip(x_inters, y_inters)], dtype=int)

    ### Selection des bons candidats.
    spots_left = [] # Les spots non references.
    for spot_ind, (xg_pic, yg_pic) in enumerate(zip(xg_spots, yg_spots)):
        inters_cand = np.argwhere(nearest_spots == spot_ind)
        adds_inter = inters_cand[
            (x_inters[inters_cand]-xg_pic)**2
          + (y_inters[inters_cand]-yg_pic)**2
          &lt; dmax**2]
        if adds_inter.any():
            _adds_axes_1, _adds_axes_2 = ind2comb(adds_inter, n=len(angles))
            adds_axes = set(_adds_axes_1) | set(_adds_axes_2)
            for add_axis in adds_axes:
                axes_spots_ind[add_axis].add(spot_ind)
            spots_axes_ind[spot_ind].update(adds_axes) # f&#34;le spot num {spot_ind} est l&#39;intersections des axes {adds_axes}.&#34;
        else:
            spots_left.append(spot_ind)

    ## Recuperation des points colles a un seul axe.
    spots_left = np.array(spots_left, dtype=int) # Les indices des spots restants.

    used_memory = len(spots_left)*len(angles)*8 # Taille memoire de la matrice de distances.
    if psutil is not None and psutil.virtual_memory().available &gt; 2*used_memory:
        distances = transformer.dist_line( # d[line, point]
            angles, dists, xg_spots[spots_left], yg_spots[spots_left])
        axis_ind = np.argmin(distances, axis=0) # A chaque points, indice de la droite la plus proche.
        close_spots = distances.min(axis=0) &lt; dmax # La matrice des points suffisement proches.
        del distances
        for axis_ind, spot_left in zip(axis_ind[close_spots], spots_left[close_spots]):
            axes_spots_ind[axis_ind].add(spot_left)
            spots_axes_ind[spot_left].add(axis_ind)   
    else: # Si il n&#39;y a pas suffisement de RAM.
        for spot_left, xg_pic, yg_pic in zip(spots_left, xg_spots[spots_left], yg_spots[spots_left]):
            xg_pic, yg_pic = np.array([xg_pic], dtype=np.float32), np.array([yg_pic], dtype=np.float32)
            distances = transformer.dist_line(angles, dists, xg_pic, yg_pic) # d[line, point]
            axis_ind = np.argmin(distances[:, 0])
            if distances[axis_ind] &lt; dmax:
                axes_spots_ind[axis_ind].add(spot_left)
                spots_axes_ind[spot_left].add(axis_ind)

    # Suppression des axes qui contiennent pas suffisement de points.
    mask_axes_to_keep = np.array([len(spots_ind) for spots_ind in axes_spots_ind]) &gt;= nbr
    ind_axes_to_keep = set(np.argwhere(mask_axes_to_keep)[:, 0])
    spots_axes_ind = [axes_ind &amp; ind_axes_to_keep for axes_ind in spots_axes_ind]
    axes_spots_ind = [spots_ind for axis_ind, spots_ind
                     in enumerate(axes_spots_ind)
                     if axis_ind in ind_axes_to_keep]
    angles, dists = angles[mask_axes_to_keep], dists[mask_axes_to_keep]

    # Changement des anciens par les nouveaux indices de droites.
    old_to_new = {
        old_axis_ind: new_axis_ind
        for new_axis_ind, old_axis_ind
        in enumerate(sorted(set.union(*spots_axes_ind)))}
    spots_axes_ind = [
        {old_to_new[old_axis_ind] for old_axis_ind in old_axes_ind}
        for old_axes_ind in spots_axes_ind]

    return angles, dists, axes_spots_ind, spots_axes_ind</code></pre>
</details>
</dd>
<dt id="laue.atomic_pic_search"><code class="name flex">
<span>def <span class="ident">atomic_pic_search</span></span>(<span>image, kernel_font, kernel_dilate, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Fonction 'bas niveau de pic search atomic serialisable. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Cette fonction n'est pas faite pour etre utilisee directement,
il vaut mieux s'en servir a travers <code><a title="laue.Experiment.get_diagrams" href="#laue.Experiment.get_diagrams">Experiment.get_diagrams()</a></code>
ou encore via <code><a title="laue.Experiment.__iter__" href="#laue.Experiment.__iter__">Experiment.__iter__()</a></code> car le context
est mieu gere, les entrees sont plus simples et les sorties aussi.</li>
<li>Il n'y a pas de verifications sur les entrees car elles sont faite
dans les methodes de plus haut niveau.</li>
<li>Cette fonction n'est pas parallelisee. Par contre les methodes
de <code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code> gerent nativement le parallelisme.</li>
<li>L'utilisation de cette fonction ne fera qu'alourdir et ralentir votre code.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Image 2d en niveau de gris codee en np.uint16.
C'est l'image brute, sans pre-traitement et avec le fond diffus.</dd>
<dt><strong><code>kernel_font</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Le masque de l'element structurant pour l'estimation
du fond par ouverture morphologique.</dd>
<dt><strong><code>kernel_dilate</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Le masque de l'element structurant pour la dilatation morphologique
sur l'image binarisee afin d'aglomerer les grains proches.</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Le niveau de seuillage relatif a la variance de l'image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Une liste qui contient autant d'elements de de pic trouves.
Les element sont des dictionaires</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import cv2
&gt;&gt;&gt; from laue import atomic_pic_search
&gt;&gt;&gt; from laue.utilities.image import read_image
&gt;&gt;&gt; image_path = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; image = read_image(image_path)
&gt;&gt;&gt; kernel_font = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (21, 21))
&gt;&gt;&gt; kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
&gt;&gt;&gt; threshold = 5.1
&gt;&gt;&gt;
&gt;&gt;&gt; res = atomic_pic_search(image, kernel_font, kernel_dilate, threshold)
&gt;&gt;&gt; type(res)
&lt;class 'list'&gt;
&gt;&gt;&gt; len(res)
78
&gt;&gt;&gt; res[0][&quot;bbox&quot;]
(1368, 1873, 6, 5)
&gt;&gt;&gt; res[0][&quot;distortion&quot;]
0.8471580534997302
&gt;&gt;&gt; res[0][&quot;spot_im&quot;]
array([[  8,  10,  16,  16,   8,   5],
       [ 11,  17,  67,  76,  13,   9],
       [  7,  19, 184, 229,  14,   6],
       [  9,   6,  12,  19,   8,   4],
       [  5,   3,   3,   9,  14,   7]], dtype=uint16)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atomic_pic_search(image, kernel_font, kernel_dilate, threshold):
    &#34;&#34;&#34;
    ** Fonction &#39;bas niveau de pic search atomic serialisable. **

    Notes
    -----
    * Cette fonction n&#39;est pas faite pour etre utilisee directement,
    il vaut mieux s&#39;en servir a travers ``laue.Experiment.get_diagrams``
    ou encore via ``laue.Experiment.__iter__`` car le context
    est mieu gere, les entrees sont plus simples et les sorties aussi.
    * Il n&#39;y a pas de verifications sur les entrees car elles sont faite
    dans les methodes de plus haut niveau.
    * Cette fonction n&#39;est pas parallelisee. Par contre les methodes
    de ``laue.Experiment`` gerent nativement le parallelisme.
    * L&#39;utilisation de cette fonction ne fera qu&#39;alourdir et ralentir votre code.

    Parameters
    ----------
    image : np.ndarray
        Image 2d en niveau de gris codee en np.uint16.
        C&#39;est l&#39;image brute, sans pre-traitement et avec le fond diffus.
    kernel_font : np.ndarray
        Le masque de l&#39;element structurant pour l&#39;estimation
        du fond par ouverture morphologique.
    kernel_dilate : np.ndarray
        Le masque de l&#39;element structurant pour la dilatation morphologique
        sur l&#39;image binarisee afin d&#39;aglomerer les grains proches.
    threshold : float
        Le niveau de seuillage relatif a la variance de l&#39;image.

    Returns
    -------
    list
        Une liste qui contient autant d&#39;elements de de pic trouves.
        Les element sont des dictionaires

    Examples
    --------
    &gt;&gt;&gt; import cv2
    &gt;&gt;&gt; from laue import atomic_pic_search
    &gt;&gt;&gt; from laue.utilities.image import read_image
    &gt;&gt;&gt; image_path = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt;
    &gt;&gt;&gt; image = read_image(image_path)
    &gt;&gt;&gt; kernel_font = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (21, 21))
    &gt;&gt;&gt; kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    &gt;&gt;&gt; threshold = 5.1
    &gt;&gt;&gt;
    &gt;&gt;&gt; res = atomic_pic_search(image, kernel_font, kernel_dilate, threshold)
    &gt;&gt;&gt; type(res)
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; len(res)
    78
    &gt;&gt;&gt; res[0][&#34;bbox&#34;]
    (1368, 1873, 6, 5)
    &gt;&gt;&gt; res[0][&#34;distortion&#34;]
    0.8471580534997302
    &gt;&gt;&gt; res[0][&#34;spot_im&#34;]
    array([[  8,  10,  16,  16,   8,   5],
           [ 11,  17,  67,  76,  13,   9],
           [  7,  19, 184, 229,  14,   6],
           [  9,   6,  12,  19,   8,   4],
           [  5,   3,   3,   9,  14,   7]], dtype=uint16)
    &gt;&gt;&gt; 
    &#34;&#34;&#34;
    # Binarisation de l&#39;image.
    bg_image = cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel_font, iterations=1)
    fg_image = image - bg_image
    thresh_image = (fg_image &gt; threshold*fg_image.std()).astype(np.uint8)
    dilated_image = cv2.dilate(thresh_image, kernel_dilate, iterations=1)

    # Detection des contours grossiers.
    outlines, _ = cv2.findContours(dilated_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    bbox = [cv2.boundingRect(outl) for outl in outlines]

    # Calcul des distortions.
    distortions_open = (2*np.sqrt(np.pi)) / np.array([
        cv2.arcLength(outl, True)/np.sqrt(cv2.contourArea(outl))
        for outl in outlines])

    # Preparation des arguments des spots.
    spots_args = [
        {
            &#34;bbox&#34;: (x, y, w, h),
            &#34;spot_im&#34;: fg_image[y:y+h, x:x+w],
            &#34;distortion&#34;: dis,
        }
        for dis, (x, y, w, h) in zip(distortions_open, bbox)]

    return spots_args</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="laue.Experiment"><code class="flex name class">
<span>class <span class="ident">Experiment</span></span>
<span>(</span><span>images=(), *, config_file=None, verbose=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Permet de travailler sur un lot d'images. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>images</code></strong> :&ensp;<code>str, iterable</code></dt>
<dd>
<ul>
<li>Toutes les images qui constituent l'experience.</li>
<li>Peut prendre plein de forme differentes:<ul>
<li>Iterable d'images. Chaque elements peut prendre 2 formes:<ul>
<li>Le chemin de l'image (str) absolu ou relatif.</li>
<li>L'image elle meme, matrice 2d en uint16 (np.ndarray).<ul>
<li>Il vaut mieux donner le nom de l'image que l'image elle-meme
car la gestion de la RAM sera meilleur, surtout si il y a
un nombre important d'images ce qui saturerait la memoire.</li>
</ul>
</li>
</ul>
</li>
<li>Repertoire. Nom du dossier qui contient recursivement les images.</li>
<li>Glob expression. Par example "mon_dossier/*.tiff".</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>
<ul>
<li>Permet d'afficher ou non des informations suplementaires.<ul>
<li>0 or False =&gt; N'affiche rien du tout, ne pollue pas l'ecran.</li>
<li>1 or True =&gt; Affiche seulement les etapes principales.</li>
<li>2 =&gt; Affiche les resultats intermediaires.</li>
<li>3 =&gt; Affiche vraiment beaucoup de choses (pas tres lisible).</li>
<li>4 =&gt; Affiche aussi des choses graphiques en plus de
tous ce qui est dans le terminal.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>max_space</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Le nombre minimum de pixels qui separent 2 taches.
Quand des taches ne sont pas separes par cet intevalle,
elles se retrouvent aglomerees. La valeur par defaut de 5
permet d'avoir une recherche tres hexaustive.</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>
<ul>
<li>Seuil relatif par raport a l'ecart type de l'image sans fond.</li>
<li>Plus la valeur est grande, moins on capture de spots:<ul>
<li>3.5 =&gt; Prend enormement de spots, beaucoup de fausses detection.</li>
<li>5.1 =&gt; Bon compromis, reste sensible sans trop capturer le fond.</li>
<li>10 =&gt; Asser selectif, ne prend que les taches qui ressortent beaucoup.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>font_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Diametre de l'element structurant qui permet d'evaluer le fond par
une ouverture morphologique. La valeur par defaut est 21,
normalement cette valeur est bien, il faut pas y toucher.</dd>
<dt><strong><code>ignore_errors</code></strong> :&ensp;<code>boolean</code>, optional</dt>
<dd>Permet d'ignorer certaine erreurs qui ne sont pas critiques.
La valeur par defaut et True.</dd>
<dt><strong><code>config_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Alias vers <code>**detector_parameters</code>.</dd>
<dt><strong><code>**detector_parameters</code></strong> :&ensp;<code>number</code></dt>
<dd>Les parametres de set_calibration de la camera deja connus.
Il servent dans la methode <code><a title="laue.experiment.base_experiment.Experiment.set_calibration" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.set_calibration">Experiment.set_calibration()</a></code>
a accelerer la recherche ou a la rendre plus precise.
Pour avoir le detail sur ces parametres, voir
<code><a title="laue.utilities.parsing.extract_parameters" href="utilities/parsing.html#laue.utilities.parsing.extract_parameters">extract_parameters()</a></code>.</dd>
<dt><strong><code>**bbox</code></strong> :&ensp;<code>number</code></dt>
<dd>Ce sont les limites min et max des parametres de set_calibration a ne pas depasser.
Les bornes minimum doivent etre precedes de '_min' et les maximum de '_max'.
Vous pouvez par example donner <code>Experiment(dd_min=90.0, dd_max=100.0)</code>.
Il sont utilises dans la methode <code><a title="laue.experiment.base_experiment.Experiment.set_calibration" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.set_calibration">Experiment.set_calibration()</a></code>.
Les noms possibles des parametres sont les meme que <code>**detector_parameters</code>
a l'exeption de <code>pixelsize, size, pxlsize et config_file</code> qui n'admettent
pas de bornes.
Les valeur par defaut sont:<pre><code>dd   : 60.0 mm          ; 80.0 mm
xbet : -0.9 degre       ; 0.9 degre
xgam : -0.9 degre       ; 0.9 degre
xcen : milieu - 150 pxl ; milieu + 150 pxl
ycen : milieu - 150 pxl ; milieu + 150 pxl
</code></pre>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Experiment:
    &#34;&#34;&#34;
    ** Permet de travailler sur un lot d&#39;images. **
    &#34;&#34;&#34;
    def __init__(self, images=(), *, config_file=None, verbose=False, **kwargs):
        &#34;&#34;&#34;
        Parameters
        ----------
        images : str, iterable
            - Toutes les images qui constituent l&#39;experience.
            - Peut prendre plein de forme differentes:
                - Iterable d&#39;images. Chaque elements peut prendre 2 formes:
                    - Le chemin de l&#39;image (str) absolu ou relatif.
                    - L&#39;image elle meme, matrice 2d en uint16 (np.ndarray).
                        - Il vaut mieux donner le nom de l&#39;image que l&#39;image elle-meme
                        car la gestion de la RAM sera meilleur, surtout si il y a
                        un nombre important d&#39;images ce qui saturerait la memoire.
                - Repertoire. Nom du dossier qui contient recursivement les images.
                - Glob expression. Par example &#34;mon_dossier/*.tiff&#34;.
        verbose : int, optional
            * Permet d&#39;afficher ou non des informations suplementaires.
                - 0 or False =&gt; N&#39;affiche rien du tout, ne pollue pas l&#39;ecran.
                - 1 or True =&gt; Affiche seulement les etapes principales.
                - 2 =&gt; Affiche les resultats intermediaires.
                - 3 =&gt; Affiche vraiment beaucoup de choses (pas tres lisible).
                - 4 =&gt; Affiche aussi des choses graphiques en plus de
                    tous ce qui est dans le terminal.

        max_space : int, optional
            Le nombre minimum de pixels qui separent 2 taches.
            Quand des taches ne sont pas separes par cet intevalle,
            elles se retrouvent aglomerees. La valeur par defaut de 5
            permet d&#39;avoir une recherche tres hexaustive.
        threshold : float, optional
            - Seuil relatif par raport a l&#39;ecart type de l&#39;image sans fond.
            - Plus la valeur est grande, moins on capture de spots:
                - 3.5 =&gt; Prend enormement de spots, beaucoup de fausses detection.
                - 5.1 =&gt; Bon compromis, reste sensible sans trop capturer le fond.
                - 10 =&gt; Asser selectif, ne prend que les taches qui ressortent beaucoup.
        font_size : int, optional
            Diametre de l&#39;element structurant qui permet d&#39;evaluer le fond par
            une ouverture morphologique. La valeur par defaut est 21,
            normalement cette valeur est bien, il faut pas y toucher.
        ignore_errors : boolean, optional
            Permet d&#39;ignorer certaine erreurs qui ne sont pas critiques.
            La valeur par defaut et True.
        config_file : str, optional
            Alias vers ``**detector_parameters``.
        **detector_parameters : number
            Les parametres de set_calibration de la camera deja connus.
            Il servent dans la methode ``laue.experiment.base_experiment.Experiment.set_calibration``
            a accelerer la recherche ou a la rendre plus precise.
            Pour avoir le detail sur ces parametres, voir
            ``laue.utilities.parsing.extract_parameters``.
        **bbox : number
            Ce sont les limites min et max des parametres de set_calibration a ne pas depasser.
            Les bornes minimum doivent etre precedes de &#39;_min&#39; et les maximum de &#39;_max&#39;.
            Vous pouvez par example donner ``Experiment(dd_min=90.0, dd_max=100.0)``.
            Il sont utilises dans la methode ``laue.experiment.base_experiment.Experiment.set_calibration``.
            Les noms possibles des parametres sont les meme que ``**detector_parameters``
            a l&#39;exeption de ``pixelsize, size, pxlsize et config_file`` qui n&#39;admettent
            pas de bornes.
            Les valeur par defaut sont:

                dd   : 60.0 mm          ; 80.0 mm
                xbet : -0.9 degre       ; 0.9 degre
                xgam : -0.9 degre       ; 0.9 degre
                xcen : milieu - 150 pxl ; milieu + 150 pxl
                ycen : milieu - 150 pxl ; milieu + 150 pxl
        &#34;&#34;&#34;
        assert hasattr(images, &#34;__iter__&#34;), (&#34;&#39;images&#39; must to be iterable. &#34;
            f&#34;It can not be of type {type(images).__name__}.&#34;)
        assert isinstance(verbose, int), f&#34;&#39;verbose&#39; has to be int, not {type(verbose).__name__}.&#34;
        
        max_space = kwargs.get(&#34;max_space&#34;, 5)
        assert isinstance(max_space, int), &#34;&#39;max_space&#39; has to be an integer, not a %s.&#34; \
            % type(max_space).__name__
        assert max_space &gt;= 1, f&#34;&#39;max_space&#39; has to be positive. His value is &#39;{max_space}&#39;.&#34;
        threshold = kwargs.get(&#34;threshold&#34;, 5.1)
        assert isinstance(threshold, float), \
            f&#34;&#39;threshold&#39; has to be float, not a {type(threshold).__name__}.&#34;
        assert 2.0 &lt; threshold &lt; 80.0, \
            f&#34;Le seuil doit etre compris entre 2 et 50, il vaut &#39;{threshold}&#39;.&#34;
        font_size = kwargs.get(&#34;font_size&#34;, 21)
        assert isinstance(font_size, int), \
            f&#34;&#39;font_size&#39; has to be an integer, not a {type(font_size).__name__}.&#34;
        assert font_size &gt;= 2, (&#34;&#39;font_size&#39; doit etre superieur a 1. &#34;
            f&#34;Il ne peut pas valoir {font_size}.&#34;)
        ignore_errors = kwargs.get(&#34;ignore_errors&#34;, True)
        assert isinstance(ignore_errors, bool), \
            f&#34;&#39;ignore_errors&#39; has to be a boolean, not a {type(ignore_errors).__name__}.&#34;

        if config_file is not None:
            kwargs[&#34;config_file&#34;] = config_file

        self._images = images

        self.verbose = verbose
        self.max_space = max_space
        self.threshold = threshold
        self.font_size = font_size
        self.ignore_errors = ignore_errors
        self.kwargs = kwargs

        # Precalul des constantes.
        self.kernel_font = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (self.font_size, self.font_size))
        self.kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (self.max_space, self.max_space))
        self.transformer = transformer.Transformer(verbose=self.verbose) # Outil permetant de faire les transformations geometriques.
        self._predictors = {} # Predicteurs bases sur un reseau de neurones.

        # Declaration des attributs interne de memoire.
        self._len = None # Nombre de diagrames lues.
        self._buff_diags = [] # La liste ordonnee des diagrames lus.

        self._mean_bg = None # Fond diffus estime par la moyenne de toutes les images.
        self._shape = None # Les dimensions des matrices des images xy.
        self._calibration_parameters = None # Le dictionaire des parametres geometrique de la camera.
        self._gnomonic_matrix = None # Les matrices de transformation.

        self._images_iterator = None # Iterateur unique des informations des images.
        self._diagrams_iterator = None # Iterateur unique qui genere les diagrammes.
        self._axes_iterator = None # Iterateur unique qui cede les axes de zonne de chaque diagramme.
        self._subsets_iterator = None # Iterateur unique qui cede les bouts de grains.

    def set_calibration(self, *diagrams):
        &#34;&#34;&#34;
        ** Calibration de la camera. **

        Notes
        -----
        * Ne nessecite aucune connaissances prealable sur le christal.
        * Il n&#39;y a pas besoin d&#39;avoir un diagramme bien calibre, il se debrouille tout seul.
        * Cette fonction peut parfois etre lente (plusieur minutes)!
        * Si vous connaissez les parametres, fournissez-les, ca ira plus vite!
        * Si cette methode a deja ete appelee une fois, elle retourne
            immeditement le resultat sans refaire les calculs.

        Parameters
        ----------
        *diagrams : optional
            Les ou le diagramme.s qui vont servir a faire la calibration.
            Si aucun diagramme n&#39;est precise, cette methode recherche par elle meme
            les diagrammes qu&#39;elle trouve convaincant parmis ceux qui sont disponibles.
            Il doivent etre de type ``laue.diagram.LaueDiagram``.

        Returns
        -------
        dict 
            Le dictionaire qui a chaque non de parametre, associe sa valeur numerique.
            Les clefs sont les suivantes: &#34;dd&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;xbet&#34;, &#34;xgam&#34; and &#34;pixelsize&#34;

        Raises
        ------
        KeyError
            Si l&#39;utilisateur n&#39;a pas precise les parametres vraiment indispenssables.
        ValueError
            Si il y a des incoherences dans les parametres.

        Example
        -------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(image, dd_min=69.5, dd_max=71.5, xbet=0.008)
        &gt;&gt;&gt; parameters = experiment.set_calibration()
        &gt;&gt;&gt; sorted(parameters.keys())
        [&#39;dd&#39;, &#39;pixelsize&#39;, &#39;xbet&#39;, &#39;xcen&#39;, &#39;xgam&#39;, &#39;ycen&#39;]
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if self._calibration_parameters is not None: # Si on peut retourner directement,
            return self._calibration_parameters # on ne s&#39;en prive pas.

        assert all(isinstance(diag, LaueDiagram) for diag in diagrams), \
            &#34;Tous les diagrammes doivent etre de type &#39;LaueDiagram&#39;. Or ce n&#39;est pas le cas.&#34;

        if self.verbose:
            print(&#34;Calibration...&#34;)
            if self.verbose &gt;= 2:
                print(&#34;\tPrise en compte des parametres fournis...&#34;)

        # Constantes.
        PIXELSIZE_REF = {(2048, 2048): 0.079856, # Taille des pixels fonction de la camera.
                         (2018, 2016): 0.0734,
                         (2594, 2748): 0.031}
        PARAM_SET = {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;} # Les parametres non deductibles.
        PARAM_MIN = {&#34;dd&#34;: 60.0, # Les bornes minimale par defaut.
                     &#34;xbet&#34;: -.9,
                     &#34;xgam&#34;: -.9,
                     &#34;xcen&#34;: self.get_images_shape()[0]/2 - 150,
                     &#34;ycen&#34;: self.get_images_shape()[0]/2 - 150}
        PARAM_MAX = {&#34;dd&#34;: 80.0, # Les bornes maximales par defaut.
                     &#34;xbet&#34;: .9,
                     &#34;xgam&#34;: .9,
                     &#34;xcen&#34;: self.get_images_shape()[0]/2 + 150,
                     &#34;ycen&#34;: self.get_images_shape()[1]/2 + 150}

        # Recuperation des parametres fournis et deductibles.
        from laue.utilities.parsing import extract_parameters
        given_parameters = extract_parameters(ignore_missing=True, **self.kwargs)
        if (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() in PIXELSIZE_REF):
            given_parameters[&#34;pixelsize&#34;] = PIXELSIZE_REF[self.get_images_shape()]
        
        elif (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() not in PIXELSIZE_REF):
            raise KeyError(&#34;Vous devez fournir le parametre &#39;pixelsize&#39;.\n&#34;
                f&#34;Les images font {self.get_images_shape()} pxl**2. &#34;
                f&#34;Or, seul les &#39;pixelsize&#39; des images {&#39; et &#39;.join(map(str, PIXELSIZE_REF))} sont connus.&#34;)

        # Recuperation des bornes.
        given_min = extract_parameters(ignore_missing=True, **{
            param[:-4]: value
            for param, value in self.kwargs.items()
            if param.endswith(&#34;_min&#34;) and len(param) &gt; 4})
        given_max = extract_parameters(ignore_missing=True, **{
            param[:-4]: value
            for param, value in self.kwargs.items()
            if param.endswith(&#34;_max&#34;) and len(param) &gt; 4})
        parameters_min = {param: given_min.get(param, PARAM_MIN[param]) for param in PARAM_SET}
        parameters_max = {param: given_max.get(param, PARAM_MAX[param]) for param in PARAM_SET}
        
        for param in PARAM_SET: # Verification de la coherence des bornes.
            if parameters_min[param] &gt;= parameters_max[param]:
                raise ValueError(f&#34;Les bornes du parametre {repr(param)} sont inversees, &#34;
                    f&#34;{param}_min={parameters_min[param]} et {param}_max={parameters_max[param]}.&#34;)

        # Valeur de departs des parametres.
        initial_parameters = { # Ce sont les parametres initiaux pour la descente de gradient.
            par: given_parameters.get(par,
                .5*(parameters_min[par] + parameters_max[par]))
            for par in PARAM_SET}
       
        for par, val in initial_parameters.items(): # Verification.
            if par in given_parameters and par in given_min:
                if given_parameters[par] &lt; given_min[par]:
                    raise ValueError(f&#34;Vous avez imposes {par}_min={given_min[par]} &#34;
                        f&#34;et en meme temp vous avez donnes {par}={val}!&#34;)
            if par in given_parameters and par in given_max:
                if given_parameters[par] &gt; given_max[par]:
                    raise ValueError(f&#34;Vous avez imposes {par}_max={given_max[par]} &#34;
                        f&#34;et en meme temps vous avez donnes {par}={val}!&#34;)

        # Parametres restants.
        unknown_parameters = PARAM_SET - set(given_parameters)
        if not unknown_parameters: # Si Il n&#39;y a rien a calculer.
            self._calibration_parameters = given_parameters
            if self.verbose:
                if self.verbose &gt;= 2:
                    print(&#34;\t\tOK: Tout est fournis, il n&#39;y a rien a faire.&#34;)
                print(f&#34;\tOK: Calibration terminee: {given_parameters}&#34;)
            return self._calibration_parameters

        # Extraction d&#39;un diagramme interressant.
        if self.verbose &gt;= 2:
            print(&#34;\tRecuperation des diagrammes interressants...&#34;)
        if not diagrams: # Si l&#39;utilisateur ne nous aide pas a trouver les bons diagrammes.
            diagrams = []
            for i, dia in enumerate(self):
                if i &gt; 60: # On ne s&#39;interesse qu&#39;a la premiere minute.
                    break
                diagrams.append(dia)
            best_diagrams = [sorted(diagrams, key=lambda dia: dia.get_quality(), reverse=True).pop()]
        else: # Si l&#39;utilisateur nous en fournit.
            best_diagrams = diagrams # C&#39;est un tuple et non pas une liste mais c&#39;est pas genant.
        if self.verbose &gt;= 2:
            for dia in best_diagrams:
                print(f&#34;\t\t{dia.get_id()}&#34;)

        # Vectorisation des donnees pour de bonnes perfs.
        min_size = min(
            200,
            min(len(dia) for dia in best_diagrams)
            ) # Le plus petit nombre de points.
        spots_position = np.array(
            [dia.get_positions(n=min_size, sort=&#34;quality&#34;)
             for dia in best_diagrams],
            dtype=np.float32)
        spots_position = np.swapaxes(spots_position, 0, 1) # shape: (2, n_diagrams, nbr_spots)

        # Perparations des parametres pour la suite.
        vect_labels = tuple(unknown_parameters) # On recupere les nom des parametres inconus seulement.
        bounds = [(parameters_min[name], parameters_max[name]) for name in vect_labels] # Les limites des variables.
        args = (given_parameters, vect_labels, spots_position) # Les arguments en plus de la fonction de cout.
        if self.verbose &gt;= 2:
            print(f&#34;\tcalibration des parametres {vect_labels}&#34;)
            print(f&#34;\tbornes min: {tuple(b_min for b_min, _ in bounds)}&#34;)
            print(f&#34;\tbornes max: {tuple(b_max for _, b_max in bounds)}&#34;)
        
        # Recherche rapide d&#39;un minimum par descente de gradient.
        from scipy import optimize # On ne l&#39;importe que ici car on est pas sur de s&#39;en servir.
        if self.verbose &gt;= 2:
            print(&#34;\tOptimsation globale, algo genetique...&#34;)
        
        if multiprocessing.current_process().name == &#34;MainProcess&#34; and os.cpu_count() &gt; 4:
            attrs = [&#34;transformer&#34;, &#34;verbose&#34;]
            self_bis = collections.namedtuple(&#34;PartialExperiment&#34;, attrs, defaults=[getattr(self, attr) for attr in attrs])()
            opt_res = optimize.differential_evolution(
                _Picklable(cloudpickle.dumps(self_bis), Experiment._calibration_cost,
                    {name: val for name, val in zip((&#34;known_params&#34;, &#34;vect_labels&#34;, &#34;spots_position&#34;), args)}
                    ),
                updating=&#34;deferred&#34;,
                bounds=bounds,
                disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
                polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
                popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
                workers=-1) # Pour utiliser tous les cpus.
        else:
            opt_res = optimize.differential_evolution(
                self._calibration_cost,
                bounds=bounds,
                args=args,
                disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
                polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
                popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
                workers=1) # Pour ne pas creer de sous processus.
                # C&#39;est plus rapide de ne pas creer de sous processus que d&#39;en faire... car cloudpickle est lent!
        if self.verbose &gt;= 2:
            print(f&#34;\t\tOk: cout final = {opt_res[&#39;fun&#39;]}&#34;)
        fit_parameters_vect = opt_res[&#34;x&#34;]
        
        # Mise en forme du resultat.
        fit_parameters = {name: fit_parameters_vect[i] for i, name in enumerate(vect_labels)}
        self._calibration_parameters = {**given_parameters, **fit_parameters}
        if self.verbose:
            print(f&#34;\tOK: set_calibration terminee: {self._calibration_parameters}&#34;)
        return self._calibration_parameters

    def _calibration_cost(self, params_as_vect, known_params, vect_labels, spots_position):
        &#34;&#34;&#34;
        ** Help for ``set_calibration``. **

        Parameters
        ----------
        params_as_vect : np.ndarray
            Le vecteur des valeurs inconues de parametres.
        :param known_params : dict
            Dictionaire des parametres connus.
        :param vect_labels : tuple
            Le tuple des nom des parametres associes au vecteur.
        spots_position : np.ndarray
            Coordonnees des points x, y des diagrammes de reference.
            shape = (2, n_diagrams, nbr_spots)
        &#34;&#34;&#34;
        # Projection gnomonique.
        _, n_diagrams, nbr_spots = spots_position.shape
        unknown_parameters = {name: value for name, value in zip(vect_labels, params_as_vect)}
        parameters = {**unknown_parameters, **known_params}
        gnom_spots_x, gnom_spots_y = self.transformer.cam_to_gnomonic(*spots_position, parameters) # shape: (n_diagrams, nbr_pic)

        # Recherche des axes de zones intensifs.
        gnom_spots_x = ((gnom_spots_x
                        - np.repeat(gnom_spots_x.mean(axis=-1)[..., np.newaxis], nbr_spots, axis=-1)
                        ) / np.repeat(gnom_spots_x.std(axis=-1)[..., np.newaxis], nbr_spots, axis=-1))
        gnom_spots_y = ((gnom_spots_y
                        - np.repeat(gnom_spots_y.mean(axis=-1)[..., np.newaxis], nbr_spots, axis=-1)
                        ) / np.repeat(gnom_spots_y.std(axis=-1)[..., np.newaxis], nbr_spots, axis=-1))
        thetas, dists = self.transformer.hough(gnom_spots_x, gnom_spots_y) # shape: (n_diagrams, nbr_pic*(nbr_pic-1)/2)
        clusters = self.transformer.hough_reduce(thetas, dists, # shape: (n_diagrams,)
            nbr=6, tol=0.035) # On prend des qu&#39;il y a 6 points environ allignes.

        # Calcul de l&#39;erreur.
        projection = np.mean([np.log(1 + self.transformer.dist_line( # compris generalement entre [0.007, 0.3]
                                clusters[i][0, :], clusters[i][1, :],
                                gnom_spots_x[i, :], gnom_spots_y[i, :]).min(axis=0, initial=1.0)).mean()
                              if clusters[i].shape[-1] else 1.0 # Si il n&#39;y a pas de droite, c&#39;est qu&#39;on est dans les choux.
                            for i in range(n_diagrams)]) # Moyenne des ecarts des projetes des points sur la droite la plus proche.
        scattering = np.mean([np.log(
                                    (gnom_spots_x[i, :] - gnom_spots_x[i, :].mean())**2
                                  + (gnom_spots_y[i, :] - gnom_spots_y[i, :].mean())**2
                                  + 1)
                            for i in range(n_diagrams)]) # Eparpillement [0.1, 0.95], &gt; =&gt; bien eparpille
        cost = projection * scattering**(-4)

        if self.verbose &gt;= 3:
            print(f&#34;\t\tCurrent parameters: {unknown_parameters}&#34;)
            print(f&#34;\t\tCurrent cost: {cost}&#34;)
            if self.verbose &gt;= 4:
                import matplotlib.pyplot as plt
                plt.clf()
                for i in range(n_diagrams):
                    plt.subplot(n_diagrams, 3, 1 + 3*i)
                    plt.title(f&#34;diagramme {i+1}, plan camera&#34;)
                    plt.scatter(spots_position[0, i, ...], spots_position[1, i, ...])

                    plt.subplot(n_diagrams, 3, 2 + 3*i)
                    plt.title(f&#34;diagramme {i+1}, plan gnomonic&#34;)
                    plt.scatter(gnom_spots_x[i, :], gnom_spots_y[i, :])
                    for angle, dist in clusters[i].transpose():
                        v = np.array([np.cos(angle), np.sin(angle)])
                        u = np.array([np.sin(angle), -np.cos(angle)])
                        p = dist*v
                        plt.axline(p, p+u, lw=0.5, color=&#34;r&#34;)

                    plt.subplot(n_diagrams, 3, 3 + 3*i)
                    plt.title(f&#34;diagramme {i+1}, hough&#34;)
                    plt.scatter(thetas[i, :], dists[i, :])
                    plt.scatter(clusters[i][0], clusters[i][1])
                plt.draw()
                plt.pause(1e-6)

        return cost

    def get_diagrams(self, *, tense_flow=False):
        &#34;&#34;&#34;
        ** Genere les diagrammes de l&#39;experience. **

        C&#39;est la qu&#39;est effectue le pic search.

        Notes
        -----
        * Performances:
            * Sur un PC (intel core i7, ssd, 8 coeurs), met environ 37 ms/diagramme.
            * Sur un PC (intel centrino, hdd, 2 coeurs), met environ 530 ms/diagramme.

        Parameters
        ----------
        tense_flow : boolean
            * True : Permet de travailler a flux tendu, c&#39;est a dire
            de cede les diagrammes au fur a meusure qu&#39;ils sont crees.
                * Le generateur termine quand toutes les images sont lues ou
                que le generateur d&#39;images leve un ``StopIteration``.
                * A chaque nouvel appel de cette methode, l&#39;iteration
                recommence a partir du debut et l&#39;ordre reste inchange.
                * Equivalent a ``laue.experiment.base_experiment.Experiment.__iter__``.
            * False. Sinon, attend que tous les diagrammes
            soient lues afin de tout renvoyer en meme temps.

        Returns
        -------
        list
            La liste des diagrammes de type ``laue.diagram.LaueDiagram``.

        Yields
        ------
        laue.diagram.LaueDiagram
            * Chaque diagram extrait au fur a mesure qu&#39;il arrive.
            * L&#39;ordre est concerve pour chaque appel de cette methode a flux tendu.
            * A chaque appel on repars du debut, meme si un autre appel n&#39;est pas termine.
            * Les sections critiques sont verouillees donc cette methode supporte le multithread.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(images)
        &gt;&gt;&gt;
        &gt;&gt;&gt; diagrams = experiment.get_diagrams()
        &gt;&gt;&gt; type(diagrams)
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(diagrams.pop())
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def cast_to_diagram(spots_args, name, image=None):
            &#34;&#34;&#34;
            Met en forme du pic search pour en faire des diagrames.
            &#34;&#34;&#34;
            laue_diagram = LaueDiagram(name, experiment=self)
            spots = [Spot(diagram=laue_diagram, identifier=i, **spot_args)
                     for i, spot_args in enumerate(spots_args)]
            laue_diagram._set_spots(spots)
            if image is not None and (
                    (not os.path.exists(name)) or (psutil is not None and psutil.virtual_memory().percent &lt; 50)
                    ):
                laue_diagram._set_image(image)
            return laue_diagram

        def update_len(func):
            &#34;&#34;&#34;
            Tient a jour la longueur de l&#39;experience.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                for i, element in enumerate(func(*func_args, **func_kwargs)):
                    yield element
                self._len = i + 1

            return decorate

        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Extraction des diagrammes...&#34;)

                for i, diag in enumerate(func(*func_args, **func_kwargs)):
                    if self.verbose &gt;= 2:
                        print(f&#34;\tdiagramme num {i} extrait: &#34;
                              f&#34;(...{diag.get_id()[-20:]}) &#34;
                              f&#34;avec {len(diag)} spots&#34;)
                    yield diag
                if self.verbose:
                    print(&#34;\tOK: Tous les diagrammes sont extraits.&#34;)
            
            return decorate

        @update_len
        @show_iterator_state
        def _diagram_extractor(self):
            &#34;&#34;&#34;
            Premiere vraie lecture. Cede les diagrammes.
            &#34;&#34;&#34;
            if multiprocessing.current_process().name == &#34;MainProcess&#34;:
                from laue.core.pic_search import _pickelable_pic_search
                from laue.utilities.multi_core import limited_imap
                with multiprocessing.Pool() as pool:
                    yield from (
                        cast_to_diagram(spots_args, name, image)
                        for spots_args, (name, image) in limited_imap(pool,
                            _pickelable_pic_search,
                            (
                                (
                                    (
                                        image,
                                        self.kernel_font,
                                        self.kernel_dilate,
                                        self.threshold
                                    ),
                                    (name, image)
                                )
                                for name, image in self.read_images()
                            )
                        )
                    )
            else:
                from laue import atomic_pic_search
                yield from (
                    cast_to_diagram(
                        atomic_pic_search(
                            image,
                            self.kernel_font,
                            self.kernel_dilate,
                            self.threshold
                        ),
                        name,
                        image
                    )
                    for name, image in self.read_images()
                )
        
        if self._diagrams_iterator is None:
            self._diagrams_iterator = iter(_diagram_extractor(self))

        from laue.utilities.multi_core import RecallingIterator
        return (
            (lambda x: (yield from x))(RecallingIterator(self._diagrams_iterator, mother=self))
            if tense_flow else list(RecallingIterator(self._diagrams_iterator, mother=self)))

    def find_subsets(self, *, tense_flow=False, **kwds):
        &#34;&#34;&#34;
        ** Estime les grains dans chaque diagrame. **

        Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_subsets``.
        Le resultat est le meme que: ``[diag.find_subsets(**kwds) for diag in self]``

        Notes
        -----
        * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.
        
        Parameters
        ----------
        tense_flow : boolean
            * True : Permet de travailler a flux tendu, c&#39;est a dire
            de ceder les bouts de grains des diagrammes au fur a meusure qu&#39;ils sont trouves.
                * Le generateur termine quand toutes les images sont lues ou
                que le generateur d&#39;images leve un ``StopIteration``.
                * A chaque nouvel appel de cette methode, l&#39;iteration
                recommence a partir du debut et l&#39;ordre reste inchange.
                * Equivalent a ``(diag.find_subsets(**kwds) for diag in self)``.
            * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
                * C&#39;est equvalent a ``[diag.find_subsets(**kwds) for diag in self]``.
                * Au lieu de retourner un generateur, retourne une liste.
        **kwds
            Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_subsets``.
            Se sont aussi ceux de la fonction ``laue.diagram.LaueDiagram.find_zone_axes``.

        Returns
        -------
        list
            Pour chaque diagramme de cette experience, cede une estimation des grains.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(experiment.find_subsets())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(experiment.find_subsets(tense_flow=True))
        &lt;class &#39;generator&#39;&gt;
        &gt;&gt;&gt; type(next(iter(experiment.find_subsets(tense_flow=True))))
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Estimation des grains...&#34;)
                
                for i, groups in enumerate(func(*func_args, **func_kwargs)):
                    if self.verbose &gt;= 2:
                        print(f&#34;\tgrain du diagramme num {i} estimes: il y a {len(groups)} clusters&#34;)
                    yield groups

                if self.verbose:
                    print(&#34;\tOK: Tous les clusters de grains sont estimes.&#34;)

            return decorate

        @show_iterator_state
        def _subsets_extractor(self):
            if multiprocessing.current_process().name == &#34;MainProcess&#34;:
                from laue.core.subsets import _pickelable as atomic_find_subsets
                from laue.utilities.multi_core import limited_imap
                with multiprocessing.Pool() as pool:
                    yield from (
                        diag.find_subsets(_atomic_subsets_res=args)
                        for diag, args
                        in zip(
                            self,
                            limited_imap(pool,
                                atomic_find_subsets,
                                (   # transformer, gnomonics, dmax, nbr, tol
                                    diag.find_subsets(**kwds, _get_args=True)
                                    for _, diag in zip(self.find_zone_axes(tense_flow=True, **kwds), self)
                                )
                            )
                        )
                    )
            else:
                yield from (diag.find_subsets(**kwds) for diag in self)

        if not tense_flow:
            return list(self.find_subsets(tense_flow=True, **kwds))

        if self._subsets_iterator is None:
            self._subsets_iterator = iter(_subsets_extractor(self))

        from laue.utilities.multi_core import RecallingIterator
        return (lambda x: (yield from x))(RecallingIterator(self._subsets_iterator, mother=self))

    def find_zone_axes(self, *, tense_flow=False, **kwds):
        &#34;&#34;&#34;
        ** Recherche l&#39;ensemble des axes de zones. **

        Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_zone_axes``.
        Le resultat est le meme que: ``[diag.find_zone_axes(**kwds) for diag in self]``

        Notes
        -----
        * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.

        Parameters
        ----------
        tense_flow : boolean
            * True : Permet de travailler a flux tendu, c&#39;est a dire
            de ceder les axes des diagrammes au fur a meusure qu&#39;ils sont trouves.
                * Le generateur termine quand toutes les images sont lues ou
                que le generateur d&#39;images leve un ``StopIteration``.
                * A chaque nouvel appel de cette methode, l&#39;iteration
                recommence a partir du debut et l&#39;ordre reste inchange.
                * Equivalent a ``(diag.find_zone_axes(**kwds) for diag in self)``.
            * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
                * C&#39;est equvalent a ``[diag.find_zone_axes(**kwds) for diag in self]``.
                * Au lieu de retourner un generateur, retourne une liste.
        **kwds
            Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_zone_axes``.

        Returns
        -------
        list
            Pour chaque diagramme de cette experience, cede la liste
            des axes de zones du diagramme. Les elements de l&#39;ensemble
            sont de type ``laue.zone_axis.ZoneAxis``.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(experiment.find_zone_axes())
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(experiment.find_zone_axes(tense_flow=True))
        &lt;class &#39;generator&#39;&gt;
        &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))))
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))).pop())
        &lt;class &#39;laue.zone_axis.ZoneAxis&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Extraction des axes de zone...&#34;)
                
                for i, axes in enumerate(func(*func_args, **func_kwargs)):
                    if self.verbose &gt;= 2:
                        print(f&#34;\taxes du diagramme num {i} trouves: il y en a {len(axes)}&#34;)
                    yield axes

                if self.verbose:
                    print(&#34;\tOK: Tous les axes de zone sont extraits.&#34;)

            return decorate

        @show_iterator_state
        def _axes_extractor(self):
            &#34;&#34;&#34;
            Premiere vraie extraction.
            &#34;&#34;&#34;
            if multiprocessing.current_process().name == &#34;MainProcess&#34;:
                # Compilation et serialisation des equations.
                self.transformer.compile(self.set_calibration(), transform=&#34;cam_to_gnomonic&#34;)
                transformer_ser = cloudpickle.dumps(self.transformer)

                # Parallelisation des fils.
                from laue.core.zone_axes import _get_zone_axes_pickle
                from laue.utilities.multi_core import limited_imap
                with multiprocessing.Pool() as pool:
                    yield from (
                        diag.find_zone_axes(_axes_args=args)
                        for diag, args
                        in zip(
                            self,
                            limited_imap(pool,
                                _get_zone_axes_pickle,
                                ( # transformer, gnomonics, dmax, nbr, tol
                                    (transformer_ser, *diag.find_zone_axes(**kwds, _get_args=True))
                                    for diag in self
                                )
                            )
                        )
                    )

            else:
                yield from (diag.find_zone_axes(**kwds) for diag in self)

        if not tense_flow:
            return list(self.find_zone_axes(tense_flow=True, **kwds))

        if self._axes_iterator is None:
            self._axes_iterator = iter(_axes_extractor(self))

        from laue.utilities.multi_core import RecallingIterator
        return (lambda x: (yield from x))(RecallingIterator(self._axes_iterator, mother=self))

    def _get_gnomonic_matrix(self):
        &#34;&#34;&#34;
        ** Calcul les matrices de transformation gnomonic **

        Notes
        -----
        * Permet via ``cv2`` d&#39;avoir une image dans le plan gnomonic.
        * Les tailles des image sont le meme dans le plan
        de la camera et dans le plan gnommonic.

        Returns
        -------
        np.ndarray(np.float32) : map_x
            La premiere matrice que l&#39;on peut voir comme une fonction
            de ``f(x_gnomon, y_gnomon) -&gt; x_camera``, avec les coordonnees
            gnomonique exprimees en pxl.
        np.ndarray(np.float32) : map_y
            La seconde matrice ``f(x_gnomon, y_gnomon) -&gt; y_camera``
        tuple : bornes
            Les limite en mm des pixel extremes:
            (xmin, xmax, ymin, ymax)
        &#34;&#34;&#34;
        if self._gnomonic_matrix is not None:
            return self._gnomonic_matrix

        if self.verbose:
            print(&#34;Recuperation de la matrice gnomonic...&#34;)
        # Recherche des bornes.
        x_max, y_max = self.get_images_shape()
        xg, yg = self.transformer.cam_to_gnomonic(
            *np.meshgrid(np.arange(x_max), np.arange(y_max), copy=False),
            self.set_calibration())
        bornes = (xg.min(), xg.max(), yg.min(), yg.max())
        
        del xg, yg
        x_side = np.linspace(bornes[0], bornes[1], num=x_max)
        y_side = np.linspace(bornes[2], bornes[3], num=y_max)

        # Fonction inverse.
        map_x, map_y = self.transformer.gnomonic_to_cam(
            *np.meshgrid(x_side, y_side, copy=False),
            self.set_calibration(), dtype=np.float32)
        # map_x, map_y = map_x.astype(np.float32, copy=False), map_y.astype(np.float32, copy=False) # cv2 en a besoin.

        if self.verbose:
            print(&#34;\tOK: La matrice gnomonic est calculee.&#34;)

        # Sauvegarde
        if psutil is not None and psutil.virtual_memory().percent &lt; 75:
            self._gnomonic_matrix = (map_x, map_y, bornes)
            return self._gnomonic_matrix
        return (map_x, map_y, bornes)

    def get_mean(self):
        &#34;&#34;&#34;
        ** Estime la moyenne des images. **

        Cela permet d&#39;avoir une estimation du fond diffus.

        Notes
        -----
        * A cause des arrondis machine, seule les 9e15 permieres images sont considerees.
        * Ne retourne pas tant que toutes les images d&#39;entree ne sont pas lues.

        Returns
        -------
        np.ndarray
            L&#39;image de la moyenne des images en matrice 2d uint16.
        &#34;&#34;&#34;
        if self._mean_bg is not None:
            return self._mean_bg

        if self.verbose:
            print(&#34;Estimation du fond par la moyenne...&#34;)

        im_gen = iter((image.astype(np.float64) for _, image in self.read_images()))
        try:
            mean_array = next(im_gen)
        except StopIteration as err:
            raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
        for i, image in enumerate(im_gen):
            mean_array = i/(i+1) * mean_array + 1/(i+1) * image

        self._mean_bg = mean_array.astype(np.uint16)

        if self.verbose:
            print(&#34;\tOK: La moyenne des images est estimee.&#34;)
        return self._mean_bg

    def get_images_shape(self):
        &#34;&#34;&#34;
        ** Recupere les dimensions des images. **

        Returns
        -------
        tuple
            (nbr de lignes, nbr de colones), de type (int, int).
        &#34;&#34;&#34;
        if self._shape is not None:
            return self._shape

        try:
            _, image = next(iter(self.read_images()))
        except StopIteration as err:
            raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
        self._shape = image.shape
        return self._shape

    def read_images(self):
        &#34;&#34;&#34;
        ** Cede le contenu des images. **

        Notes
        -----
        * Reitere depuis le debut a chaque appel.
        * Il peut y avoir plusieurs appels en parallele
        sans que cela ne genere de conflits. Dumoins tans que des threads
        ne sont pas utilises, car il n&#39;y a pas de mecanisme de verrou.
        * A chaque appel de cette methode, l&#39;ordre est conserve.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.

        Yields
        ------
        name : str
            Le nom de l&#39;image (path si possible)
        image : np.ndarray
            Le contenu de l&#39;image

        Raises
        ------
        TypeError
            Si l&#39;image n&#39;est pas bien typee.
        FileNotFoundError
            Si le chemin de l&#39;image n&#39;est pas correcte.
        ValueError
            Si les images ne sont pas de la meme taille.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt; for image in laue.Experiment(images):
        ...     pass
        ...
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        from laue.utilities.multi_core import RecallingIterator, prevent_generator_size

        def read_and_check_any_image(image_info, image_num):
            &#34;&#34;&#34;
            Soit retroune directement, soit lit le fichier.
            Retourne le nom de l&#39;image et l&#39;image elle-meme.
            Renvoi None, None si il faut ignorer cette image.
            &#34;&#34;&#34;            
            # Mise en forme.
            if isinstance(image_info, str):
                image_name = image_info
                from laue.utilities.image import read_image
                image = read_image(image_info, ignore_errors=self.ignore_errors)
                if image is None:
                    return None, None
            elif isinstance(image_info, np.ndarray):
                image_name = f&#34;image_{image_num}&#34;
                image = image_info
            else:
                raise TypeError(&#34;L&#39;image doit etre de type str ou np.array, &#34;
                    f&#34;pas {type(image_info).__name__}.&#34;)

            # Verifications
            if not isinstance(image, np.ndarray):
                raise TypeError(f&#34;L&#39;image doit etre un array numpy, pas un {type(image).__name__}.&#34;)
            if image.ndim != 2:
                raise TypeError(f&#34;L&#39;image {image_name} doit etre en niveau de gris pas de dimension {image.ndim}.&#34;)
            if image.dtype != np.uint16:
                raise TypeError(f&#34;L&#39;image {image_name} doit etre encodee en uint16, pas {image.dtype}.&#34;)
            if self._shape is None:
                self._shape = image.shape
            if self._shape != image.shape:
                raise ValueError(f&#34;L&#39;image {image_name} a pour taille {image.shape} tandis que les images &#34;
                    f&#34;precedentes ont pour taille {self._shape}. Les images ne sont pas issues de la meme experience.&#34;)

            return image_name, image

        def show_iterator_state(func):
            &#34;&#34;&#34;
            Insere des commentaires.
            &#34;&#34;&#34;
            def decorate(*func_args, **func_kwargs):
                if self.verbose:
                    print(&#34;Lecture des images...&#34;)
                
                for image_info in func(*func_args, **func_kwargs):
                    yield image_info
                    if self.verbose &gt;= 2:
                        print(f&#34;\timage : (...{str(image_info)[-20:]}) cedee.&#34;)

                if self.verbose:
                    print(&#34;\tOK: Toutes les images sont lues.&#34;)

            return decorate

        @show_iterator_state
        def _images_extractor():
            &#34;&#34;&#34;
            Premiere vraie extraction.
            &#34;&#34;&#34;
            # Convertion str vers generateur
            if isinstance(self._images, str): # Dans le cas ou une chaine de caractere
                if os.path.isdir(self._images): # decrit l&#39;ensemble des images.
                    self._images = sorted(
                        os.path.join(father, file)
                        for father, _, files in os.walk(self._images)
                        for file in files)
                else:
                    self._images = sorted(glob.iglob(self._images, recursive=True))

            yield from self._images

        @prevent_generator_size(min_size=1)
        def jump_map(multi_image_iterator):
            image_num = 0
            for image_info in multi_image_iterator:
                image_name, image = read_and_check_any_image(image_info, image_num)
                if image is None:
                    continue
                image_num += 1
                yield image_name, image

        if self._images_iterator is None:
            self._images_iterator = iter(_images_extractor())

        return jump_map(RecallingIterator(self._images_iterator, mother=self))

    def save_file(self, filename):
        &#34;&#34;&#34;
        ** Enregistre un fichier contenant des informations. **

        Notes
        -----
        * Les extensions prises en charge sont ``.det``.
        * Pour les fichiers propres a chaque diagrammes, voir ``laue.diagram.LaueDiagram.save_file``.

        Parameters
        ----------
        filename : str
            Nom ou chemin du fichier de destination.
            L&#39;extension doit etre comprise dans le nom du fichier.
            Si un fichier du meme nom existe deja, il est ecrase.

        Example
        -------
        &gt;&gt;&gt; import os, tempfile
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt;
        &gt;&gt;&gt; images = [&#34;laue/examples/ge_blanc.mccd&#34;]
        &gt;&gt;&gt; rep = tempfile.mkdtemp()
        &gt;&gt;&gt; expe = laue.Experiment(images, dd=71.5, x0=938.5, y0=1078.1)
        &gt;&gt;&gt; expe.save_file(os.path.join(rep, &#34;fit.det&#34;))
        &#34;&#34;&#34;
        assert isinstance(filename, str), \
            f&#34;&#39;filename&#39; has to be a string, not a {type(filename).__name__}.&#34;
        assert &#34;.&#34; in filename, &#34;Le fichier doit posseder une extension.&#34;
        assert filename.split(&#34;.&#34;)[-1].lower() in {&#34;det&#34;}, \
            f&#34;Seule les extensions &#39;.det&#39; sont supportees. Pas &#39;.{filename.split(&#39;.&#39;)[-1]}&#39;.&#34;

        ext = filename.split(&#34;.&#34;)[-1].lower()
        if ext == &#34;det&#34;:
            with open(filename, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
                file.write(
                   (f&#34;{self.set_calibration()[&#39;dd&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;xcen&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;ycen&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;xbet&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;xgam&#39;]}, &#34;
                    f&#34;{self.set_calibration()[&#39;pixelsize&#39;]}, &#34;
                    f&#34;{self.get_images_shape()[0]}, &#34;
                    f&#34;{self.get_images_shape()[1]}\n&#34;))
                file.write(&#34;Sample-Detector distance(IM), xO, yO, angle1, angle2, pixelsize, dim1, dim2\n&#34;)
                file.write(f&#34;{repr(self)}\n&#34;)
                file.write(f&#34;Calibration done at {time.asctime()}.\n&#34;)

    def _clean(self):
        &#34;&#34;&#34;
        ** Tente de liberer de la memoire. **

        Supprime tous les attributs qui sont suceptibles
        de prendre de la place en memoire.
        &#34;&#34;&#34;
        if self.verbose:
            print(&#34;Suppression des attributs facultatifs...&#34;)
        self._gnomonic_matrix = None
        for diag in self:
            diag._clean()
        if self.verbose:
            print(&#34;\tOK: Le volume de donnees et minimum.&#34;)

    def __getitem__(self, item):
        &#34;&#34;&#34;
        ** Recupere un ou plusieurs diagrame.s. **

        Retroune le ou les diagrames de type ``laue.diagram.LaueDiagram``.

        Parameters
        ----------
        item
            * Ce qui permet de reconaitre un diagrame parmis tous.
                * ``int`` =&gt; Retourne le ieme diagrame, genere par la
                    ieme image lue.
                * ``slice`` =&gt; Permet de manipuler l&#39;experience comme une
                    liste de diagrames ordones dans l&#39;ordre de generation des images.

        Raises
        ------
        KeyError
            Si la clef est correcte mais qu&#39;aucun diagrame ne correspond a cette clef.
        TypeError
            Si la clef n&#39;est pas correcte.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(laue.Experiment(images)[0])
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt; type(laue.Experiment(images)[-1])
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt;
        &gt;&gt;&gt; type(laue.Experiment(images)[:])
        &lt;class &#39;list&#39;&gt;
        &gt;&gt;&gt; len(laue.Experiment(images)[:])
        2
        &gt;&gt;&gt; laue.Experiment(images)[2:]
        []
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def get_diag_list(limit, ignore=False):
            # Cas simple ou il n&#39;y a rien a extraire.
            if limit &gt;= 0 and len(self._buff_diags) &gt; limit: # Si on a deja une liste de la bone taille.
                return self._buff_diags
            if limit &lt; 0 and len(self) and -limit &lt;= len(self):
                return self._buff_diags
            if len(self) and ignore: # Si il faut se contenter de ce qu&#39;on a, meme si c&#39;est pas suffisant.
                return self._buff_diags
            if len(self) and limit &gt;= len(self):
                raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                    f&#34;Or vous tentez d&#39;acceder au {limit+1}eme diagrame!&#34;)
            if len(self) and -limit &gt; len(self):
                raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                    f&#34;Or vous tentez d&#39;acceder au rang {limit}. &#34;
                    f&#34;Le plus petit rang possible c&#39;est {-len(self)}.&#34;)

            # Cas ou il faut extraire.
            if limit &gt;= 0:
                target_limit = max(limit, 2*len(self._buff_diags))
                self._buff_diags = []
                for i, diag in enumerate(self):
                    self._buff_diags.append(diag)
                    if i == limit:
                        break
            else:
                self._buff_diags = self.get_diagrams()

            return get_diag_list(limit=limit, ignore=ignore)

        if isinstance(item, (int, np.integer)):
            return get_diag_list(item)[item]

        if isinstance(item, slice):
            assert item.start is None or isinstance(item.start, (int, np.integer)), \
                f&#34;Slice arguments has to be int, not {type(item.start).__name__}.&#34;
            assert item.stop is None or isinstance(item.stop, (int, np.integer)), \
                f&#34;Slice arguments has to be int, not {type(item.stop).__name__}.&#34;
            assert item.step is None or isinstance(item.step, (int, np.integer)), \
                f&#34;Slice arguments has to be int, not {type(item.step).__name__}.&#34;
            l1 = get_diag_list(item.start, ignore=True) if item.start is not None else []
            l2 = get_diag_list(item.stop, ignore=True) if item.stop is not None else self.get_diagrams()
            return (l1 if len(l1) &gt; len(l2) else l2)[item]

        raise TypeError(f&#34;La clef doit etre de type int ou slice. Pas {type(item).__name__}.&#34;)

    def __iter__(self):
        &#34;&#34;&#34;
        ** Cede les differents diagrammes contenus dans l&#39;experience. **

        * L&#39;ordre est arbitraire la premiere fois mais reste le meme a chaque appel.
        * Strictement equivalent a ``self.get_diagrams(tense_flow=True)`` de
        la methode ``laue.experiment.base_experiment.Experiment.get_diagrams``.

        Yields
        ------
        diagram : laue.diagram.LaueDiagram
            Chaque diagramme contenus dans l&#39;experience.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
        &gt;&gt;&gt; experiment = laue.Experiment(image)
        &gt;&gt;&gt;
        &gt;&gt;&gt; for diag in experiment:
        ...     pass # Allows to process each diagram as it is ready.
        ...
        &gt;&gt;&gt; type(next(iter(experiment)))
        &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        yield from self.get_diagrams(tense_flow=True)

    def __len__(self):
        &#34;&#34;&#34;
        ** Nombre de diagrammes constituants l&#39;experience. **

        Returns
        -------
        int
            Renvoi le nombre de diagrames presents dans cette experience.
            Si tous les diagrames ne sont pas lus, la valeur 0 est renvoyee.
        &#34;&#34;&#34;
        if self._len is None:
            return 0
        return self._len

    def __repr__(self):
        &#34;&#34;&#34;
        ** Renvoi une chaine evaluable de self. **
        &#34;&#34;&#34;
        name = repr(&#34;/&#34;.join(self[0].get_id().split(&#34;/&#34;)[:-1]))
        return f&#34;Experiment({name})&#34;

    def __str__(self):
        &#34;&#34;&#34;
        ** Retourne une jolie representation. **
        &#34;&#34;&#34;
        addi_kwargs = &#39;\t\t\n&#39;.join(f&#39;{k}={v}&#39; for k, v in self.kwargs.items())
        addi_print = f&#34;\n\tadditional kwargs: \n\t\t{addi_kwargs}&#34; if addi_kwargs else &#34;&#34;
        return (&#34;Basic Experiment:\n&#34;
                f&#34;\tnbr reading diagrams: {len(self)}\n&#34;
                f&#34;\tmax_space: {self.max_space} pxl\n&#34;
                f&#34;\tthreshold: {self.threshold} impact/impact\n&#34;
                f&#34;\tfont_size: {self.font_size} pxl\n&#34;
                f&#34;\tignore_errors: {self.ignore_errors}\n&#34;
                f&#34;\tverbose: {self.verbose}&#34;
                f&#34;{addi_print}&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="laue.experiment.ordered_experiment.OrderedExperiment" href="experiment/ordered_experiment.html#laue.experiment.ordered_experiment.OrderedExperiment">OrderedExperiment</a></li>
<li><a title="laue.experiment.theorical_experiment.TheoricalExperiment" href="experiment/theorical_experiment.html#laue.experiment.theorical_experiment.TheoricalExperiment">TheoricalExperiment</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laue.Experiment.__getitem__"><code class="name flex">
<span>def <span class="ident">__getitem__</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere un ou plusieurs diagrame.s. </strong></p>
<p>Retroune le ou les diagrames de type <code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>
<ul>
<li>Ce qui permet de reconaitre un diagrame parmis tous.<ul>
<li><code>int</code> =&gt; Retourne le ieme diagrame, genere par la
ieme image lue.</li>
<li><code>slice</code> =&gt; Permet de manipuler l'experience comme une
liste de diagrames ordones dans l'ordre de generation des images.</li>
</ul>
</li>
</ul>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>Si la clef est correcte mais qu'aucun diagrame ne correspond a cette clef.</dd>
<dt><code>TypeError</code></dt>
<dd>Si la clef n'est pas correcte.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt;
&gt;&gt;&gt; type(laue.Experiment(images)[0])
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt; type(laue.Experiment(images)[-1])
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; type(laue.Experiment(images)[:])
&lt;class 'list'&gt;
&gt;&gt;&gt; len(laue.Experiment(images)[:])
2
&gt;&gt;&gt; laue.Experiment(images)[2:]
[]
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __getitem__(self, item):
    &#34;&#34;&#34;
    ** Recupere un ou plusieurs diagrame.s. **

    Retroune le ou les diagrames de type ``laue.diagram.LaueDiagram``.

    Parameters
    ----------
    item
        * Ce qui permet de reconaitre un diagrame parmis tous.
            * ``int`` =&gt; Retourne le ieme diagrame, genere par la
                ieme image lue.
            * ``slice`` =&gt; Permet de manipuler l&#39;experience comme une
                liste de diagrames ordones dans l&#39;ordre de generation des images.

    Raises
    ------
    KeyError
        Si la clef est correcte mais qu&#39;aucun diagrame ne correspond a cette clef.
    TypeError
        Si la clef n&#39;est pas correcte.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(laue.Experiment(images)[0])
    &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
    &gt;&gt;&gt; type(laue.Experiment(images)[-1])
    &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(laue.Experiment(images)[:])
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; len(laue.Experiment(images)[:])
    2
    &gt;&gt;&gt; laue.Experiment(images)[2:]
    []
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def get_diag_list(limit, ignore=False):
        # Cas simple ou il n&#39;y a rien a extraire.
        if limit &gt;= 0 and len(self._buff_diags) &gt; limit: # Si on a deja une liste de la bone taille.
            return self._buff_diags
        if limit &lt; 0 and len(self) and -limit &lt;= len(self):
            return self._buff_diags
        if len(self) and ignore: # Si il faut se contenter de ce qu&#39;on a, meme si c&#39;est pas suffisant.
            return self._buff_diags
        if len(self) and limit &gt;= len(self):
            raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                f&#34;Or vous tentez d&#39;acceder au {limit+1}eme diagrame!&#34;)
        if len(self) and -limit &gt; len(self):
            raise KeyError(f&#34;L&#39;experience n&#39;est faite que de {len(self)} diagrames, &#34;
                f&#34;Or vous tentez d&#39;acceder au rang {limit}. &#34;
                f&#34;Le plus petit rang possible c&#39;est {-len(self)}.&#34;)

        # Cas ou il faut extraire.
        if limit &gt;= 0:
            target_limit = max(limit, 2*len(self._buff_diags))
            self._buff_diags = []
            for i, diag in enumerate(self):
                self._buff_diags.append(diag)
                if i == limit:
                    break
        else:
            self._buff_diags = self.get_diagrams()

        return get_diag_list(limit=limit, ignore=ignore)

    if isinstance(item, (int, np.integer)):
        return get_diag_list(item)[item]

    if isinstance(item, slice):
        assert item.start is None or isinstance(item.start, (int, np.integer)), \
            f&#34;Slice arguments has to be int, not {type(item.start).__name__}.&#34;
        assert item.stop is None or isinstance(item.stop, (int, np.integer)), \
            f&#34;Slice arguments has to be int, not {type(item.stop).__name__}.&#34;
        assert item.step is None or isinstance(item.step, (int, np.integer)), \
            f&#34;Slice arguments has to be int, not {type(item.step).__name__}.&#34;
        l1 = get_diag_list(item.start, ignore=True) if item.start is not None else []
        l2 = get_diag_list(item.stop, ignore=True) if item.stop is not None else self.get_diagrams()
        return (l1 if len(l1) &gt; len(l2) else l2)[item]

    raise TypeError(f&#34;La clef doit etre de type int ou slice. Pas {type(item).__name__}.&#34;)</code></pre>
</details>
</dd>
<dt id="laue.Experiment.__iter__"><code class="name flex">
<span>def <span class="ident">__iter__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Cede les differents diagrammes contenus dans l'experience. </strong></p>
<ul>
<li>L'ordre est arbitraire la premiere fois mais reste le meme a chaque appel.</li>
<li>Strictement equivalent a <code>self.get_diagrams(tense_flow=True)</code> de
la methode <code><a title="laue.experiment.base_experiment.Experiment.get_diagrams" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.get_diagrams">Experiment.get_diagrams()</a></code>.</li>
</ul>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>diagram</code></strong> :&ensp;<code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code></dt>
<dd>Chaque diagramme contenus dans l'experience.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(image)
&gt;&gt;&gt;
&gt;&gt;&gt; for diag in experiment:
...     pass # Allows to process each diagram as it is ready.
...
&gt;&gt;&gt; type(next(iter(experiment)))
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __iter__(self):
    &#34;&#34;&#34;
    ** Cede les differents diagrammes contenus dans l&#39;experience. **

    * L&#39;ordre est arbitraire la premiere fois mais reste le meme a chaque appel.
    * Strictement equivalent a ``self.get_diagrams(tense_flow=True)`` de
    la methode ``laue.experiment.base_experiment.Experiment.get_diagrams``.

    Yields
    ------
    diagram : laue.diagram.LaueDiagram
        Chaque diagramme contenus dans l&#39;experience.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(image)
    &gt;&gt;&gt;
    &gt;&gt;&gt; for diag in experiment:
    ...     pass # Allows to process each diagram as it is ready.
    ...
    &gt;&gt;&gt; type(next(iter(experiment)))
    &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    yield from self.get_diagrams(tense_flow=True)</code></pre>
</details>
</dd>
<dt id="laue.Experiment.__len__"><code class="name flex">
<span>def <span class="ident">__len__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Nombre de diagrammes constituants l'experience. </strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Renvoi le nombre de diagrames presents dans cette experience.
Si tous les diagrames ne sont pas lus, la valeur 0 est renvoyee.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __len__(self):
    &#34;&#34;&#34;
    ** Nombre de diagrammes constituants l&#39;experience. **

    Returns
    -------
    int
        Renvoi le nombre de diagrames presents dans cette experience.
        Si tous les diagrames ne sont pas lus, la valeur 0 est renvoyee.
    &#34;&#34;&#34;
    if self._len is None:
        return 0
    return self._len</code></pre>
</details>
</dd>
<dt id="laue.Experiment.find_subsets"><code class="name flex">
<span>def <span class="ident">find_subsets</span></span>(<span>self, *, tense_flow=False, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Estime les grains dans chaque diagrame. </strong></p>
<p>Sorte d'alias parallelise vers <code><a title="laue.diagram.LaueDiagram.find_subsets" href="core/subsets.html#laue.core.subsets.Splitable.find_subsets">Splitable.find_subsets()</a></code>.
Le resultat est le meme que: <code>[diag.find_subsets(**kwds) for diag in self]</code></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Il est possible d'appeler plusieur fois cette methode en parallele.</li>
<li>Les sections critiques sont verouillees donc cette methode supporte le multithread.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tense_flow</code></strong> :&ensp;<code>boolean</code></dt>
<dd>
<ul>
<li>True : Permet de travailler a flux tendu, c'est a dire
de ceder les bouts de grains des diagrammes au fur a meusure qu'ils sont trouves.<ul>
<li>Le generateur termine quand toutes les images sont lues ou
que le generateur d'images leve un <code>StopIteration</code>.</li>
<li>A chaque nouvel appel de cette methode, l'iteration
recommence a partir du debut et l'ordre reste inchange.</li>
<li>Equivalent a <code>(diag.find_subsets(**kwds) for diag in self)</code>.</li>
</ul>
</li>
<li>False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.<ul>
<li>C'est equvalent a <code>[diag.find_subsets(**kwds) for diag in self]</code>.</li>
<li>Au lieu de retourner un generateur, retourne une liste.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>**kwds</code></strong></dt>
<dd>Se sont les parametres de la fonction <code><a title="laue.diagram.LaueDiagram.find_subsets" href="core/subsets.html#laue.core.subsets.Splitable.find_subsets">Splitable.find_subsets()</a></code>.
Se sont aussi ceux de la fonction <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Pour chaque diagramme de cette experience, cede une estimation des grains.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&quot;laue/examples/ge_blanc.det&quot;)
&gt;&gt;&gt;
&gt;&gt;&gt; type(experiment.find_subsets())
&lt;class 'list'&gt;
&gt;&gt;&gt; type(experiment.find_subsets(tense_flow=True))
&lt;class 'generator'&gt;
&gt;&gt;&gt; type(next(iter(experiment.find_subsets(tense_flow=True))))
&lt;class 'list'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_subsets(self, *, tense_flow=False, **kwds):
    &#34;&#34;&#34;
    ** Estime les grains dans chaque diagrame. **

    Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_subsets``.
    Le resultat est le meme que: ``[diag.find_subsets(**kwds) for diag in self]``

    Notes
    -----
    * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
    * Les sections critiques sont verouillees donc cette methode supporte le multithread.
    
    Parameters
    ----------
    tense_flow : boolean
        * True : Permet de travailler a flux tendu, c&#39;est a dire
        de ceder les bouts de grains des diagrammes au fur a meusure qu&#39;ils sont trouves.
            * Le generateur termine quand toutes les images sont lues ou
            que le generateur d&#39;images leve un ``StopIteration``.
            * A chaque nouvel appel de cette methode, l&#39;iteration
            recommence a partir du debut et l&#39;ordre reste inchange.
            * Equivalent a ``(diag.find_subsets(**kwds) for diag in self)``.
        * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
            * C&#39;est equvalent a ``[diag.find_subsets(**kwds) for diag in self]``.
            * Au lieu de retourner un generateur, retourne une liste.
    **kwds
        Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_subsets``.
        Se sont aussi ceux de la fonction ``laue.diagram.LaueDiagram.find_zone_axes``.

    Returns
    -------
    list
        Pour chaque diagramme de cette experience, cede une estimation des grains.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(experiment.find_subsets())
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; type(experiment.find_subsets(tense_flow=True))
    &lt;class &#39;generator&#39;&gt;
    &gt;&gt;&gt; type(next(iter(experiment.find_subsets(tense_flow=True))))
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def show_iterator_state(func):
        &#34;&#34;&#34;
        Insere des commentaires.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            if self.verbose:
                print(&#34;Estimation des grains...&#34;)
            
            for i, groups in enumerate(func(*func_args, **func_kwargs)):
                if self.verbose &gt;= 2:
                    print(f&#34;\tgrain du diagramme num {i} estimes: il y a {len(groups)} clusters&#34;)
                yield groups

            if self.verbose:
                print(&#34;\tOK: Tous les clusters de grains sont estimes.&#34;)

        return decorate

    @show_iterator_state
    def _subsets_extractor(self):
        if multiprocessing.current_process().name == &#34;MainProcess&#34;:
            from laue.core.subsets import _pickelable as atomic_find_subsets
            from laue.utilities.multi_core import limited_imap
            with multiprocessing.Pool() as pool:
                yield from (
                    diag.find_subsets(_atomic_subsets_res=args)
                    for diag, args
                    in zip(
                        self,
                        limited_imap(pool,
                            atomic_find_subsets,
                            (   # transformer, gnomonics, dmax, nbr, tol
                                diag.find_subsets(**kwds, _get_args=True)
                                for _, diag in zip(self.find_zone_axes(tense_flow=True, **kwds), self)
                            )
                        )
                    )
                )
        else:
            yield from (diag.find_subsets(**kwds) for diag in self)

    if not tense_flow:
        return list(self.find_subsets(tense_flow=True, **kwds))

    if self._subsets_iterator is None:
        self._subsets_iterator = iter(_subsets_extractor(self))

    from laue.utilities.multi_core import RecallingIterator
    return (lambda x: (yield from x))(RecallingIterator(self._subsets_iterator, mother=self))</code></pre>
</details>
</dd>
<dt id="laue.Experiment.find_zone_axes"><code class="name flex">
<span>def <span class="ident">find_zone_axes</span></span>(<span>self, *, tense_flow=False, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recherche l'ensemble des axes de zones. </strong></p>
<p>Sorte d'alias parallelise vers <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code>.
Le resultat est le meme que: <code>[diag.find_zone_axes(**kwds) for diag in self]</code></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Il est possible d'appeler plusieur fois cette methode en parallele.</li>
<li>Les sections critiques sont verouillees donc cette methode supporte le multithread.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tense_flow</code></strong> :&ensp;<code>boolean</code></dt>
<dd>
<ul>
<li>True : Permet de travailler a flux tendu, c'est a dire
de ceder les axes des diagrammes au fur a meusure qu'ils sont trouves.<ul>
<li>Le generateur termine quand toutes les images sont lues ou
que le generateur d'images leve un <code>StopIteration</code>.</li>
<li>A chaque nouvel appel de cette methode, l'iteration
recommence a partir du debut et l'ordre reste inchange.</li>
<li>Equivalent a <code>(diag.find_zone_axes(**kwds) for diag in self)</code>.</li>
</ul>
</li>
<li>False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.<ul>
<li>C'est equvalent a <code>[diag.find_zone_axes(**kwds) for diag in self]</code>.</li>
<li>Au lieu de retourner un generateur, retourne une liste.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>**kwds</code></strong></dt>
<dd>Se sont les parametres de la fonction <code><a title="laue.diagram.LaueDiagram.find_zone_axes" href="diagram.html#laue.diagram.LaueDiagram.find_zone_axes">LaueDiagram.find_zone_axes()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Pour chaque diagramme de cette experience, cede la liste
des axes de zones du diagramme. Les elements de l'ensemble
sont de type <code><a title="laue.zone_axis.ZoneAxis" href="zone_axis.html#laue.zone_axis.ZoneAxis">ZoneAxis</a></code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&quot;laue/examples/ge_blanc.det&quot;)
&gt;&gt;&gt;
&gt;&gt;&gt; type(experiment.find_zone_axes())
&lt;class 'list'&gt;
&gt;&gt;&gt; type(experiment.find_zone_axes(tense_flow=True))
&lt;class 'generator'&gt;
&gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))))
&lt;class 'list'&gt;
&gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))).pop())
&lt;class 'laue.zone_axis.ZoneAxis'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_zone_axes(self, *, tense_flow=False, **kwds):
    &#34;&#34;&#34;
    ** Recherche l&#39;ensemble des axes de zones. **

    Sorte d&#39;alias parallelise vers ``laue.diagram.LaueDiagram.find_zone_axes``.
    Le resultat est le meme que: ``[diag.find_zone_axes(**kwds) for diag in self]``

    Notes
    -----
    * Il est possible d&#39;appeler plusieur fois cette methode en parallele.
    * Les sections critiques sont verouillees donc cette methode supporte le multithread.

    Parameters
    ----------
    tense_flow : boolean
        * True : Permet de travailler a flux tendu, c&#39;est a dire
        de ceder les axes des diagrammes au fur a meusure qu&#39;ils sont trouves.
            * Le generateur termine quand toutes les images sont lues ou
            que le generateur d&#39;images leve un ``StopIteration``.
            * A chaque nouvel appel de cette methode, l&#39;iteration
            recommence a partir du debut et l&#39;ordre reste inchange.
            * Equivalent a ``(diag.find_zone_axes(**kwds) for diag in self)``.
        * False. Sinon, attend que tous les diagrammes soient lues afin de tout renvoyer en meme temps.
            * C&#39;est equvalent a ``[diag.find_zone_axes(**kwds) for diag in self]``.
            * Au lieu de retourner un generateur, retourne une liste.
    **kwds
        Se sont les parametres de la fonction ``laue.diagram.LaueDiagram.find_zone_axes``.

    Returns
    -------
    list
        Pour chaque diagramme de cette experience, cede la liste
        des axes de zones du diagramme. Les elements de l&#39;ensemble
        sont de type ``laue.zone_axis.ZoneAxis``.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(images, config_file=&#34;laue/examples/ge_blanc.det&#34;)
    &gt;&gt;&gt;
    &gt;&gt;&gt; type(experiment.find_zone_axes())
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; type(experiment.find_zone_axes(tense_flow=True))
    &lt;class &#39;generator&#39;&gt;
    &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))))
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; type(next(iter(experiment.find_zone_axes(tense_flow=True))).pop())
    &lt;class &#39;laue.zone_axis.ZoneAxis&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def show_iterator_state(func):
        &#34;&#34;&#34;
        Insere des commentaires.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            if self.verbose:
                print(&#34;Extraction des axes de zone...&#34;)
            
            for i, axes in enumerate(func(*func_args, **func_kwargs)):
                if self.verbose &gt;= 2:
                    print(f&#34;\taxes du diagramme num {i} trouves: il y en a {len(axes)}&#34;)
                yield axes

            if self.verbose:
                print(&#34;\tOK: Tous les axes de zone sont extraits.&#34;)

        return decorate

    @show_iterator_state
    def _axes_extractor(self):
        &#34;&#34;&#34;
        Premiere vraie extraction.
        &#34;&#34;&#34;
        if multiprocessing.current_process().name == &#34;MainProcess&#34;:
            # Compilation et serialisation des equations.
            self.transformer.compile(self.set_calibration(), transform=&#34;cam_to_gnomonic&#34;)
            transformer_ser = cloudpickle.dumps(self.transformer)

            # Parallelisation des fils.
            from laue.core.zone_axes import _get_zone_axes_pickle
            from laue.utilities.multi_core import limited_imap
            with multiprocessing.Pool() as pool:
                yield from (
                    diag.find_zone_axes(_axes_args=args)
                    for diag, args
                    in zip(
                        self,
                        limited_imap(pool,
                            _get_zone_axes_pickle,
                            ( # transformer, gnomonics, dmax, nbr, tol
                                (transformer_ser, *diag.find_zone_axes(**kwds, _get_args=True))
                                for diag in self
                            )
                        )
                    )
                )

        else:
            yield from (diag.find_zone_axes(**kwds) for diag in self)

    if not tense_flow:
        return list(self.find_zone_axes(tense_flow=True, **kwds))

    if self._axes_iterator is None:
        self._axes_iterator = iter(_axes_extractor(self))

    from laue.utilities.multi_core import RecallingIterator
    return (lambda x: (yield from x))(RecallingIterator(self._axes_iterator, mother=self))</code></pre>
</details>
</dd>
<dt id="laue.Experiment.get_diagrams"><code class="name flex">
<span>def <span class="ident">get_diagrams</span></span>(<span>self, *, tense_flow=False)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Genere les diagrammes de l'experience. </strong></p>
<p>C'est la qu'est effectue le pic search.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>Performances:<ul>
<li>Sur un PC (intel core i7, ssd, 8 coeurs), met environ 37 ms/diagramme.</li>
<li>Sur un PC (intel centrino, hdd, 2 coeurs), met environ 530 ms/diagramme.</li>
</ul>
</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tense_flow</code></strong> :&ensp;<code>boolean</code></dt>
<dd>
<ul>
<li>True : Permet de travailler a flux tendu, c'est a dire
de cede les diagrammes au fur a meusure qu'ils sont crees.<ul>
<li>Le generateur termine quand toutes les images sont lues ou
que le generateur d'images leve un <code>StopIteration</code>.</li>
<li>A chaque nouvel appel de cette methode, l'iteration
recommence a partir du debut et l'ordre reste inchange.</li>
<li>Equivalent a <code><a title="laue.experiment.base_experiment.Experiment.__iter__" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.__iter__">Experiment.__iter__()</a></code>.</li>
</ul>
</li>
<li>False. Sinon, attend que tous les diagrammes
soient lues afin de tout renvoyer en meme temps.</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>La liste des diagrammes de type <code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code>.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code></dt>
<dd>
<ul>
<li>Chaque diagram extrait au fur a mesure qu'il arrive.</li>
<li>L'ordre est concerve pour chaque appel de cette methode a flux tendu.</li>
<li>A chaque appel on repars du debut, meme si un autre appel n'est pas termine.</li>
<li>Les sections critiques sont verouillees donc cette methode supporte le multithread.</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(images)
&gt;&gt;&gt;
&gt;&gt;&gt; diagrams = experiment.get_diagrams()
&gt;&gt;&gt; type(diagrams)
&lt;class 'list'&gt;
&gt;&gt;&gt; type(diagrams.pop())
&lt;class 'laue.diagram.LaueDiagram'&gt;
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_diagrams(self, *, tense_flow=False):
    &#34;&#34;&#34;
    ** Genere les diagrammes de l&#39;experience. **

    C&#39;est la qu&#39;est effectue le pic search.

    Notes
    -----
    * Performances:
        * Sur un PC (intel core i7, ssd, 8 coeurs), met environ 37 ms/diagramme.
        * Sur un PC (intel centrino, hdd, 2 coeurs), met environ 530 ms/diagramme.

    Parameters
    ----------
    tense_flow : boolean
        * True : Permet de travailler a flux tendu, c&#39;est a dire
        de cede les diagrammes au fur a meusure qu&#39;ils sont crees.
            * Le generateur termine quand toutes les images sont lues ou
            que le generateur d&#39;images leve un ``StopIteration``.
            * A chaque nouvel appel de cette methode, l&#39;iteration
            recommence a partir du debut et l&#39;ordre reste inchange.
            * Equivalent a ``laue.experiment.base_experiment.Experiment.__iter__``.
        * False. Sinon, attend que tous les diagrammes
        soient lues afin de tout renvoyer en meme temps.

    Returns
    -------
    list
        La liste des diagrammes de type ``laue.diagram.LaueDiagram``.

    Yields
    ------
    laue.diagram.LaueDiagram
        * Chaque diagram extrait au fur a mesure qu&#39;il arrive.
        * L&#39;ordre est concerve pour chaque appel de cette methode a flux tendu.
        * A chaque appel on repars du debut, meme si un autre appel n&#39;est pas termine.
        * Les sections critiques sont verouillees donc cette methode supporte le multithread.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(images)
    &gt;&gt;&gt;
    &gt;&gt;&gt; diagrams = experiment.get_diagrams()
    &gt;&gt;&gt; type(diagrams)
    &lt;class &#39;list&#39;&gt;
    &gt;&gt;&gt; type(diagrams.pop())
    &lt;class &#39;laue.diagram.LaueDiagram&#39;&gt;
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def cast_to_diagram(spots_args, name, image=None):
        &#34;&#34;&#34;
        Met en forme du pic search pour en faire des diagrames.
        &#34;&#34;&#34;
        laue_diagram = LaueDiagram(name, experiment=self)
        spots = [Spot(diagram=laue_diagram, identifier=i, **spot_args)
                 for i, spot_args in enumerate(spots_args)]
        laue_diagram._set_spots(spots)
        if image is not None and (
                (not os.path.exists(name)) or (psutil is not None and psutil.virtual_memory().percent &lt; 50)
                ):
            laue_diagram._set_image(image)
        return laue_diagram

    def update_len(func):
        &#34;&#34;&#34;
        Tient a jour la longueur de l&#39;experience.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            for i, element in enumerate(func(*func_args, **func_kwargs)):
                yield element
            self._len = i + 1

        return decorate

    def show_iterator_state(func):
        &#34;&#34;&#34;
        Insere des commentaires.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            if self.verbose:
                print(&#34;Extraction des diagrammes...&#34;)

            for i, diag in enumerate(func(*func_args, **func_kwargs)):
                if self.verbose &gt;= 2:
                    print(f&#34;\tdiagramme num {i} extrait: &#34;
                          f&#34;(...{diag.get_id()[-20:]}) &#34;
                          f&#34;avec {len(diag)} spots&#34;)
                yield diag
            if self.verbose:
                print(&#34;\tOK: Tous les diagrammes sont extraits.&#34;)
        
        return decorate

    @update_len
    @show_iterator_state
    def _diagram_extractor(self):
        &#34;&#34;&#34;
        Premiere vraie lecture. Cede les diagrammes.
        &#34;&#34;&#34;
        if multiprocessing.current_process().name == &#34;MainProcess&#34;:
            from laue.core.pic_search import _pickelable_pic_search
            from laue.utilities.multi_core import limited_imap
            with multiprocessing.Pool() as pool:
                yield from (
                    cast_to_diagram(spots_args, name, image)
                    for spots_args, (name, image) in limited_imap(pool,
                        _pickelable_pic_search,
                        (
                            (
                                (
                                    image,
                                    self.kernel_font,
                                    self.kernel_dilate,
                                    self.threshold
                                ),
                                (name, image)
                            )
                            for name, image in self.read_images()
                        )
                    )
                )
        else:
            from laue import atomic_pic_search
            yield from (
                cast_to_diagram(
                    atomic_pic_search(
                        image,
                        self.kernel_font,
                        self.kernel_dilate,
                        self.threshold
                    ),
                    name,
                    image
                )
                for name, image in self.read_images()
            )
    
    if self._diagrams_iterator is None:
        self._diagrams_iterator = iter(_diagram_extractor(self))

    from laue.utilities.multi_core import RecallingIterator
    return (
        (lambda x: (yield from x))(RecallingIterator(self._diagrams_iterator, mother=self))
        if tense_flow else list(RecallingIterator(self._diagrams_iterator, mother=self)))</code></pre>
</details>
</dd>
<dt id="laue.Experiment.get_images_shape"><code class="name flex">
<span>def <span class="ident">get_images_shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere les dimensions des images. </strong></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(nbr de lignes, nbr de colones), de type (int, int).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_images_shape(self):
    &#34;&#34;&#34;
    ** Recupere les dimensions des images. **

    Returns
    -------
    tuple
        (nbr de lignes, nbr de colones), de type (int, int).
    &#34;&#34;&#34;
    if self._shape is not None:
        return self._shape

    try:
        _, image = next(iter(self.read_images()))
    except StopIteration as err:
        raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
    self._shape = image.shape
    return self._shape</code></pre>
</details>
</dd>
<dt id="laue.Experiment.get_mean"><code class="name flex">
<span>def <span class="ident">get_mean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Estime la moyenne des images. </strong></p>
<p>Cela permet d'avoir une estimation du fond diffus.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>A cause des arrondis machine, seule les 9e15 permieres images sont considerees.</li>
<li>Ne retourne pas tant que toutes les images d'entree ne sont pas lues.</li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>L'image de la moyenne des images en matrice 2d uint16.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mean(self):
    &#34;&#34;&#34;
    ** Estime la moyenne des images. **

    Cela permet d&#39;avoir une estimation du fond diffus.

    Notes
    -----
    * A cause des arrondis machine, seule les 9e15 permieres images sont considerees.
    * Ne retourne pas tant que toutes les images d&#39;entree ne sont pas lues.

    Returns
    -------
    np.ndarray
        L&#39;image de la moyenne des images en matrice 2d uint16.
    &#34;&#34;&#34;
    if self._mean_bg is not None:
        return self._mean_bg

    if self.verbose:
        print(&#34;Estimation du fond par la moyenne...&#34;)

    im_gen = iter((image.astype(np.float64) for _, image in self.read_images()))
    try:
        mean_array = next(im_gen)
    except StopIteration as err:
        raise ValueError(&#34;L&#39;experience ne contient aucune image.&#34;) from err
    for i, image in enumerate(im_gen):
        mean_array = i/(i+1) * mean_array + 1/(i+1) * image

    self._mean_bg = mean_array.astype(np.uint16)

    if self.verbose:
        print(&#34;\tOK: La moyenne des images est estimee.&#34;)
    return self._mean_bg</code></pre>
</details>
</dd>
<dt id="laue.Experiment.read_images"><code class="name flex">
<span>def <span class="ident">read_images</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Cede le contenu des images. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Reitere depuis le debut a chaque appel.</li>
<li>Il peut y avoir plusieurs appels en parallele
sans que cela ne genere de conflits. Dumoins tans que des threads
ne sont pas utilises, car il n'y a pas de mecanisme de verrou.</li>
<li>A chaque appel de cette methode, l'ordre est conserve.</li>
<li>Les sections critiques sont verouillees donc cette methode supporte le multithread.</li>
</ul>
<h2 id="yields">Yields</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Le nom de l'image (path si possible)</dd>
<dt><strong><code>image</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Le contenu de l'image</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Si l'image n'est pas bien typee.</dd>
<dt><code>FileNotFoundError</code></dt>
<dd>Si le chemin de l'image n'est pas correcte.</dd>
<dt><code>ValueError</code></dt>
<dd>Si les images ne sont pas de la meme taille.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = &quot;laue/examples/*.mccd&quot;
&gt;&gt;&gt; for image in laue.Experiment(images):
...     pass
...
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_images(self):
    &#34;&#34;&#34;
    ** Cede le contenu des images. **

    Notes
    -----
    * Reitere depuis le debut a chaque appel.
    * Il peut y avoir plusieurs appels en parallele
    sans que cela ne genere de conflits. Dumoins tans que des threads
    ne sont pas utilises, car il n&#39;y a pas de mecanisme de verrou.
    * A chaque appel de cette methode, l&#39;ordre est conserve.
    * Les sections critiques sont verouillees donc cette methode supporte le multithread.

    Yields
    ------
    name : str
        Le nom de l&#39;image (path si possible)
    image : np.ndarray
        Le contenu de l&#39;image

    Raises
    ------
    TypeError
        Si l&#39;image n&#39;est pas bien typee.
    FileNotFoundError
        Si le chemin de l&#39;image n&#39;est pas correcte.
    ValueError
        Si les images ne sont pas de la meme taille.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = &#34;laue/examples/*.mccd&#34;
    &gt;&gt;&gt; for image in laue.Experiment(images):
    ...     pass
    ...
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    from laue.utilities.multi_core import RecallingIterator, prevent_generator_size

    def read_and_check_any_image(image_info, image_num):
        &#34;&#34;&#34;
        Soit retroune directement, soit lit le fichier.
        Retourne le nom de l&#39;image et l&#39;image elle-meme.
        Renvoi None, None si il faut ignorer cette image.
        &#34;&#34;&#34;            
        # Mise en forme.
        if isinstance(image_info, str):
            image_name = image_info
            from laue.utilities.image import read_image
            image = read_image(image_info, ignore_errors=self.ignore_errors)
            if image is None:
                return None, None
        elif isinstance(image_info, np.ndarray):
            image_name = f&#34;image_{image_num}&#34;
            image = image_info
        else:
            raise TypeError(&#34;L&#39;image doit etre de type str ou np.array, &#34;
                f&#34;pas {type(image_info).__name__}.&#34;)

        # Verifications
        if not isinstance(image, np.ndarray):
            raise TypeError(f&#34;L&#39;image doit etre un array numpy, pas un {type(image).__name__}.&#34;)
        if image.ndim != 2:
            raise TypeError(f&#34;L&#39;image {image_name} doit etre en niveau de gris pas de dimension {image.ndim}.&#34;)
        if image.dtype != np.uint16:
            raise TypeError(f&#34;L&#39;image {image_name} doit etre encodee en uint16, pas {image.dtype}.&#34;)
        if self._shape is None:
            self._shape = image.shape
        if self._shape != image.shape:
            raise ValueError(f&#34;L&#39;image {image_name} a pour taille {image.shape} tandis que les images &#34;
                f&#34;precedentes ont pour taille {self._shape}. Les images ne sont pas issues de la meme experience.&#34;)

        return image_name, image

    def show_iterator_state(func):
        &#34;&#34;&#34;
        Insere des commentaires.
        &#34;&#34;&#34;
        def decorate(*func_args, **func_kwargs):
            if self.verbose:
                print(&#34;Lecture des images...&#34;)
            
            for image_info in func(*func_args, **func_kwargs):
                yield image_info
                if self.verbose &gt;= 2:
                    print(f&#34;\timage : (...{str(image_info)[-20:]}) cedee.&#34;)

            if self.verbose:
                print(&#34;\tOK: Toutes les images sont lues.&#34;)

        return decorate

    @show_iterator_state
    def _images_extractor():
        &#34;&#34;&#34;
        Premiere vraie extraction.
        &#34;&#34;&#34;
        # Convertion str vers generateur
        if isinstance(self._images, str): # Dans le cas ou une chaine de caractere
            if os.path.isdir(self._images): # decrit l&#39;ensemble des images.
                self._images = sorted(
                    os.path.join(father, file)
                    for father, _, files in os.walk(self._images)
                    for file in files)
            else:
                self._images = sorted(glob.iglob(self._images, recursive=True))

        yield from self._images

    @prevent_generator_size(min_size=1)
    def jump_map(multi_image_iterator):
        image_num = 0
        for image_info in multi_image_iterator:
            image_name, image = read_and_check_any_image(image_info, image_num)
            if image is None:
                continue
            image_num += 1
            yield image_name, image

    if self._images_iterator is None:
        self._images_iterator = iter(_images_extractor())

    return jump_map(RecallingIterator(self._images_iterator, mother=self))</code></pre>
</details>
</dd>
<dt id="laue.Experiment.save_file"><code class="name flex">
<span>def <span class="ident">save_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Enregistre un fichier contenant des informations. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Les extensions prises en charge sont <code>.det</code>.</li>
<li>Pour les fichiers propres a chaque diagrammes, voir <code><a title="laue.diagram.LaueDiagram.save_file" href="diagram.html#laue.diagram.LaueDiagram.save_file">LaueDiagram.save_file()</a></code>.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Nom ou chemin du fichier de destination.
L'extension doit etre comprise dans le nom du fichier.
Si un fichier du meme nom existe deja, il est ecrase.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import os, tempfile
&gt;&gt;&gt; import laue
&gt;&gt;&gt;
&gt;&gt;&gt; images = [&quot;laue/examples/ge_blanc.mccd&quot;]
&gt;&gt;&gt; rep = tempfile.mkdtemp()
&gt;&gt;&gt; expe = laue.Experiment(images, dd=71.5, x0=938.5, y0=1078.1)
&gt;&gt;&gt; expe.save_file(os.path.join(rep, &quot;fit.det&quot;))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_file(self, filename):
    &#34;&#34;&#34;
    ** Enregistre un fichier contenant des informations. **

    Notes
    -----
    * Les extensions prises en charge sont ``.det``.
    * Pour les fichiers propres a chaque diagrammes, voir ``laue.diagram.LaueDiagram.save_file``.

    Parameters
    ----------
    filename : str
        Nom ou chemin du fichier de destination.
        L&#39;extension doit etre comprise dans le nom du fichier.
        Si un fichier du meme nom existe deja, il est ecrase.

    Example
    -------
    &gt;&gt;&gt; import os, tempfile
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt;
    &gt;&gt;&gt; images = [&#34;laue/examples/ge_blanc.mccd&#34;]
    &gt;&gt;&gt; rep = tempfile.mkdtemp()
    &gt;&gt;&gt; expe = laue.Experiment(images, dd=71.5, x0=938.5, y0=1078.1)
    &gt;&gt;&gt; expe.save_file(os.path.join(rep, &#34;fit.det&#34;))
    &#34;&#34;&#34;
    assert isinstance(filename, str), \
        f&#34;&#39;filename&#39; has to be a string, not a {type(filename).__name__}.&#34;
    assert &#34;.&#34; in filename, &#34;Le fichier doit posseder une extension.&#34;
    assert filename.split(&#34;.&#34;)[-1].lower() in {&#34;det&#34;}, \
        f&#34;Seule les extensions &#39;.det&#39; sont supportees. Pas &#39;.{filename.split(&#39;.&#39;)[-1]}&#39;.&#34;

    ext = filename.split(&#34;.&#34;)[-1].lower()
    if ext == &#34;det&#34;:
        with open(filename, &#34;w&#34;, encoding=&#34;utf-8&#34;) as file:
            file.write(
               (f&#34;{self.set_calibration()[&#39;dd&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;xcen&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;ycen&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;xbet&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;xgam&#39;]}, &#34;
                f&#34;{self.set_calibration()[&#39;pixelsize&#39;]}, &#34;
                f&#34;{self.get_images_shape()[0]}, &#34;
                f&#34;{self.get_images_shape()[1]}\n&#34;))
            file.write(&#34;Sample-Detector distance(IM), xO, yO, angle1, angle2, pixelsize, dim1, dim2\n&#34;)
            file.write(f&#34;{repr(self)}\n&#34;)
            file.write(f&#34;Calibration done at {time.asctime()}.\n&#34;)</code></pre>
</details>
</dd>
<dt id="laue.Experiment.set_calibration"><code class="name flex">
<span>def <span class="ident">set_calibration</span></span>(<span>self, *diagrams)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Calibration de la camera. </strong></p>
<h2 id="notes">Notes</h2>
<ul>
<li>Ne nessecite aucune connaissances prealable sur le christal.</li>
<li>Il n'y a pas besoin d'avoir un diagramme bien calibre, il se debrouille tout seul.</li>
<li>Cette fonction peut parfois etre lente (plusieur minutes)!</li>
<li>Si vous connaissez les parametres, fournissez-les, ca ira plus vite!</li>
<li>Si cette methode a deja ete appelee une fois, elle retourne
immeditement le resultat sans refaire les calculs.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*diagrams</code></strong> :&ensp;<code>optional</code></dt>
<dd>Les ou le diagramme.s qui vont servir a faire la calibration.
Si aucun diagramme n'est precise, cette methode recherche par elle meme
les diagrammes qu'elle trouve convaincant parmis ceux qui sont disponibles.
Il doivent etre de type <code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict </code></dt>
<dd>Le dictionaire qui a chaque non de parametre, associe sa valeur numerique.
Les clefs sont les suivantes: "dd", "xcen", "ycen", "xbet", "xgam" and "pixelsize"</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>Si l'utilisateur n'a pas precise les parametres vraiment indispenssables.</dd>
<dt><code>ValueError</code></dt>
<dd>Si il y a des incoherences dans les parametres.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; image = &quot;laue/examples/ge_blanc.mccd&quot;
&gt;&gt;&gt; experiment = laue.Experiment(image, dd_min=69.5, dd_max=71.5, xbet=0.008)
&gt;&gt;&gt; parameters = experiment.set_calibration()
&gt;&gt;&gt; sorted(parameters.keys())
['dd', 'pixelsize', 'xbet', 'xcen', 'xgam', 'ycen']
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_calibration(self, *diagrams):
    &#34;&#34;&#34;
    ** Calibration de la camera. **

    Notes
    -----
    * Ne nessecite aucune connaissances prealable sur le christal.
    * Il n&#39;y a pas besoin d&#39;avoir un diagramme bien calibre, il se debrouille tout seul.
    * Cette fonction peut parfois etre lente (plusieur minutes)!
    * Si vous connaissez les parametres, fournissez-les, ca ira plus vite!
    * Si cette methode a deja ete appelee une fois, elle retourne
        immeditement le resultat sans refaire les calculs.

    Parameters
    ----------
    *diagrams : optional
        Les ou le diagramme.s qui vont servir a faire la calibration.
        Si aucun diagramme n&#39;est precise, cette methode recherche par elle meme
        les diagrammes qu&#39;elle trouve convaincant parmis ceux qui sont disponibles.
        Il doivent etre de type ``laue.diagram.LaueDiagram``.

    Returns
    -------
    dict 
        Le dictionaire qui a chaque non de parametre, associe sa valeur numerique.
        Les clefs sont les suivantes: &#34;dd&#34;, &#34;xcen&#34;, &#34;ycen&#34;, &#34;xbet&#34;, &#34;xgam&#34; and &#34;pixelsize&#34;

    Raises
    ------
    KeyError
        Si l&#39;utilisateur n&#39;a pas precise les parametres vraiment indispenssables.
    ValueError
        Si il y a des incoherences dans les parametres.

    Example
    -------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; image = &#34;laue/examples/ge_blanc.mccd&#34;
    &gt;&gt;&gt; experiment = laue.Experiment(image, dd_min=69.5, dd_max=71.5, xbet=0.008)
    &gt;&gt;&gt; parameters = experiment.set_calibration()
    &gt;&gt;&gt; sorted(parameters.keys())
    [&#39;dd&#39;, &#39;pixelsize&#39;, &#39;xbet&#39;, &#39;xcen&#39;, &#39;xgam&#39;, &#39;ycen&#39;]
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if self._calibration_parameters is not None: # Si on peut retourner directement,
        return self._calibration_parameters # on ne s&#39;en prive pas.

    assert all(isinstance(diag, LaueDiagram) for diag in diagrams), \
        &#34;Tous les diagrammes doivent etre de type &#39;LaueDiagram&#39;. Or ce n&#39;est pas le cas.&#34;

    if self.verbose:
        print(&#34;Calibration...&#34;)
        if self.verbose &gt;= 2:
            print(&#34;\tPrise en compte des parametres fournis...&#34;)

    # Constantes.
    PIXELSIZE_REF = {(2048, 2048): 0.079856, # Taille des pixels fonction de la camera.
                     (2018, 2016): 0.0734,
                     (2594, 2748): 0.031}
    PARAM_SET = {&#34;dd&#34;, &#34;xbet&#34;, &#34;xgam&#34;, &#34;xcen&#34;, &#34;ycen&#34;} # Les parametres non deductibles.
    PARAM_MIN = {&#34;dd&#34;: 60.0, # Les bornes minimale par defaut.
                 &#34;xbet&#34;: -.9,
                 &#34;xgam&#34;: -.9,
                 &#34;xcen&#34;: self.get_images_shape()[0]/2 - 150,
                 &#34;ycen&#34;: self.get_images_shape()[0]/2 - 150}
    PARAM_MAX = {&#34;dd&#34;: 80.0, # Les bornes maximales par defaut.
                 &#34;xbet&#34;: .9,
                 &#34;xgam&#34;: .9,
                 &#34;xcen&#34;: self.get_images_shape()[0]/2 + 150,
                 &#34;ycen&#34;: self.get_images_shape()[1]/2 + 150}

    # Recuperation des parametres fournis et deductibles.
    from laue.utilities.parsing import extract_parameters
    given_parameters = extract_parameters(ignore_missing=True, **self.kwargs)
    if (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() in PIXELSIZE_REF):
        given_parameters[&#34;pixelsize&#34;] = PIXELSIZE_REF[self.get_images_shape()]
    
    elif (&#34;pixelsize&#34; not in given_parameters) and (self.get_images_shape() not in PIXELSIZE_REF):
        raise KeyError(&#34;Vous devez fournir le parametre &#39;pixelsize&#39;.\n&#34;
            f&#34;Les images font {self.get_images_shape()} pxl**2. &#34;
            f&#34;Or, seul les &#39;pixelsize&#39; des images {&#39; et &#39;.join(map(str, PIXELSIZE_REF))} sont connus.&#34;)

    # Recuperation des bornes.
    given_min = extract_parameters(ignore_missing=True, **{
        param[:-4]: value
        for param, value in self.kwargs.items()
        if param.endswith(&#34;_min&#34;) and len(param) &gt; 4})
    given_max = extract_parameters(ignore_missing=True, **{
        param[:-4]: value
        for param, value in self.kwargs.items()
        if param.endswith(&#34;_max&#34;) and len(param) &gt; 4})
    parameters_min = {param: given_min.get(param, PARAM_MIN[param]) for param in PARAM_SET}
    parameters_max = {param: given_max.get(param, PARAM_MAX[param]) for param in PARAM_SET}
    
    for param in PARAM_SET: # Verification de la coherence des bornes.
        if parameters_min[param] &gt;= parameters_max[param]:
            raise ValueError(f&#34;Les bornes du parametre {repr(param)} sont inversees, &#34;
                f&#34;{param}_min={parameters_min[param]} et {param}_max={parameters_max[param]}.&#34;)

    # Valeur de departs des parametres.
    initial_parameters = { # Ce sont les parametres initiaux pour la descente de gradient.
        par: given_parameters.get(par,
            .5*(parameters_min[par] + parameters_max[par]))
        for par in PARAM_SET}
   
    for par, val in initial_parameters.items(): # Verification.
        if par in given_parameters and par in given_min:
            if given_parameters[par] &lt; given_min[par]:
                raise ValueError(f&#34;Vous avez imposes {par}_min={given_min[par]} &#34;
                    f&#34;et en meme temp vous avez donnes {par}={val}!&#34;)
        if par in given_parameters and par in given_max:
            if given_parameters[par] &gt; given_max[par]:
                raise ValueError(f&#34;Vous avez imposes {par}_max={given_max[par]} &#34;
                    f&#34;et en meme temps vous avez donnes {par}={val}!&#34;)

    # Parametres restants.
    unknown_parameters = PARAM_SET - set(given_parameters)
    if not unknown_parameters: # Si Il n&#39;y a rien a calculer.
        self._calibration_parameters = given_parameters
        if self.verbose:
            if self.verbose &gt;= 2:
                print(&#34;\t\tOK: Tout est fournis, il n&#39;y a rien a faire.&#34;)
            print(f&#34;\tOK: Calibration terminee: {given_parameters}&#34;)
        return self._calibration_parameters

    # Extraction d&#39;un diagramme interressant.
    if self.verbose &gt;= 2:
        print(&#34;\tRecuperation des diagrammes interressants...&#34;)
    if not diagrams: # Si l&#39;utilisateur ne nous aide pas a trouver les bons diagrammes.
        diagrams = []
        for i, dia in enumerate(self):
            if i &gt; 60: # On ne s&#39;interesse qu&#39;a la premiere minute.
                break
            diagrams.append(dia)
        best_diagrams = [sorted(diagrams, key=lambda dia: dia.get_quality(), reverse=True).pop()]
    else: # Si l&#39;utilisateur nous en fournit.
        best_diagrams = diagrams # C&#39;est un tuple et non pas une liste mais c&#39;est pas genant.
    if self.verbose &gt;= 2:
        for dia in best_diagrams:
            print(f&#34;\t\t{dia.get_id()}&#34;)

    # Vectorisation des donnees pour de bonnes perfs.
    min_size = min(
        200,
        min(len(dia) for dia in best_diagrams)
        ) # Le plus petit nombre de points.
    spots_position = np.array(
        [dia.get_positions(n=min_size, sort=&#34;quality&#34;)
         for dia in best_diagrams],
        dtype=np.float32)
    spots_position = np.swapaxes(spots_position, 0, 1) # shape: (2, n_diagrams, nbr_spots)

    # Perparations des parametres pour la suite.
    vect_labels = tuple(unknown_parameters) # On recupere les nom des parametres inconus seulement.
    bounds = [(parameters_min[name], parameters_max[name]) for name in vect_labels] # Les limites des variables.
    args = (given_parameters, vect_labels, spots_position) # Les arguments en plus de la fonction de cout.
    if self.verbose &gt;= 2:
        print(f&#34;\tcalibration des parametres {vect_labels}&#34;)
        print(f&#34;\tbornes min: {tuple(b_min for b_min, _ in bounds)}&#34;)
        print(f&#34;\tbornes max: {tuple(b_max for _, b_max in bounds)}&#34;)
    
    # Recherche rapide d&#39;un minimum par descente de gradient.
    from scipy import optimize # On ne l&#39;importe que ici car on est pas sur de s&#39;en servir.
    if self.verbose &gt;= 2:
        print(&#34;\tOptimsation globale, algo genetique...&#34;)
    
    if multiprocessing.current_process().name == &#34;MainProcess&#34; and os.cpu_count() &gt; 4:
        attrs = [&#34;transformer&#34;, &#34;verbose&#34;]
        self_bis = collections.namedtuple(&#34;PartialExperiment&#34;, attrs, defaults=[getattr(self, attr) for attr in attrs])()
        opt_res = optimize.differential_evolution(
            _Picklable(cloudpickle.dumps(self_bis), Experiment._calibration_cost,
                {name: val for name, val in zip((&#34;known_params&#34;, &#34;vect_labels&#34;, &#34;spots_position&#34;), args)}
                ),
            updating=&#34;deferred&#34;,
            bounds=bounds,
            disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
            polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
            popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
            workers=-1) # Pour utiliser tous les cpus.
    else:
        opt_res = optimize.differential_evolution(
            self._calibration_cost,
            bounds=bounds,
            args=args,
            disp=self.verbose &gt;= 3, # Pour rendre la fonction verbeuse.
            polish=False, # Pour ne pas utiliser scipy.optimize.minimize a la fin.
            popsize=10, # Pour aller plus vite que la valeur de 15 par defaut.
            workers=1) # Pour ne pas creer de sous processus.
            # C&#39;est plus rapide de ne pas creer de sous processus que d&#39;en faire... car cloudpickle est lent!
    if self.verbose &gt;= 2:
        print(f&#34;\t\tOk: cout final = {opt_res[&#39;fun&#39;]}&#34;)
    fit_parameters_vect = opt_res[&#34;x&#34;]
    
    # Mise en forme du resultat.
    fit_parameters = {name: fit_parameters_vect[i] for i, name in enumerate(vect_labels)}
    self._calibration_parameters = {**given_parameters, **fit_parameters}
    if self.verbose:
        print(f&#34;\tOK: set_calibration terminee: {self._calibration_parameters}&#34;)
    return self._calibration_parameters</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="laue.OrderedExperiment"><code class="flex name class">
<span>class <span class="ident">OrderedExperiment</span></span>
<span>(</span><span>*args, position, time=&lt;function OrderedExperiment.&lt;lambda&gt;&gt;, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Permet de travailler sur un lot ordonne d'images. </strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>callable</code></dt>
<dd>Fonction qui a tout indice de diagrame (int)
Associe le temps ecoule depuis le debut de l'experience (float).
Les indices commencent a 0 inclu.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>callable</code></dt>
<dd>Fonction qui a tout indice de diagrame (int)
Associe la position en x et en y du diagrame
correspondant. Les indices commencent a 0 inclu.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Same as <code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Same as <code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OrderedExperiment(Experiment):
    &#34;&#34;&#34;
    ** Permet de travailler sur un lot ordonne d&#39;images. **
    &#34;&#34;&#34;
    def __init__(self, *args, position, time=(lambda ind: .0*ind), **kwargs):
        &#34;&#34;&#34;
        Parameters
        ----------
        time : callable
            Fonction qui a tout indice de diagrame (int)
            Associe le temps ecoule depuis le debut de l&#39;experience (float).
            Les indices commencent a 0 inclu.
        position : callable
            Fonction qui a tout indice de diagrame (int)
            Associe la position en x et en y du diagrame
            correspondant. Les indices commencent a 0 inclu.

        *args
            Same as ``laue.Experiment.__init__``.
        **kwargs
            Same as ``laue.Experiment.__init__``.
        &#34;&#34;&#34;
        assert hasattr(position, &#34;__call__&#34;), &#34;&#39;position&#39; has to be callable.&#34;
        assert hasattr(time, &#34;__call__&#34;), &#34;&#39;time&#39; has to be a callable.&#34;
        
        Experiment.__init__(self, *args, **kwargs)

        self.time = time
        self.position = position

        # Memory attrs.
        self._next_row = 0
        self._t_min, self._t_max = None, None
        self._x_min, self._x_max = None, None
        self._y_min, self._y_max = None, None
        self._t_dict, self._x_dict, self._y_dict = {}, {}, {}
        self._index = None

    def _full_update(self, i_max=None):
        &#34;&#34;&#34;
        ** Met a jour les tables. **

        Les elements sont calcules jusqu&#39;a ``self[i_max]`` inclu.
        &#34;&#34;&#34;
        if i_max is None:
            i_max = len(self._buff_diags)-1
        for current_row in range(self._next_row, i_max+1):
            self._update(current_row)
            self._next_row = current_row + 1

    def _update(self, i):
        &#34;&#34;&#34;
        ** Ajoute un elements aux tables de correspondances. **
        &#34;&#34;&#34;
        t, (x, y) = self.time(i), self.position(i)

        self._t_dict[t] = self._t_dict.get(t, set()) | {i}
        self._x_dict[x] = self._x_dict.get(x, set()) | {i}
        self._y_dict[y] = self._y_dict.get(y, set()) | {i}

        self._t_min = min(self._t_min, t) if self._t_min is not None else t
        self._t_max = min(self._t_max, t) if self._t_max is not None else t
        self._x_min = min(self._x_min, x) if self._x_min is not None else x
        self._x_max = min(self._x_max, x) if self._x_max is not None else x
        self._y_min = min(self._y_min, y) if self._y_min is not None else y
        self._y_max = min(self._y_max, y) if self._y_max is not None else y

    def get_shape(self):
        &#34;&#34;&#34;
        ** Recupere les 2 dimensions x, y. **

        Utilise uniquement la fonction ``position`` fourni a l&#39;initialisateur.

        Returns
        -------
        x : int
            Le nombre de diagrames sur l&#39;axe x.
        y : int
            Le nombre de diagrames pris selon l&#39;axe y.

        Examples
        --------
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; def get_positions(i):
        ...     i_mod = i % 3362
        ...     return divmod(i_mod, 82)
        ...
        &gt;&gt;&gt; exp = laue.OrderedExperiment((None,), position=get_positions)
        &gt;&gt;&gt; exp.get_shape()
        (41, 82)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def is_first():
            &#34;&#34;&#34;Renvoie True si on a fini le cycle.&#34;&#34;&#34;
            x, y = self.position(self._next_row)
            return bool(self._x_dict.get(x, set()) &amp; self._y_dict.get(y, set()))

        while not is_first():
            self._full_update(self._next_row)

        return len(self._x_dict), len(self._y_dict)

    def get_index(self):
        &#34;&#34;&#34;
        ** Recupere la matrice des index d&#39;une couche. **

        Utilise uniquement la fonction ``position`` fourni a l&#39;initialisateur.

        Returns
        -------
        np.ndarray
            La matrice 2d ayant le role d&#39;une fonction de N**2 dans N.
            A couple de rang (x, y) associ le rang &#39;ravel&#39; du diagrame.

        Examples
        --------
        &gt;&gt;&gt; import laue

        Cas balayage.
        &gt;&gt;&gt; def get_position(i):
        ...     i_mod = i % 12
        ...     return divmod(i_mod, 4)
        ...
        &gt;&gt;&gt; experiment = laue.OrderedExperiment((None,), position=get_position)
        &gt;&gt;&gt; experiment.get_index()
        array([[ 0,  1,  2,  3],
               [ 4,  5,  6,  7],
               [ 8,  9, 10, 11]], dtype=uint32)
        &gt;&gt;&gt;

        Cas non conventionel
        &gt;&gt;&gt; def get_position(i):
        ...     x = [0, 1, 1, 2, 2, 0, 2, 1, 0, 1, 0, 2]
        ...     y = [0, 2, 3, 1, 0, 2, 2, 0, 1, 1, 3, 3]
        ...     return x[i%12], y[i%12]
        ...
        &gt;&gt;&gt; experiment = laue.OrderedExperiment((None,), position=get_position)
        &gt;&gt;&gt; experiment.get_index()
        array([[ 0,  8,  5, 10],
               [ 7,  9,  1,  2],
               [ 4,  3,  6, 11]], dtype=uint32)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        def min_inter(a, b, x_ind, y_ind):
            inter = a &amp; b
            if self.ignore_errors:
                return min(inter, default=np.nan)
            if not inter:
                raise ValueError(f&#34;pour la {x_ind+1}eme coordonnee sur x&#34;
                                 f&#34;et la {y_ind+1}eme coordonnee sur y, &#34;
                                  &#34;aucun numero de diagrame n&#39;est fournis &#34;
                                  &#34;par la fonction ``self.position``.&#34;) from err
            return min(a &amp; b)

        if self._index is not None:
            return self._index

        x, y = self.get_shape()
        self._index = np.array([[
                    min_inter(ind_x_set, ind_y_set, x_ind, y_ind)
                    for y_ind, ind_y_set
                    in sorted(self._y_dict.items(), key=lambda t: t[0])]
                for x_ind, ind_x_set
                in sorted(self._x_dict.items(), key=lambda t: t[0])],
            dtype=np.uint32)
        return self._index

    def __getitem__(self, item):
        &#34;&#34;&#34;
        ** Recupere un diagrame ou un tenseur de diagrames. **

        Retourne le ou les diagrames de type ``laue.diagram.LaueDiagram``.

        Parameters
        ----------
        item
            Il faut voir cette experience comme un tableau
            numpy a 3 dimensions. La premiere est associee au temps,
            la seconde a l&#39;axe x et la derniere a l&#39;axe y.

        Returns
        -------
        diagrams
            * Si seul 1 dimension est precisee, cette methode se refere a
            la methode ``laue.experiment.base_experiment.Experiment.__getitem__``.
            * Si les 3 coordonnees sont entieres, le diagrame
            correspondant est renvoye.
            * Si l&#39;une des 3 coordonnees au moins est un slice, une array
            numpy dimension 3 est renvoyee.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; import laue
        &gt;&gt;&gt; images = (np.zeros(shape=(2, 2), dtype=np.uint16)
        ...     for _ in range(120)) # Image generator.
        &gt;&gt;&gt; def get_position(i):
        ...     i_mod = i % 12
        ...     return divmod(i_mod, 4)
        ...
        &gt;&gt;&gt; experiment = laue.OrderedExperiment(images, position=get_position)
        &gt;&gt;&gt;

        Acces directe simple.
        &gt;&gt;&gt; experiment[0]
        LaueDiagram(name=&#39;image_0&#39;)
        &gt;&gt;&gt; experiment[1]
        LaueDiagram(name=&#39;image_1&#39;)
        &gt;&gt;&gt; experiment[1:10:3]
        [LaueDiagram(name=&#39;image_1&#39;), LaueDiagram(name=&#39;image_4&#39;), LaueDiagram(name=&#39;image_7&#39;)]

        Acces directe organise.
        &gt;&gt;&gt; experiment[0, 0, 0]
        LaueDiagram(name=&#39;image_0&#39;)
        &gt;&gt;&gt; experiment[2, 3, 0]
        LaueDiagram(name=&#39;image_11&#39;)
        &gt;&gt;&gt;

        Acces slice
        &gt;&gt;&gt; experiment[:2, 1:3, 0]
        array([[[LaueDiagram(name=&#39;image_1&#39;)],
                [LaueDiagram(name=&#39;image_2&#39;)]],
        &lt;BLANKLINE&gt;
               [[LaueDiagram(name=&#39;image_5&#39;)],
                [LaueDiagram(name=&#39;image_6&#39;)]]], dtype=object)
        &gt;&gt;&gt; experiment[0, 0, 2:5]
        array([[[LaueDiagram(name=&#39;image_24&#39;), LaueDiagram(name=&#39;image_36&#39;),
                 LaueDiagram(name=&#39;image_48&#39;)]]], dtype=object)
        &gt;&gt;&gt; experiment[::-1, :2, -1]
        array([[[LaueDiagram(name=&#39;image_116&#39;)],
                [LaueDiagram(name=&#39;image_117&#39;)]],
        &lt;BLANKLINE&gt;
               [[LaueDiagram(name=&#39;image_112&#39;)],
                [LaueDiagram(name=&#39;image_113&#39;)]],
        &lt;BLANKLINE&gt;
               [[LaueDiagram(name=&#39;image_108&#39;)],
                [LaueDiagram(name=&#39;image_109&#39;)]]], dtype=object)
        &gt;&gt;&gt;
        &#34;&#34;&#34;
        if isinstance(item, (slice, int, np.integer)):
            return super().__getitem__(item)

        if not isinstance(item, tuple):
            raise ValueError(&#34;La clef doit etre de type, int, slice or tuple &#34;
                f&#34;not {type(item).__name__}.&#34;)
        if len(item) != 3:
            raise ValueError(&#34;Si l&#39;element est un tuple, il doit contenir 3 &#34;
                f&#34; elements. x, y et t. Il en contient {len(item)}.&#34;)
        x, y, t = item
        size = np.prod(self.get_shape(), dtype=np.uint32)

        if all(isinstance(coord, (int, np.integer)) for coord in item):
            return super().__getitem__(self.get_index()[x, y] + t*size)

        x_index = np.arange(self.get_shape()[0])[x] if isinstance(x, slice) else [x]
        y_index = np.arange(self.get_shape()[1])[y] if isinstance(y, slice) else [y]
        if isinstance(t, slice): # Si il est pas nescessaire de lire tous les diagrames.
            if (    (t.start is None or t.start &gt;= 0)
                and (t.stop is not None and t.stop &gt; 0)
                and (t.step is None or t.step &gt; 0)
                ) or ( # cas croissant ou cas decroissant
                    (t.start is not None and t.start &gt; 0)
                and (t.stop is None or t.stop &gt;= 0)
                and (t.step is not None and t.step &lt; 0)):
                t_max = max(
                    (0 if t.stop is None else t.stop), # Cas croissant.
                    (0 if t.start is None else t.start)) # Cas decroissant.
            else:
                if len(self) == 0: # Si il faut lire tous les diagrames.
                    for _ in self:
                        pass
                t_max = (len(self) // np.prod(self.get_shape())) - 1
            t_index = np.arange(t_max+1)[t]
        else:
            t_index = [t]

        table = np.empty((len(x_index), len(y_index), len(t_index)), dtype=object)
        table[...] = [[[
                    self[x_, y_, t_]
                    for t_ in t_index
                ]
                for y_ in y_index
            ]
            for x_ in x_index
        ]
        return table</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="laue.experiment.base_experiment.Experiment" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment">Experiment</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="laue.OrderedExperiment.__getitem__"><code class="name flex">
<span>def <span class="ident">__getitem__</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere un diagrame ou un tenseur de diagrames. </strong></p>
<p>Retourne le ou les diagrames de type <code><a title="laue.diagram.LaueDiagram" href="diagram.html#laue.diagram.LaueDiagram">LaueDiagram</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>Il faut voir cette experience comme un tableau
numpy a 3 dimensions. La premiere est associee au temps,
la seconde a l'axe x et la derniere a l'axe y.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>diagrams</code></dt>
<dd>
<ul>
<li>Si seul 1 dimension est precisee, cette methode se refere a
la methode <code><a title="laue.experiment.base_experiment.Experiment.__getitem__" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.__getitem__">Experiment.__getitem__()</a></code>.</li>
<li>Si les 3 coordonnees sont entieres, le diagrame
correspondant est renvoye.</li>
<li>Si l'une des 3 coordonnees au moins est un slice, une array
numpy dimension 3 est renvoyee.</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import laue
&gt;&gt;&gt; images = (np.zeros(shape=(2, 2), dtype=np.uint16)
...     for _ in range(120)) # Image generator.
&gt;&gt;&gt; def get_position(i):
...     i_mod = i % 12
...     return divmod(i_mod, 4)
...
&gt;&gt;&gt; experiment = laue.OrderedExperiment(images, position=get_position)
&gt;&gt;&gt;
</code></pre>
<p>Acces directe simple.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; experiment[0]
LaueDiagram(name='image_0')
&gt;&gt;&gt; experiment[1]
LaueDiagram(name='image_1')
&gt;&gt;&gt; experiment[1:10:3]
[LaueDiagram(name='image_1'), LaueDiagram(name='image_4'), LaueDiagram(name='image_7')]
</code></pre>
<p>Acces directe organise.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; experiment[0, 0, 0]
LaueDiagram(name='image_0')
&gt;&gt;&gt; experiment[2, 3, 0]
LaueDiagram(name='image_11')
&gt;&gt;&gt;
</code></pre>
<p>Acces slice</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; experiment[:2, 1:3, 0]
array([[[LaueDiagram(name='image_1')],
        [LaueDiagram(name='image_2')]],
&lt;BLANKLINE&gt;
       [[LaueDiagram(name='image_5')],
        [LaueDiagram(name='image_6')]]], dtype=object)
&gt;&gt;&gt; experiment[0, 0, 2:5]
array([[[LaueDiagram(name='image_24'), LaueDiagram(name='image_36'),
         LaueDiagram(name='image_48')]]], dtype=object)
&gt;&gt;&gt; experiment[::-1, :2, -1]
array([[[LaueDiagram(name='image_116')],
        [LaueDiagram(name='image_117')]],
&lt;BLANKLINE&gt;
       [[LaueDiagram(name='image_112')],
        [LaueDiagram(name='image_113')]],
&lt;BLANKLINE&gt;
       [[LaueDiagram(name='image_108')],
        [LaueDiagram(name='image_109')]]], dtype=object)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __getitem__(self, item):
    &#34;&#34;&#34;
    ** Recupere un diagrame ou un tenseur de diagrames. **

    Retourne le ou les diagrames de type ``laue.diagram.LaueDiagram``.

    Parameters
    ----------
    item
        Il faut voir cette experience comme un tableau
        numpy a 3 dimensions. La premiere est associee au temps,
        la seconde a l&#39;axe x et la derniere a l&#39;axe y.

    Returns
    -------
    diagrams
        * Si seul 1 dimension est precisee, cette methode se refere a
        la methode ``laue.experiment.base_experiment.Experiment.__getitem__``.
        * Si les 3 coordonnees sont entieres, le diagrame
        correspondant est renvoye.
        * Si l&#39;une des 3 coordonnees au moins est un slice, une array
        numpy dimension 3 est renvoyee.

    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; images = (np.zeros(shape=(2, 2), dtype=np.uint16)
    ...     for _ in range(120)) # Image generator.
    &gt;&gt;&gt; def get_position(i):
    ...     i_mod = i % 12
    ...     return divmod(i_mod, 4)
    ...
    &gt;&gt;&gt; experiment = laue.OrderedExperiment(images, position=get_position)
    &gt;&gt;&gt;

    Acces directe simple.
    &gt;&gt;&gt; experiment[0]
    LaueDiagram(name=&#39;image_0&#39;)
    &gt;&gt;&gt; experiment[1]
    LaueDiagram(name=&#39;image_1&#39;)
    &gt;&gt;&gt; experiment[1:10:3]
    [LaueDiagram(name=&#39;image_1&#39;), LaueDiagram(name=&#39;image_4&#39;), LaueDiagram(name=&#39;image_7&#39;)]

    Acces directe organise.
    &gt;&gt;&gt; experiment[0, 0, 0]
    LaueDiagram(name=&#39;image_0&#39;)
    &gt;&gt;&gt; experiment[2, 3, 0]
    LaueDiagram(name=&#39;image_11&#39;)
    &gt;&gt;&gt;

    Acces slice
    &gt;&gt;&gt; experiment[:2, 1:3, 0]
    array([[[LaueDiagram(name=&#39;image_1&#39;)],
            [LaueDiagram(name=&#39;image_2&#39;)]],
    &lt;BLANKLINE&gt;
           [[LaueDiagram(name=&#39;image_5&#39;)],
            [LaueDiagram(name=&#39;image_6&#39;)]]], dtype=object)
    &gt;&gt;&gt; experiment[0, 0, 2:5]
    array([[[LaueDiagram(name=&#39;image_24&#39;), LaueDiagram(name=&#39;image_36&#39;),
             LaueDiagram(name=&#39;image_48&#39;)]]], dtype=object)
    &gt;&gt;&gt; experiment[::-1, :2, -1]
    array([[[LaueDiagram(name=&#39;image_116&#39;)],
            [LaueDiagram(name=&#39;image_117&#39;)]],
    &lt;BLANKLINE&gt;
           [[LaueDiagram(name=&#39;image_112&#39;)],
            [LaueDiagram(name=&#39;image_113&#39;)]],
    &lt;BLANKLINE&gt;
           [[LaueDiagram(name=&#39;image_108&#39;)],
            [LaueDiagram(name=&#39;image_109&#39;)]]], dtype=object)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    if isinstance(item, (slice, int, np.integer)):
        return super().__getitem__(item)

    if not isinstance(item, tuple):
        raise ValueError(&#34;La clef doit etre de type, int, slice or tuple &#34;
            f&#34;not {type(item).__name__}.&#34;)
    if len(item) != 3:
        raise ValueError(&#34;Si l&#39;element est un tuple, il doit contenir 3 &#34;
            f&#34; elements. x, y et t. Il en contient {len(item)}.&#34;)
    x, y, t = item
    size = np.prod(self.get_shape(), dtype=np.uint32)

    if all(isinstance(coord, (int, np.integer)) for coord in item):
        return super().__getitem__(self.get_index()[x, y] + t*size)

    x_index = np.arange(self.get_shape()[0])[x] if isinstance(x, slice) else [x]
    y_index = np.arange(self.get_shape()[1])[y] if isinstance(y, slice) else [y]
    if isinstance(t, slice): # Si il est pas nescessaire de lire tous les diagrames.
        if (    (t.start is None or t.start &gt;= 0)
            and (t.stop is not None and t.stop &gt; 0)
            and (t.step is None or t.step &gt; 0)
            ) or ( # cas croissant ou cas decroissant
                (t.start is not None and t.start &gt; 0)
            and (t.stop is None or t.stop &gt;= 0)
            and (t.step is not None and t.step &lt; 0)):
            t_max = max(
                (0 if t.stop is None else t.stop), # Cas croissant.
                (0 if t.start is None else t.start)) # Cas decroissant.
        else:
            if len(self) == 0: # Si il faut lire tous les diagrames.
                for _ in self:
                    pass
            t_max = (len(self) // np.prod(self.get_shape())) - 1
        t_index = np.arange(t_max+1)[t]
    else:
        t_index = [t]

    table = np.empty((len(x_index), len(y_index), len(t_index)), dtype=object)
    table[...] = [[[
                self[x_, y_, t_]
                for t_ in t_index
            ]
            for y_ in y_index
        ]
        for x_ in x_index
    ]
    return table</code></pre>
</details>
</dd>
<dt id="laue.OrderedExperiment.get_index"><code class="name flex">
<span>def <span class="ident">get_index</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere la matrice des index d'une couche. </strong></p>
<p>Utilise uniquement la fonction <code>position</code> fourni a l'initialisateur.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>La matrice 2d ayant le role d'une fonction de N**2 dans N.
A couple de rang (x, y) associ le rang 'ravel' du diagrame.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
</code></pre>
<p>Cas balayage.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def get_position(i):
...     i_mod = i % 12
...     return divmod(i_mod, 4)
...
&gt;&gt;&gt; experiment = laue.OrderedExperiment((None,), position=get_position)
&gt;&gt;&gt; experiment.get_index()
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]], dtype=uint32)
&gt;&gt;&gt;
</code></pre>
<p>Cas non conventionel</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def get_position(i):
...     x = [0, 1, 1, 2, 2, 0, 2, 1, 0, 1, 0, 2]
...     y = [0, 2, 3, 1, 0, 2, 2, 0, 1, 1, 3, 3]
...     return x[i%12], y[i%12]
...
&gt;&gt;&gt; experiment = laue.OrderedExperiment((None,), position=get_position)
&gt;&gt;&gt; experiment.get_index()
array([[ 0,  8,  5, 10],
       [ 7,  9,  1,  2],
       [ 4,  3,  6, 11]], dtype=uint32)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_index(self):
    &#34;&#34;&#34;
    ** Recupere la matrice des index d&#39;une couche. **

    Utilise uniquement la fonction ``position`` fourni a l&#39;initialisateur.

    Returns
    -------
    np.ndarray
        La matrice 2d ayant le role d&#39;une fonction de N**2 dans N.
        A couple de rang (x, y) associ le rang &#39;ravel&#39; du diagrame.

    Examples
    --------
    &gt;&gt;&gt; import laue

    Cas balayage.
    &gt;&gt;&gt; def get_position(i):
    ...     i_mod = i % 12
    ...     return divmod(i_mod, 4)
    ...
    &gt;&gt;&gt; experiment = laue.OrderedExperiment((None,), position=get_position)
    &gt;&gt;&gt; experiment.get_index()
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]], dtype=uint32)
    &gt;&gt;&gt;

    Cas non conventionel
    &gt;&gt;&gt; def get_position(i):
    ...     x = [0, 1, 1, 2, 2, 0, 2, 1, 0, 1, 0, 2]
    ...     y = [0, 2, 3, 1, 0, 2, 2, 0, 1, 1, 3, 3]
    ...     return x[i%12], y[i%12]
    ...
    &gt;&gt;&gt; experiment = laue.OrderedExperiment((None,), position=get_position)
    &gt;&gt;&gt; experiment.get_index()
    array([[ 0,  8,  5, 10],
           [ 7,  9,  1,  2],
           [ 4,  3,  6, 11]], dtype=uint32)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def min_inter(a, b, x_ind, y_ind):
        inter = a &amp; b
        if self.ignore_errors:
            return min(inter, default=np.nan)
        if not inter:
            raise ValueError(f&#34;pour la {x_ind+1}eme coordonnee sur x&#34;
                             f&#34;et la {y_ind+1}eme coordonnee sur y, &#34;
                              &#34;aucun numero de diagrame n&#39;est fournis &#34;
                              &#34;par la fonction ``self.position``.&#34;) from err
        return min(a &amp; b)

    if self._index is not None:
        return self._index

    x, y = self.get_shape()
    self._index = np.array([[
                min_inter(ind_x_set, ind_y_set, x_ind, y_ind)
                for y_ind, ind_y_set
                in sorted(self._y_dict.items(), key=lambda t: t[0])]
            for x_ind, ind_x_set
            in sorted(self._x_dict.items(), key=lambda t: t[0])],
        dtype=np.uint32)
    return self._index</code></pre>
</details>
</dd>
<dt id="laue.OrderedExperiment.get_shape"><code class="name flex">
<span>def <span class="ident">get_shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><strong> Recupere les 2 dimensions x, y. </strong></p>
<p>Utilise uniquement la fonction <code>position</code> fourni a l'initialisateur.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>Le nombre de diagrames sur l'axe x.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>Le nombre de diagrames pris selon l'axe y.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import laue
&gt;&gt;&gt; def get_positions(i):
...     i_mod = i % 3362
...     return divmod(i_mod, 82)
...
&gt;&gt;&gt; exp = laue.OrderedExperiment((None,), position=get_positions)
&gt;&gt;&gt; exp.get_shape()
(41, 82)
&gt;&gt;&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shape(self):
    &#34;&#34;&#34;
    ** Recupere les 2 dimensions x, y. **

    Utilise uniquement la fonction ``position`` fourni a l&#39;initialisateur.

    Returns
    -------
    x : int
        Le nombre de diagrames sur l&#39;axe x.
    y : int
        Le nombre de diagrames pris selon l&#39;axe y.

    Examples
    --------
    &gt;&gt;&gt; import laue
    &gt;&gt;&gt; def get_positions(i):
    ...     i_mod = i % 3362
    ...     return divmod(i_mod, 82)
    ...
    &gt;&gt;&gt; exp = laue.OrderedExperiment((None,), position=get_positions)
    &gt;&gt;&gt; exp.get_shape()
    (41, 82)
    &gt;&gt;&gt;
    &#34;&#34;&#34;
    def is_first():
        &#34;&#34;&#34;Renvoie True si on a fini le cycle.&#34;&#34;&#34;
        x, y = self.position(self._next_row)
        return bool(self._x_dict.get(x, set()) &amp; self._y_dict.get(y, set()))

    while not is_first():
        self._full_update(self._next_row)

    return len(self._x_dict), len(self._y_dict)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="laue.experiment.base_experiment.Experiment" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment">Experiment</a></b></code>:
<ul class="hlist">
<li><code><a title="laue.experiment.base_experiment.Experiment.__iter__" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.__iter__">__iter__</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.__len__" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.__len__">__len__</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.find_subsets" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.find_subsets">find_subsets</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.find_zone_axes" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.find_zone_axes">find_zone_axes</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.get_diagrams" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.get_diagrams">get_diagrams</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.get_images_shape" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.get_images_shape">get_images_shape</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.get_mean" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.get_mean">get_mean</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.read_images" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.read_images">read_images</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.save_file" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.save_file">save_file</a></code></li>
<li><code><a title="laue.experiment.base_experiment.Experiment.set_calibration" href="experiment/base_experiment.html#laue.experiment.base_experiment.Experiment.set_calibration">set_calibration</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#permet-de-manipuler-un-lot-de-diagrammes-de-laue">Permet de manipuler un lot de diagrammes de laue.</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="laue.core" href="core/index.html">laue.core</a></code></li>
<li><code><a title="laue.diagram" href="diagram.html">laue.diagram</a></code></li>
<li><code><a title="laue.experiment" href="experiment/index.html">laue.experiment</a></code></li>
<li><code><a title="laue.spot" href="spot.html">laue.spot</a></code></li>
<li><code><a title="laue.utilities" href="utilities/index.html">laue.utilities</a></code></li>
<li><code><a title="laue.zone_axis" href="zone_axis.html">laue.zone_axis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="laue.atomic_find_subsets" href="#laue.atomic_find_subsets">atomic_find_subsets</a></code></li>
<li><code><a title="laue.atomic_find_zone_axes" href="#laue.atomic_find_zone_axes">atomic_find_zone_axes</a></code></li>
<li><code><a title="laue.atomic_pic_search" href="#laue.atomic_pic_search">atomic_pic_search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="laue.Experiment" href="#laue.Experiment">Experiment</a></code></h4>
<ul class="two-column">
<li><code><a title="laue.Experiment.__getitem__" href="#laue.Experiment.__getitem__">__getitem__</a></code></li>
<li><code><a title="laue.Experiment.__iter__" href="#laue.Experiment.__iter__">__iter__</a></code></li>
<li><code><a title="laue.Experiment.__len__" href="#laue.Experiment.__len__">__len__</a></code></li>
<li><code><a title="laue.Experiment.find_subsets" href="#laue.Experiment.find_subsets">find_subsets</a></code></li>
<li><code><a title="laue.Experiment.find_zone_axes" href="#laue.Experiment.find_zone_axes">find_zone_axes</a></code></li>
<li><code><a title="laue.Experiment.get_diagrams" href="#laue.Experiment.get_diagrams">get_diagrams</a></code></li>
<li><code><a title="laue.Experiment.get_images_shape" href="#laue.Experiment.get_images_shape">get_images_shape</a></code></li>
<li><code><a title="laue.Experiment.get_mean" href="#laue.Experiment.get_mean">get_mean</a></code></li>
<li><code><a title="laue.Experiment.read_images" href="#laue.Experiment.read_images">read_images</a></code></li>
<li><code><a title="laue.Experiment.save_file" href="#laue.Experiment.save_file">save_file</a></code></li>
<li><code><a title="laue.Experiment.set_calibration" href="#laue.Experiment.set_calibration">set_calibration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="laue.OrderedExperiment" href="#laue.OrderedExperiment">OrderedExperiment</a></code></h4>
<ul class="">
<li><code><a title="laue.OrderedExperiment.__getitem__" href="#laue.OrderedExperiment.__getitem__">__getitem__</a></code></li>
<li><code><a title="laue.OrderedExperiment.get_index" href="#laue.OrderedExperiment.get_index">get_index</a></code></li>
<li><code><a title="laue.OrderedExperiment.get_shape" href="#laue.OrderedExperiment.get_shape">get_shape</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>